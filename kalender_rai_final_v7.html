<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Kalender V Beta</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        darkbg: '#121212',
                        darkcard: '#1E1E1E'
                    }
                }
            }
        }
    </script>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-storage-compat.js"></script>
    
    <!-- Fallback to 12.6.0 if 10.7.1 fails -->
    <script>
        window.firebaseLoadFallback = function() {
            if (typeof firebase === 'undefined') {
                console.warn('Firebase 10.7.1 failed, attempting 12.6.0 fallback...');
                const scripts = [
                    'https://www.gstatic.com/firebasejs/12.6.0/firebase-app-compat.js',
                    'https://www.gstatic.com/firebasejs/12.6.0/firebase-auth-compat.js',
                    'https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore-compat.js',
                    'https://www.gstatic.com/firebasejs/12.6.0/firebase-storage-compat.js'
                ];
                return Promise.all(scripts.map(src => {
                    return new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        script.src = src;
                        script.onload = resolve;
                        script.onerror = reject;
                        document.head.appendChild(script);
                    });
                }));
            }
            return Promise.resolve();
        };
    </script>

    <style>
        body { -webkit-tap-highlight-color: transparent; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; overscroll-behavior-y: none; }
        ::-webkit-scrollbar { width: 0; background: transparent; }
        .slide-up { animation: slideUp 0.3s cubic-bezier(0.2, 0.8, 0.2, 1); }
        .fade-in { animation: fadeIn 0.3s ease-out; }
        .scale-in { animation: scaleIn 0.2s ease-out; }
        @keyframes slideUp { from { transform: translateY(100%); } to { transform: translateY(0); } }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes scaleIn { from { transform: scale(0.9); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        
        .details-wrapper { display: grid; grid-template-rows: 0fr; transition: grid-template-rows 0.3s ease-out; }
        .details-wrapper.open { grid-template-rows: 1fr; }
        .details-inner { overflow: hidden; }
        
        /* Checkbox - Updated for new themes */
        .custom-checkbox {
            appearance: none; background-color: #f1f5f9; margin: 0; color: currentColor; width: 1.25em; height: 1.25em;
            border: 2px solid #cbd5e1; border-radius: 0.35em; display: grid; place-content: center; transition: all 0.2s;
        }
        .dark .custom-checkbox { background-color: #1a1a1a; border-color: #333333; }
        .custom-checkbox::before {
            content: ""; width: 0.65em; height: 0.65em; transform: scale(0); transition: 120ms transform;
            box-shadow: inset 1em 1em white; transform-origin: center;
            clip-path: polygon(14% 44%, 0 65%, 50% 100%, 100% 16%, 80% 0%, 43% 62%);
        }
        .custom-checkbox:checked { background-color: #2563eb; border-color: #2563eb; }
        .dark .custom-checkbox:checked { background-color: #4da3ff; border-color: #4da3ff; }
        .custom-checkbox:checked::before { transform: scale(1); }
        .dark .custom-checkbox:checked::before { box-shadow: inset 1em 1em #000000; }
        
        .no-select { user-select: none; }
    
        /* Attention blink (today) */
        .blink-attn { position: relative; }
        .blink-attn::after{
            content:"";
            position:absolute;
            inset:-5px;
            border-radius: 18px;
            border: 2px solid currentColor;
            opacity:0;
            pointer-events:none;
            animation: pwBlinkRing 1s ease-in-out infinite;
        }
        @keyframes pwBlinkRing{
            0%,100%{ opacity:0; transform: scale(0.98); }
            50%{ opacity:0.45; transform: scale(1.04); }
        }
        
        /* Theme Palettes - Refined for Light (elegant) and Dark (AMOLED) */
        :root {
            /* Light Theme - Elegant white with soft contrast */
            --primary: #2563eb;
            --primary-light: #f8f9fb;
            --accent: #4da3ff;
            --bg: #f8f9fb;
            --card: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --shadow: rgba(0, 0, 0, 0.05);
        }
        
        :root.pastel {
            /* Pastel Theme - Secondary option */
            --primary: #8b5cf6;
            --primary-light: #faf5ff;
            --accent: #a78bfa;
            --bg: #faf5ff;
            --card: #f5f3ff;
            --text: #4c1d95;
            --text-secondary: #7c3aed;
            --border: #e9d5ff;
            --shadow: rgba(139, 92, 246, 0.08);
        }
        
        :root.high-contrast {
            /* High-contrast Theme - Secondary option */
            --primary: #000000;
            --primary-light: #ffffff;
            --accent: #0066cc;
            --bg: #ffffff;
            --card: #f5f5f5;
            --text: #000000;
            --text-secondary: #333333;
            --border: #cccccc;
            --shadow: rgba(0, 0, 0, 0.15);
        }
        
        .dark:root {
            /* Dark Theme - True AMOLED with muted surfaces */
            --primary: #4da3ff;
            --primary-light: #000000;
            --accent: #2563eb;
            --bg: #000000;
            --card: #0f0f0f;
            --text: #e8ecf5;
            --text-secondary: #9ca3af;
            --border: #1f1f1f;
            --shadow: rgba(255, 255, 255, 0.03);
        }
        
        .dark:root.pastel {
            /* Dark Pastel - Secondary option */
            --primary: #a78bfa;
            --primary-light: #1a1a1a;
            --accent: #8b5cf6;
            --bg: #0a0a0a;
            --card: #1a1a1a;
            --text: #e9d5ff;
            --text-secondary: #c4b5fd;
            --border: #2a2a2a;
            --shadow: rgba(167, 139, 250, 0.05);
        }
        
        .dark:root.high-contrast {
            /* Dark High-contrast - Secondary option */
            --primary: #ffffff;
            --primary-light: #000000;
            --accent: #00aaff;
            --bg: #000000;
            --card: #1a1a1a;
            --text: #ffffff;
            --text-secondary: #cccccc;
            --border: #333333;
            --shadow: rgba(255, 255, 255, 0.08);
        }
        
        /* Drag and Drop - Updated for new themes */
        .draggable-event {
            cursor: move;
            user-select: none;
        }
        
        .drop-zone {
            transition: background-color 0.2s, border-color 0.2s;
        }
        
        .drop-zone.drag-over {
            background-color: rgba(37, 99, 235, 0.08);
            border: 2px dashed #2563eb;
        }
        
        .dark .drop-zone.drag-over {
            background-color: rgba(77, 163, 255, 0.1);
            border-color: #4da3ff;
        }
        
        /* Focus States for Accessibility */
        button:focus-visible, input:focus-visible, select:focus-visible, textarea:focus-visible {
            outline: 2px solid #2563eb;
            outline-offset: 2px;
        }
        
        .dark button:focus-visible, .dark input:focus-visible, .dark select:focus-visible, .dark textarea:focus-visible {
            outline-color: #4da3ff;
        }
        
        /* Improved transitions */
        button, input, select, textarea {
            transition: all 0.2s ease;
        }
            
    </style>
</head>
<body class="bg-[#f8f9fb] text-[#1e293b] dark:bg-[#000000] dark:text-[#e8ecf5] transition-colors duration-300">

    <div id="loading" class="fixed inset-0 flex items-center justify-center bg-[#f8f9fb] dark:bg-[#000000] z-50">
        <div className="text-center">
            <div class="w-12 h-12 border-4 border-gray-200 border-t-[#2563eb] dark:border-gray-900 dark:border-t-[#4da3ff] rounded-full animate-spin mb-4 mx-auto"></div>
            <p class="text-sm font-bold text-gray-400 uppercase tracking-widest">Lade...</p>
        </div>
    </div>

    <div id="root"></div>

    <script>
        window.onerror = function(msg, url, line) {
            document.getElementById('loading').style.display = 'none';
            console.error(msg);
        };
    </script>

    <script type="text/babel">
        // --- ICONS ---
        const Icon = ({ name, size = 20, className = "" }) => {
            const icons = {
                chevronLeft: <path d="M15 18l-6-6 6-6" />,
                chevronRight: <path d="M9 18l6-6-6-6" />,
                chevronDown: <path d="M6 9l6 6 6-6" />,
                plus: <path d="M12 5v14M5 12h14" />,
                x: <path d="M18 6L6 18M6 6l12 12" />,
                trash: <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2" />,
                check: <path d="M20 6L9 17l-5-5" />,
                bell: <path d="M18 8A6 6 0 006 8c0 7-3 9-3 9h18s-3-2-3-9" />,
                settings: <path d="M12.22 2h-.44a2 2 0 00-2 2v.18a2 2 0 01-1 1.73l-.43.25a2 2 0 01-2 0l-.18-.08a2 2 0 00-2 2v.44a2 2 0 002 2h.18a2 2 0 011.73 1l.25.43a2 2 0 010 2l-.08.18a2 2 0 00-2-2z" />,
                calendar: <path d="M19 4H5a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2V6a2 2 0 00-2-2zm-1-2v4M6 2v4m-4 6h20" />,
                sun: <path d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M12 7a5 5 0 110 10 5 5 0 010-10z" />,
                moon: <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z" />,
                send: <path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z" />,
                image: <><rect x="3" y="3" width="18" height="18" rx="2" ry="2" /><circle cx="8.5" cy="8.5" r="1.5" /><path d="M21 15l-5-5L5 21" /></>,
                camera: <><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h3l2-3h8l2 3h3a2 2 0 0 1 2 2z" /><circle cx="12" cy="13" r="4" /></>,
                mic: <><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z" /><path d="M19 10v2a7 7 0 0 1-14 0v-2" /><line x1="12" y1="19" x2="12" y2="23" /><line x1="8" y1="23" x2="16" y2="23" /></>,
                play: <polygon points="5 3 19 12 5 21 5 3" />,
                pause: <><rect x="6" y="4" width="4" height="16" /><rect x="14" y="4" width="4" height="16" /></>,
                stop: <rect x="7" y="7" width="10" height="10" rx="2" />, 
                search: <path d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />,
                lock: <path d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a7 7 0 00-14 0v2" />,
                user: <path d="M20 21v-2a4 4 0 00-4-4H8a4 4 0 00-4 4v2M12 11a4 4 0 100-8 4 4 0 000 8z" />,
                alignLeft: <path d="M17 10H3M21 6H3M21 14H3M17 18H3" />,
                clock: <><circle cx="12" cy="12" r="10" /><polyline points="12 6 12 12 16 14" /></>,
                repeat: <><path d="M17 1l4 4-4 4" /><path d="M3 11V9a4 4 0 014-4h14" /><path d="M7 23l-4-4 4-4" /><path d="M21 13v2a4 4 0 01-4 4H3" /></>,
                layers: <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5" />,
                grid: <><rect x="3" y="3" width="7" height="7" /><rect x="14" y="3" width="7" height="7" /><rect x="14" y="14" width="7" height="7" /><rect x="3" y="14" width="7" height="7" /></>,
                tag: <><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z" /><line x1="7" y1="7" x2="7.01" y2="7" /></>,
                briefcase: <><rect x="2" y="7" width="20" height="14" rx="2" ry="2" /><path d="M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16" /></>
            };
            return (
                <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                    {icons[name] || <circle cx="12" cy="12" r="10" />}
                </svg>
            );
        };

        // --- FIREBASE CONFIG WITH ROBUST INITIALIZATION ---
        const firebaseConfig = {
            apiKey: "AIzaSyAI4AlNcXHBVnlJtqBRl_4vmNvDEghpk88",
            authDomain: "planwise-cr.firebaseapp.com",
            projectId: "planwise-cr",
            storageBucket: "planwise-cr.appspot.com",
            messagingSenderId: "567060346362",
            appId: "1:567060346362:web:aa034bea9c41274b512043",
            measurementId: "G-30SGGBT9BY"
        };

        // Initialize Firebase with error handling and fallback
        let auth, db, storage;
        try {
            if (typeof firebase === 'undefined') {
                throw new Error('Firebase SDK not loaded');
            }
            if (!firebase.apps || !firebase.apps.length) {
                firebase.initializeApp(firebaseConfig);
            }
            auth = firebase.auth ? firebase.auth() : null;
            db = firebase.firestore ? firebase.firestore() : null;
            storage = firebase.storage ? firebase.storage() : null;
            
            if (!auth || !db || !storage) {
                console.error('Firebase services not fully available');
            }
        } catch (err) {
            console.error('Firebase initialization error:', err);
            // Attempt fallback loading
            window.firebaseLoadFallback().then(() => {
                if (typeof firebase !== 'undefined' && firebase.apps && !firebase.apps.length) {
                    firebase.initializeApp(firebaseConfig);
                    auth = firebase.auth();
                    db = firebase.firestore();
                    storage = firebase.storage();
                }
            }).catch(fallbackErr => {
                console.error('Firebase fallback failed:', fallbackErr);
            });
        }

        // --- CONSTANTS ---
        const { useState, useEffect, useRef, useMemo } = React;
        const ALL_CALENDARS = 'ALL';
        const ROLES = { ADMIN: 'admin', EDITOR: 'editor', VIEWER: 'viewer' };
        const MS_PER_DAY = 86400000; // 24 hours in milliseconds
        const MS_PER_HOUR = 3600000; // 1 hour in milliseconds
        const MAX_RECURRENCE_YEAR = 2099;
        
        const CALENDAR_COLORS = [
            { name: 'Orange', hex: '#F97316', bg: 'bg-orange-500', light: 'bg-orange-50 dark:bg-orange-900/30', text: 'text-orange-500' },
            { name: 'Blue', hex: '#3B82F6', bg: 'bg-blue-500', light: 'bg-blue-50 dark:bg-blue-900/30', text: 'text-blue-500' },
            { name: 'Green', hex: '#22C55E', bg: 'bg-green-500', light: 'bg-green-50 dark:bg-green-900/30', text: 'text-green-500' },
            { name: 'Purple', hex: '#A855F7', bg: 'bg-purple-500', light: 'bg-purple-50 dark:bg-purple-900/30', text: 'text-purple-500' },
            { name: 'Red', hex: '#EF4444', bg: 'bg-red-500', light: 'bg-red-50 dark:bg-red-900/30', text: 'text-red-500' },
        ];
        
        const DEFAULT_CATEGORIES = {
            'Arbeit': ['Meeting', 'Deadline', 'Home Office', 'Call'],
            'Privat': ['Hobby', 'Date', 'Urlaub', 'Freunde'],
            'Haushalt': ['Einkaufen', 'Putzen', 'Kochen'],
            'Gesundheit': ['Arzt', 'Sport', 'Zahnarzt'],
            'Wichtig': ['Erinnerung', 'BehÃ¶rde', 'Frist']
        };
        
        // Category to color mapping for automatic coloring
        const CATEGORY_COLORS = {
            'Arbeit': { bg: 'bg-blue-500', light: 'bg-blue-50 dark:bg-blue-900/30', text: 'text-blue-500', hex: '#3B82F6' },
            'Privat': { bg: 'bg-purple-500', light: 'bg-purple-50 dark:bg-purple-900/30', text: 'text-purple-500', hex: '#A855F7' },
            'Haushalt': { bg: 'bg-green-500', light: 'bg-green-50 dark:bg-green-900/30', text: 'text-green-500', hex: '#22C55E' },
            'Gesundheit': { bg: 'bg-red-500', light: 'bg-red-50 dark:bg-red-900/30', text: 'text-red-500', hex: '#EF4444' },
            'Wichtig': { bg: 'bg-orange-500', light: 'bg-orange-50 dark:bg-orange-900/30', text: 'text-orange-500', hex: '#F97316' }
        };

        // --- ARCHIV HELPERS ---
        const generateSecretId = () => {
            // 10 Zeichen, ohne leicht verwechselbare Zeichen (0/O, 1/I, etc.)
            const alphabet = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let out = '';
            for (let i = 0; i < 10; i++) out += alphabet[Math.floor(Math.random() * alphabet.length)];
            return out;
        };

        const bytesToBase64 = (bytes) => {
            let bin = '';
            bytes.forEach(b => bin += String.fromCharCode(b));
            return btoa(bin);
        };

        const base64ToBytes = (b64) => {
            const bin = atob(b64);
            const bytes = new Uint8Array(bin.length);
            for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
            return bytes;
        };
        const MEDIA_B64_LIMIT = 900000; // ~900KB (~0.9MB) to stay below Firestore 1MB doc limit incl. base64 overhead
        const IMAGE_EXT_PATTERN = /\.(jpe?g|png|webp|gif|heic|heif|bmp|avif)$/i;
        const isImageFile = (file) => {
            if (!file) return false;
            const t = (file?.type || '').toLowerCase();
            const fileName = file?.name || '';
            const typeIsImage = t.startsWith('image/');
            const nameMatches = IMAGE_EXT_PATTERN.test(fileName);
            return typeIsImage || nameMatches;
        };

        const canUseSecretCrypto = () => {
            return !!(window.crypto && window.crypto.subtle);
        };

        // --- NEW FEATURES HELPERS ---
        
        // Quick Add Natural Language Parser (German)
        const parseQuickAdd = (input) => {
            const result = { date: null, time: null, durationMin: 60, title: '' };
            let remaining = input.trim();
            
            // Parse date keywords
            const today = new Date();
            const dateKeywords = {
                'heute': 0, 
                'morgen': 1, 
                'Ã¼bermorgen': 2,
                'mo': getNextWeekday(today, 1), 'montag': getNextWeekday(today, 1),
                'di': getNextWeekday(today, 2), 'dienstag': getNextWeekday(today, 2),
                'mi': getNextWeekday(today, 3), 'mittwoch': getNextWeekday(today, 3),
                'do': getNextWeekday(today, 4), 'donnerstag': getNextWeekday(today, 4),
                'fr': getNextWeekday(today, 5), 'freitag': getNextWeekday(today, 5),
                'sa': getNextWeekday(today, 6), 'samstag': getNextWeekday(today, 6),
                'so': getNextWeekday(today, 0), 'sonntag': getNextWeekday(today, 0)
            };
            
            for (const [keyword, offset] of Object.entries(dateKeywords)) {
                const regex = new RegExp(`\\b${keyword}\\b`, 'i');
                if (regex.test(remaining)) {
                    if (typeof offset === 'number') {
                        result.date = new Date(today);
                        result.date.setDate(today.getDate() + offset);
                    } else {
                        result.date = offset;
                    }
                    remaining = remaining.replace(regex, '').trim();
                    break;
                }
            }
            
            // Parse time (15, 15:30, 15.30, "15 Uhr")
            const timePatterns = [
                /\b(\d{1,2}):(\d{2})\b/,  // 15:30
                /\b(\d{1,2})\.(\d{2})\b/,  // 15.30
                /\b(\d{1,2})\s*uhr\b/i,    // 15 Uhr
                /\b(\d{1,2})\b(?!\d)/       // 15 (standalone)
            ];
            
            for (const pattern of timePatterns) {
                const match = remaining.match(pattern);
                if (match) {
                    const hours = parseInt(match[1]);
                    const minutes = match[2] ? parseInt(match[2]) : 0;
                    if (hours >= 0 && hours < 24 && minutes >= 0 && minutes < 60) {
                        result.time = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        remaining = remaining.replace(match[0], '').trim();
                        break;
                    }
                }
            }
            
            // Parse duration (90min, 1h, 2h)
            const durationPatterns = [
                /\b(\d+)\s*min\b/i,
                /\b(\d+)\s*h\b/i
            ];
            
            for (const pattern of durationPatterns) {
                const match = remaining.match(pattern);
                if (match) {
                    const value = parseInt(match[1]);
                    result.durationMin = pattern.source.includes('h') ? value * 60 : value;
                    remaining = remaining.replace(match[0], '').trim();
                    break;
                }
            }
            
            // Rest is title
            result.title = remaining || 'Neuer Termin';
            
            return result;
        };
        
        const getNextWeekday = (from, targetDay) => {
            const result = new Date(from);
            const currentDay = result.getDay();
            let daysToAdd = targetDay - currentDay;
            if (daysToAdd <= 0) daysToAdd += 7;
            result.setDate(result.getDate() + daysToAdd);
            return result;
        };
        
        // Check for event conflicts
        const checkEventConflicts = (events, newEvent, targetDate, excludeEventId = null) => {
            const conflicts = [];
            const newStart = new Date(targetDate);
            const [h, m] = (newEvent.time || '12:00').split(':');
            newStart.setHours(parseInt(h), parseInt(m), 0, 0);
            const newEnd = new Date(newStart.getTime() + (newEvent.durationMin || 60) * 60000);
            
            const dayEvents = events.filter(e => {
                if (e.id === excludeEventId) return false;
                const evDate = e.date instanceof Date ? e.date : (e.date?.toDate ? e.date.toDate() : new Date(e.date));
                return evDate.toDateString() === targetDate.toDateString();
            });
            
            for (const ev of dayEvents) {
                const evStart = ev.date instanceof Date ? new Date(ev.date) : new Date(ev.date.toDate());
                const evEnd = new Date(evStart.getTime() + (ev.durationMin || 60) * 60000);
                
                // Check overlap
                if (newStart < evEnd && newEnd > evStart) {
                    conflicts.push(ev);
                }
            }
            
            return conflicts;
        };
        
        // Find next free slot
        const findNextFreeSlot = (events, targetDate, durationMin = 60, startHour = 8, endHour = 18) => {
            const slots = [];
            const dayEvents = events.filter(e => {
                const evDate = e.date instanceof Date ? e.date : (e.date?.toDate ? e.date.toDate() : new Date(e.date));
                return evDate.toDateString() === targetDate.toDateString();
            }).sort((a, b) => {
                const aDate = a.date instanceof Date ? a.date : a.date.toDate();
                const bDate = b.date instanceof Date ? b.date : b.date.toDate();
                return aDate - bDate;
            });
            
            let currentTime = new Date(targetDate);
            currentTime.setHours(startHour, 0, 0, 0);
            const endTime = new Date(targetDate);
            endTime.setHours(endHour, 0, 0, 0);
            
            for (const ev of dayEvents) {
                const evStart = ev.date instanceof Date ? new Date(ev.date) : new Date(ev.date.toDate());
                const evEnd = new Date(evStart.getTime() + (ev.durationMin || 60) * 60000);
                
                if (currentTime < evStart && (evStart - currentTime) >= durationMin * 60000) {
                    return currentTime;
                }
                currentTime = new Date(Math.max(currentTime, evEnd));
            }
            
            if (currentTime < endTime && (endTime - currentTime) >= durationMin * 60000) {
                return currentTime;
            }
            
            return null;
        };
        
        // Smart suggestions for free slots
        const suggestFreeSlots = (events, targetDate, historicalEvents = []) => {
            const slots = [];
            const durationMin = 60;
            
            // Get historical patterns (most common hours)
            const hourCounts = {};
            historicalEvents.forEach(ev => {
                const evDate = ev.date instanceof Date ? ev.date : (ev.date?.toDate ? ev.date.toDate() : new Date(ev.date));
                const hour = evDate.getHours();
                hourCounts[hour] = (hourCounts[hour] || 0) + 1;
            });
            
            const popularHours = Object.entries(hourCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5)
                .map(([hour]) => parseInt(hour));
            
            // Find free slots
            for (let hour = 8; hour < 18; hour++) {
                const testDate = new Date(targetDate);
                testDate.setHours(hour, 0, 0, 0);
                const testEnd = new Date(testDate.getTime() + durationMin * 60000);
                
                const hasConflict = events.some(ev => {
                    const evDate = ev.date instanceof Date ? ev.date : (ev.date?.toDate ? ev.date.toDate() : new Date(ev.date));
                    if (evDate.toDateString() !== targetDate.toDateString()) return false;
                    const evStart = new Date(evDate);
                    const evEnd = new Date(evStart.getTime() + (ev.durationMin || 60) * 60000);
                    return testDate < evEnd && testEnd > evStart;
                });
                
                if (!hasConflict) {
                    const priority = popularHours.includes(hour) ? 1 : 0;
                    slots.push({ time: `${hour.toString().padStart(2, '0')}:00`, priority });
                }
            }
            
            // Sort by priority (popular hours first) and return top 3
            return slots.sort((a, b) => b.priority - a.priority).slice(0, 3);
        };
        
        // Simple emoji picker data
        const EMOJI_CATEGORIES = {
            'HÃ¤ufig': ['ðŸ“…', 'â°', 'âœ…', 'ðŸŽ¯', 'ðŸ’¼', 'ðŸ“', 'ðŸƒ', 'ðŸ•'],
            'Arbeit': ['ðŸ’¼', 'ðŸ“Š', 'ðŸ’»', 'ðŸ“ž', 'âœ‰ï¸', 'ðŸ“', 'ðŸ–Šï¸', 'ðŸ“ˆ'],
            'Freizeit': ['ðŸŽ®', 'ðŸŽ¬', 'ðŸŽµ', 'ðŸ“š', 'ðŸŽ¨', 'ðŸ‹ï¸', 'âš½', 'ðŸŽ¯'],
            'Essen': ['ðŸ•', 'ðŸ”', 'ðŸœ', 'â˜•', 'ðŸ°', 'ðŸ¥—', 'ðŸ±', 'ðŸ·'],
            'Reisen': ['âœˆï¸', 'ðŸš—', 'ðŸ–ï¸', 'ðŸ—ºï¸', 'ðŸ¨', 'ðŸŽ’', 'ðŸ“¸', 'ðŸŒ'],
            'Gesundheit': ['ðŸ’Š', 'ðŸ¥', 'ðŸ§˜', 'ðŸ’ª', 'ðŸƒ', 'ðŸš´', 'ðŸ¥—', 'ðŸ’†']
        };
        
        // Default calendar templates
        const DEFAULT_TEMPLATES = [
            {
                id: 'workout-week',
                name: 'Workout-Woche',
                events: [
                    { dayOffset: 0, time: '07:00', durationMin: 60, title: 'Morgen-Workout', category: 'Gesundheit', subCategory: 'Sport', emoji: 'ðŸ‹ï¸' },
                    { dayOffset: 2, time: '07:00', durationMin: 60, title: 'Cardio', category: 'Gesundheit', subCategory: 'Sport', emoji: 'ðŸƒ' },
                    { dayOffset: 4, time: '07:00', durationMin: 60, title: 'Yoga', category: 'Gesundheit', subCategory: 'Sport', emoji: 'ðŸ§˜' },
                    { dayOffset: 6, time: '09:00', durationMin: 90, title: 'Langer Lauf', category: 'Gesundheit', subCategory: 'Sport', emoji: 'ðŸƒ' }
                ]
            },
            {
                id: 'project-sprint',
                name: 'Projekt-Sprint',
                events: [
                    { dayOffset: 0, time: '09:00', durationMin: 30, title: 'Sprint Planning', category: 'Arbeit', subCategory: 'Meeting', emoji: 'ðŸ“Š' },
                    { dayOffset: 1, time: '14:00', durationMin: 90, title: 'Deep Work', category: 'Arbeit', subCategory: 'Home Office', emoji: 'ðŸ’»', isFocus: true },
                    { dayOffset: 2, time: '14:00', durationMin: 90, title: 'Deep Work', category: 'Arbeit', subCategory: 'Home Office', emoji: 'ðŸ’»', isFocus: true },
                    { dayOffset: 3, time: '14:00', durationMin: 90, title: 'Deep Work', category: 'Arbeit', subCategory: 'Home Office', emoji: 'ðŸ’»', isFocus: true },
                    { dayOffset: 4, time: '10:00', durationMin: 60, title: 'Sprint Review', category: 'Arbeit', subCategory: 'Meeting', emoji: 'âœ…' }
                ]
            }
        ];

        // --- AUTH SCREEN ---
        const AuthScreen = ({ onLoginSuccess, onDemoStart }) => {
            const [isRegister, setIsRegister] = useState(false);
            const [email, setEmail] = useState('');
            const [password, setPassword] = useState('');
            const [username, setUsername] = useState('');
            const [error, setError] = useState('');
            const [loading, setLoading] = useState(false);

            const handleAuth = async (e) => {
                e.preventDefault(); setError(''); setLoading(true);
                try {
                    if (isRegister) {
                        if (!/^[a-zA-Z0-9]+$/.test(username) || username.length < 3) throw new Error("Benutzername ungÃ¼ltig.");
                        const snapshot = await db.collection('users').where('username', '==', username).get();
                        if (!snapshot.empty) throw new Error("Name vergeben.");
                        const cred = await auth.createUserWithEmailAndPassword(email, password);
                        await cred.user.updateProfile({ displayName: username });
                        await db.collection('users').doc(cred.user.uid).set({
                            username,
                            displayName: username,
                            email,
                            uid: cred.user.uid,
                            secretId: generateSecretId(),
                            avatarColor: '#1D1D1F',
                            categories: DEFAULT_CATEGORIES,
                            createdAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    } else { await auth.signInWithEmailAndPassword(email, password); }
                    onLoginSuccess();
                } catch (err) { setError(err.message.replace('Firebase:', '').trim()); } finally { setLoading(false); }
            };

            return (
                <div className="min-h-screen flex items-center justify-center p-6 bg-[#f8f9fb] dark:bg-[#000000]">
                    <div className="w-full max-w-sm fade-in">
                        <div className="mb-10 text-center">
                            <h1 className="text-4xl font-bold tracking-tighter mb-2 text-[#1e293b] dark:text-[#e8ecf5]">Kalender</h1>
                            <p className="text-[#64748b] dark:text-[#9ca3af] text-sm uppercase tracking-widest">V Beta</p>
                        </div>
                        <form onSubmit={handleAuth} className="space-y-4">
                            {error && <div className="bg-red-50 dark:bg-red-900/20 text-red-600 dark:text-red-400 text-xs p-3 rounded-xl text-center">{error}</div>}
                            {isRegister && <input className="w-full bg-[#f1f5f9] dark:bg-[#0f0f0f] text-[#1e293b] dark:text-[#e8ecf5] p-4 rounded-2xl outline-none border border-[#e2e8f0] dark:border-[#1f1f1f] focus:border-[#2563eb] dark:focus:border-[#4da3ff] transition-colors" placeholder="Benutzername" value={username} onChange={e => setUsername(e.target.value)} />}
                            <input type="email" className="w-full bg-[#f1f5f9] dark:bg-[#0f0f0f] text-[#1e293b] dark:text-[#e8ecf5] p-4 rounded-2xl outline-none border border-[#e2e8f0] dark:border-[#1f1f1f] focus:border-[#2563eb] dark:focus:border-[#4da3ff] transition-colors" placeholder="Email" value={email} onChange={e => setEmail(e.target.value)} />
                            <input type="password" className="w-full bg-[#f1f5f9] dark:bg-[#0f0f0f] text-[#1e293b] dark:text-[#e8ecf5] p-4 rounded-2xl outline-none border border-[#e2e8f0] dark:border-[#1f1f1f] focus:border-[#2563eb] dark:focus:border-[#4da3ff] transition-colors" placeholder="Passwort" value={password} onChange={e => setPassword(e.target.value)} />
                            <button disabled={loading} className="w-full bg-[#2563eb] hover:bg-[#1d4ed8] dark:bg-[#4da3ff] dark:hover:bg-[#3b8fe7] text-white dark:text-[#000000] py-4 rounded-2xl font-bold transition-colors disabled:opacity-50">{loading ? '...' : (isRegister ? 'Registrieren' : 'Einloggen')}</button>
                        </form>
                        <div className="mt-6 text-center space-y-4">
                            <button onClick={() => setIsRegister(!isRegister)} className="text-sm font-medium text-[#64748b] dark:text-[#9ca3af] hover:text-[#2563eb] dark:hover:text-[#4da3ff] transition-colors">{isRegister ? 'Login' : 'Registrieren'}</button>
                            <div className="border-t border-[#e2e8f0] dark:border-[#1f1f1f] pt-4"><button onClick={onDemoStart} className="text-xs font-bold text-[#64748b] dark:text-[#9ca3af] hover:text-[#2563eb] dark:hover:text-[#4da3ff] transition-colors">Demo starten</button></div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- ARCHIV (E2EE via WebCrypto + Firestore) ---
        const VaultPanel = ({ user, db, userData, onClose, notificationsEnabled, setNotificationsEnabled, showToast }) => {
            const [ready, setReady] = useState(false);
            const [mySecretId, setMySecretId] = useState(userData?.secretId || '');
            const [convs, setConvs] = useState([]);
            const [profiles, setProfiles] = useState({});
            const profilesRef = useRef({});
            useEffect(() => { profilesRef.current = profiles; }, [profiles]);
            const [view, setView] = useState('list'); // 'list' | 'detail'
            const [activeConvId, setActiveConvId] = useState(null);
            const [messages, setMessages] = useState([]);
            const [idInput, setIdInput] = useState('');
            const [draft, setDraft] = useState('');
            const [busy, setBusy] = useState(false);
            const libraryInputRef = useRef(null);
            const cameraInputRef = useRef(null);

            const [recOn, setRecOn] = useState(false);
            const recRef = useRef({ recorder: null, stream: null, chunks: [], startedAt: 0, mime: '', discard: false });
            const [playBusyId, setPlayBusyId] = useState(null);
            const [hiddenIds, setHiddenIds] = useState({});
            const hiddenIdsRef = useRef({});
            useEffect(() => { hiddenIdsRef.current = hiddenIds; }, [hiddenIds]);

            const [mediaOverlay, setMediaOverlay] = useState(null);
            const overlayObjectUrlRef = useRef(null);


            const listLoadedRef = useRef(false);
            const lastNotifiedRef = useRef({});
            const keyCacheRef = useRef({});
            const myPrivKeyRef = useRef(null);
            const scrollRef = useRef(null);

            const convCollection = db.collection('secretConversations');

            const shortUid = (uid) => (uid || '').slice(0, 6) + 'â€¦' + (uid || '').slice(-4);

            const makeConvId = (uids) => {
                const sorted = [...uids].sort();
                return 'sc_' + sorted.join('_');
            };

            const getOtherUid = (conv) => (conv.memberIds || []).find(x => x !== user.uid);
            const isImageMessage = (m) => {
                if (!m) return false;
                return m.kind === 'img'
                    || (!!m.thumbCiphertext && !!m.thumbIv)
                    || (!!m.storagePath && !!m.thumbCiphertext);
            };

            const ensureSecretSetup = async () => {
                if (!canUseSecretCrypto()) {
                    showToast('Archiv: benÃ¶tigt HTTPS/localhost (WebCrypto).');
                    return false;
                }

                // Secret-ID sicherstellen (Backfill)
                try {
                    const meRef = db.collection('users').doc(user.uid);
                    const snap = await meRef.get();
                    if (snap.exists) {
                        const data = snap.data() || {};
                        if (data.secretId) setMySecretId(data.secretId);
                        else {
                            const sid = generateSecretId();
                            await meRef.update({ secretId: sid });
                            setMySecretId(sid);
                        }
                    }
                } catch (e) {}

                // ECDH Keypair lokal + PublicKey in Firestore
                try {
                    const privKeyStorage = `pw_sc_priv_${user.uid}`;
                    const pubKeyField = 'secretPubKey';
                    const stored = localStorage.getItem(privKeyStorage);

                    const importPriv = async (jwk) => {
                        return await crypto.subtle.importKey(
                            'jwk',
                            jwk,
                            { name: 'ECDH', namedCurve: 'P-256' },
                            false,
                            ['deriveKey']
                        );
                    };
                    const importPub = async (jwk) => {
                        return await crypto.subtle.importKey(
                            'jwk',
                            jwk,
                            { name: 'ECDH', namedCurve: 'P-256' },
                            true,
                            []
                        );
                    };

                    if (stored) {
                        const jwk = JSON.parse(stored);
                        myPrivKeyRef.current = await importPriv(jwk);
                    } else {
                        const kp = await crypto.subtle.generateKey(
                            { name: 'ECDH', namedCurve: 'P-256' },
                            true,
                            ['deriveKey']
                        );
                        const privJwk = await crypto.subtle.exportKey('jwk', kp.privateKey);
                        const pubJwk = await crypto.subtle.exportKey('jwk', kp.publicKey);
                        localStorage.setItem(privKeyStorage, JSON.stringify(privJwk));
                        myPrivKeyRef.current = kp.privateKey;

                        // Public Key publishen
                        await db.collection('users').doc(user.uid).update({ [pubKeyField]: pubJwk }).catch(()=>{});
                    }

                    // Falls User-Dokument PublicKey noch nicht hat: publizieren
                    const meSnap = await db.collection('users').doc(user.uid).get();
                    if (meSnap.exists) {
                        const data = meSnap.data() || {};
                        if (!data[pubKeyField]) {
                            // Re-export public key aus priv ist nicht mÃ¶glich -> regenerate pair ist Overkill.
                            // LÃ¶sung: wenn Public fehlt, generiere neues Paar.
                            const kp = await crypto.subtle.generateKey(
                                { name: 'ECDH', namedCurve: 'P-256' },
                                true,
                                ['deriveKey']
                            );
                            const privJwk = await crypto.subtle.exportKey('jwk', kp.privateKey);
                            const pubJwk = await crypto.subtle.exportKey('jwk', kp.publicKey);
                            localStorage.setItem(privKeyStorage, JSON.stringify(privJwk));
                            myPrivKeyRef.current = kp.privateKey;
                            await db.collection('users').doc(user.uid).update({ [pubKeyField]: pubJwk }).catch(()=>{});
                        }
                    }

                    setReady(true);
                    return true;
                } catch (e) {
                    showToast('Archiv: Crypto-Setup fehlgeschlagen.');
                    return false;
                }
            };

            const getSharedKey = async (otherUid) => {
                if (keyCacheRef.current[otherUid]) return keyCacheRef.current[otherUid];
                const otherSnap = await db.collection('users').doc(otherUid).get();
                if (!otherSnap.exists) throw new Error('User nicht gefunden');
                const other = otherSnap.data() || {};
                if (!other.secretPubKey) throw new Error('Gegenseite hat Archiv noch nie geÃ¶ffnet.');

                const otherPub = await crypto.subtle.importKey(
                    'jwk',
                    other.secretPubKey,
                    { name: 'ECDH', namedCurve: 'P-256' },
                    true,
                    []
                );

                if (!myPrivKeyRef.current) throw new Error('Private Key fehlt');
                const aesKey = await crypto.subtle.deriveKey(
                    { name: 'ECDH', public: otherPub },
                    myPrivKeyRef.current,
                    { name: 'AES-GCM', length: 256 },
                    false,
                    ['encrypt', 'decrypt']
                );

                keyCacheRef.current[otherUid] = aesKey;
                return aesKey;
            };

            const encryptFor = async (otherUid, plaintext) => {
                const key = await getSharedKey(otherUid);
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const enc = new TextEncoder().encode(plaintext);
                const ct = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, enc);
                return { ciphertext: bytesToBase64(new Uint8Array(ct)), iv: bytesToBase64(iv) };
            };

            const decryptFrom = async (otherUid, ciphertextB64, ivB64) => {
                const key = await getSharedKey(otherUid);
                const iv = base64ToBytes(ivB64);
                const ct = base64ToBytes(ciphertextB64);
                const pt = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, ct);
                return new TextDecoder().decode(pt);
            };


            const encryptBytesFor = async (otherUid, plainBytes) => {
                const key = await getSharedKey(otherUid);
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const ct = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, plainBytes);
                return { cipherBytes: new Uint8Array(ct), ivB64: bytesToBase64(iv) };
            };

            const decryptBytesFrom = async (otherUid, ciphertextB64, ivB64) => {
                const key = await getSharedKey(otherUid);
                const iv = base64ToBytes(ivB64);
                const ct = base64ToBytes(ciphertextB64);
                const pt = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, ct);
                return new Uint8Array(pt);
            };

            const makeThumbBlob = (file) => {
                return new Promise((resolve, reject) => {
                    try {
                        const url = URL.createObjectURL(file);
                        const img = new Image();
                        img.onload = () => {
                            try {
                                const max = 360;
                                const w = img.naturalWidth || img.width || 1;
                                const h = img.naturalHeight || img.height || 1;
                                const scale = Math.min(1, max / Math.max(w, h));
                                const tw = Math.max(1, Math.round(w * scale));
                                const th = Math.max(1, Math.round(h * scale));
                                const canvas = document.createElement('canvas');
                                canvas.width = tw;
                                canvas.height = th;
                                const ctx = canvas.getContext('2d');
                                ctx.drawImage(img, 0, 0, tw, th);
                                canvas.toBlob((blob) => {
                                    URL.revokeObjectURL(url);
                                    if (blob) resolve(blob);
                                    else reject(new Error('thumb'));
                                }, 'image/jpeg', 0.72);
                            } catch (e) {
                                URL.revokeObjectURL(url);
                                reject(e);
                            }
                        };
                        img.onerror = () => { URL.revokeObjectURL(url); reject(new Error('img')); };
                        img.src = url;
                    } catch (e) { reject(e); }
                });
            };


            const compressImageToJpeg = (fileOrBlob, maxDim = 2048, quality = 0.84) => {
                return new Promise((resolve, reject) => {
                    try {
                        const src = fileOrBlob;
                        const url = URL.createObjectURL(src);
                        const cleanup = () => { try { URL.revokeObjectURL(url); } catch(e){} };

                        const renderToCanvas = (imgLike, w0, h0) => {
                            const scale = Math.min(1, maxDim / Math.max(w0 || 1, h0 || 1));
                            const w = Math.max(1, Math.round((w0 || 1) * scale));
                            const h = Math.max(1, Math.round((h0 || 1) * scale));
                            const canvas = document.createElement('canvas');
                            canvas.width = w;
                            canvas.height = h;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(imgLike, 0, 0, w, h);
                            return { canvas, w, h };
                        };

                        const finish = (canvas, w, h) => {
                            canvas.toBlob((blob) => {
                                cleanup();
                                if (!blob) return reject(new Error('jpeg'));
                                resolve({ blob, width: w, height: h });
                            }, 'image/jpeg', quality);
                        };

                        // Prefer createImageBitmap where available (can respect EXIF orientation in some browsers)
                        if (window.createImageBitmap) {
                            const opts = {};
                            try { opts.imageOrientation = 'from-image'; } catch (e) {}
                            createImageBitmap(src, opts).then((bmp) => {
                                try {
                                    const w0 = bmp.width || 1;
                                    const h0 = bmp.height || 1;
                                    const { canvas, w, h } = renderToCanvas(bmp, w0, h0);
                                    try { bmp.close && bmp.close(); } catch(e){}
                                    finish(canvas, w, h);
                                } catch (e) {
                                    cleanup();
                                    reject(e);
                                }
                            }).catch(() => {
                                const img = new Image();
                                img.onload = () => {
                                    try {
                                        const w0 = img.naturalWidth || img.width || 1;
                                        const h0 = img.naturalHeight || img.height || 1;
                                        const { canvas, w, h } = renderToCanvas(img, w0, h0);
                                        finish(canvas, w, h);
                                    } catch (e) { cleanup(); reject(e); }
                                };
                                img.onerror = () => { cleanup(); reject(new Error('img')); };
                                img.src = url;
                            });
                            return;
                        }

                        const img = new Image();
                        img.onload = () => {
                            try {
                                const w0 = img.naturalWidth || img.width || 1;
                                const h0 = img.naturalHeight || img.height || 1;
                                const { canvas, w, h } = renderToCanvas(img, w0, h0);
                                finish(canvas, w, h);
                            } catch (e) { cleanup(); reject(e); }
                        };
                        img.onerror = () => { cleanup(); reject(new Error('img')); };
                        img.src = url;
                    } catch (e) { reject(e); }
                });
            };

            const closeMedia = () => {
                if (overlayObjectUrlRef.current) {
                    URL.revokeObjectURL(overlayObjectUrlRef.current);
                    overlayObjectUrlRef.current = null;
                }
                setMediaOverlay(null);
            };

            const openMedia = async (msg) => {
                if (!ready || !msg?.ivFull) return;
                if (!msg.fullCiphertext && !msg.storagePath) return;
                const conv = convs.find(c => c.id === activeConvId);
                if (!conv) return;
                const otherUid = getOtherUid(conv);
                if (!otherUid) return;

                setMediaOverlay({ id: msg.id, mine: msg.senderId === user.uid, url: null, loading: true, msg, openedAt: Date.now() });

                try {
                    let bytes = null;
                    if (msg.fullCiphertext) {
                        bytes = await decryptBytesFrom(otherUid, msg.fullCiphertext, msg.ivFull);
                    } else if (msg.storagePath) {
                        const url = await storage.ref(msg.storagePath).getDownloadURL();
                        const resp = await fetch(url);
                        const encBuf = await resp.arrayBuffer();
                        const key = await getSharedKey(otherUid);
                        const iv = base64ToBytes(msg.ivFull);
                        const pt = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, encBuf);
                        bytes = new Uint8Array(pt);
                    } else {
                        throw new Error('Media content not available');
                    }

                    const blob = new Blob([bytes], { type: msg.mime || 'image/jpeg' });
                    const objectUrl = URL.createObjectURL(blob);

                    if (overlayObjectUrlRef.current) URL.revokeObjectURL(overlayObjectUrlRef.current);
                    overlayObjectUrlRef.current = objectUrl;

                    setMediaOverlay({ id: msg.id, mine: msg.senderId === user.uid, url: objectUrl, loading: false, msg });
                } catch (e) {
                    showToast('Ã–ffnen fehlgeschlagen');
                    closeMedia();
                }
            };

            // Hinweis: Absichtliche Freigabe â€“ jeder GesprÃ¤chsteilnehmer darf per Doppeltap lÃ¶schen
            const deleteMedia = async (msg) => {
                if (!msg) return closeMedia();
                try {
                    await convCollection.doc(activeConvId).collection('messages').doc(msg.id).delete();
                    showToast('GelÃ¶scht');
                } catch (e) {
                    showToast('LÃ¶schen fehlgeschlagen');
                } finally {
                    closeMedia();
                }
            };

            const requestNotifications = async () => {
                if (!('Notification' in window)) {
                    showToast('Browser unterstÃ¼tzt keine Benachrichtigungen.');
                    return;
                }
                const perm = await Notification.requestPermission();
                if (perm === 'granted') {
                    setNotificationsEnabled(true);
                    showToast('Benachrichtigungen aktiviert.');
                } else {
                    setNotificationsEnabled(false);
                    showToast('Benachrichtigungen nicht freigegeben.');
                }
            };

            const notify = (title, body) => {
                try {
                    if (!notificationsEnabled) return;
                    if (!('Notification' in window)) return;
                    if (Notification.permission !== 'granted') return;
                    new Notification(title, { body });
                } catch (e) {}
            };

            const ensureProfile = async (uid) => {
                if (!uid) return;
                if (profiles[uid]) return;
                try {
                    const snap = await db.collection('users').doc(uid).get();
                    if (snap.exists) {
                        const d = snap.data() || {};
                        setProfiles(prev => ({ ...prev, [uid]: { username: d.username || d.displayName || shortUid(uid), secretId: d.secretId || '' } }));
                    } else {
                        setProfiles(prev => ({ ...prev, [uid]: { username: shortUid(uid), secretId: '' } }));
                    }
                } catch (e) {
                    setProfiles(prev => ({ ...prev, [uid]: { username: shortUid(uid), secretId: '' } }));
                }
            };

            const connectById = async () => {
                const raw = (idInput || '').trim();
                if (!raw) return;
                if (!ready) return;

                setBusy(true);
                try {
                    const input = raw.toUpperCase();

                    // 1) via Secret-ID
                    let targetUid = null;
                    const q = await db.collection('users').where('secretId', '==', input).limit(1).get();
                    if (!q.empty) targetUid = q.docs[0].id;

                    // 2) fallback: UID direkt
                    if (!targetUid) {
                        const u = await db.collection('users').doc(raw).get();
                        if (u.exists) targetUid = u.id;
                    }

                    if (!targetUid) {
                        showToast('Kein User mit dieser ID gefunden.');
                        return;
                    }
                    if (targetUid === user.uid) {
                        showToast('Eigene ID ist nicht sinnvoll.');
                        return;
                    }

                    const convId = makeConvId([user.uid, targetUid]);
                    const ref = convCollection.doc(convId);
                    const exists = await ref.get();
                    if (!exists.exists) {
                        await ref.set({
                            memberIds: [user.uid, targetUid],
                            createdBy: user.uid,
                            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                            type: 'dm',
                            lastMessageAt: firebase.firestore.FieldValue.serverTimestamp(),
                            lastSenderId: user.uid
                        });
                    }

                    await ensureProfile(targetUid);
                    setIdInput('');
                    setActiveConvId(convId);
                    setView('detail');
                } catch (e) {
                    showToast(e.message || 'Fehler');
                } finally {
                    setBusy(false);
                }
            };

            const sendMessage = async () => {
                if (!draft.trim() || !activeConvId) return;
                const conv = convs.find(c => c.id === activeConvId);
                if (!conv) return;

                const otherUid = getOtherUid(conv);
                if (!otherUid) return;

                setBusy(true);
                try {
                    const { ciphertext, iv } = await encryptFor(otherUid, draft.trim());
                    const msgRef = convCollection.doc(activeConvId).collection('messages').doc();
                    await msgRef.set({
                        senderId: user.uid,
                        ciphertext,
                        iv,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    await convCollection.doc(activeConvId).update({
                        lastMessageAt: firebase.firestore.FieldValue.serverTimestamp(),
                        lastSenderId: user.uid
                    });

                    setDraft('');
                    setTimeout(() => {
                        if (scrollRef.current) scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
                    }, 50);
                } catch (e) {
                    showToast(e.message || 'Senden fehlgeschlagen');
                } finally {
                    setBusy(false);
                }
            };


            const sendMedia = async (file) => {
                if (!file || !activeConvId) return;
                if (!ready) return;

                const conv = convs.find(c => c.id === activeConvId);
                if (!conv) return;
                const otherUid = getOtherUid(conv);
                if (!otherUid) return;

                const looksLikeImage = isImageFile(file);
                if (!looksLikeImage) {
                    showToast('Nur Bilder');
                    return;
                }

                setBusy(true);
                try {
                    // WhatsApp-Ã¤hnlich: JPEG + max. 2048px Kante (HD)
                    const { blob: jpegBlob } = await compressImageToJpeg(file, 2048, 0.84);
                    const thumbBlob = await makeThumbBlob(jpegBlob);

                    const msgRef = convCollection.doc(activeConvId).collection('messages').doc();
                    const msgId = msgRef.id;

                    const thumbBytes = new Uint8Array(await thumbBlob.arrayBuffer());
                    const fullBytes = new Uint8Array(await jpegBlob.arrayBuffer());

                    const thumbEnc = await encryptBytesFor(otherUid, thumbBytes);
                    const fullEnc = await encryptBytesFor(otherUid, fullBytes);
                    const fullCiphertext = bytesToBase64(fullEnc.cipherBytes);
                    if (fullCiphertext.length > MEDIA_B64_LIMIT) { // Firestore 1MB limit safeguard
                        showToast('Bild zu groÃŸ');
                        return;
                    }

                    await msgRef.set({
                        senderId: user.uid,
                        kind: 'img',
                        fullCiphertext,
                        ivFull: fullEnc.ivB64,
                        mime: 'image/jpeg',
                        thumbCiphertext: bytesToBase64(thumbEnc.cipherBytes),
                        thumbIv: thumbEnc.ivB64,
                        thumbMime: 'image/jpeg',
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });

                    await convCollection.doc(activeConvId).update({
                        lastMessageAt: firebase.firestore.FieldValue.serverTimestamp(),
                        lastSenderId: user.uid
                    });

                    setTimeout(() => {
                        if (scrollRef.current) scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
                    }, 60);
                } catch (e) {
                    showToast('Upload fehlgeschlagen');
                } finally {
                    setBusy(false);
                }
            };



            const pickAudioMime = () => {
                try {
                    const types = ['audio/webm;codecs=opus','audio/webm','audio/ogg;codecs=opus','audio/ogg','audio/mp4'];
                    if (!window.MediaRecorder) return '';
                    for (const t of types) {
                        if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(t)) return t;
                    }
                    return '';
                } catch (e) { return ''; }
            };

            // Cordova: Kamera/Galerie via cordova-plugin-camera (fallback auf <input>)
            const cordovaGetJpegFile = async (sourceType) => {
                if (!window.cordova || !navigator.camera || !window.Camera) return null;

                // Runtime-Permissions (Android) - best effort
                try {
                    const perms = window.cordova?.plugins?.permissions;
                    if (perms) {
                        const req = (p) => new Promise((resolve) => {
                            if (!p) return resolve(false);
                            try { perms.requestPermission(p, () => resolve(true), () => resolve(false)); } catch (e) { resolve(false); }
                        });

                        if (perms.CAMERA && sourceType === Camera.PictureSourceType.CAMERA) await req(perms.CAMERA);
                        if (perms.READ_MEDIA_IMAGES && sourceType === Camera.PictureSourceType.PHOTOLIBRARY) await req(perms.READ_MEDIA_IMAGES);
                        else if (perms.READ_EXTERNAL_STORAGE && sourceType === Camera.PictureSourceType.PHOTOLIBRARY) await req(perms.READ_EXTERNAL_STORAGE);
                    }
                } catch (e) {}

                return await new Promise((resolve) => {
                    try {
                        navigator.camera.getPicture(
                            (data) => {
                                try {
                                    const byteStr = atob(data);
                                    const bytes = new Uint8Array(byteStr.length);
                                    for (let i = 0; i < byteStr.length; i++) bytes[i] = byteStr.charCodeAt(i);
                                    const blob = new Blob([bytes], { type: 'image/jpeg' });
                                    resolve(new File([blob], `img_${Date.now()}.jpg`, { type: 'image/jpeg' }));
                                } catch (e) { resolve(null); }
                            },
                            () => resolve(null),
                            {
                                destinationType: Camera.DestinationType.DATA_URL,
                                sourceType,
                                encodingType: Camera.EncodingType.JPEG,
                                quality: 84,
                                targetWidth: 2048,
                                targetHeight: 2048,
                                correctOrientation: true,
                                saveToPhotoAlbum: false
                            }
                        );
                    } catch (e) { resolve(null); }
                });
            };

            const openGallery = async () => {
                if (window.cordova && navigator.camera && window.Camera) {
                    const f = await cordovaGetJpegFile(Camera.PictureSourceType.PHOTOLIBRARY);
                    if (f) return await sendMedia(f);
                }
                try { libraryInputRef.current?.click(); } catch (e) {}
            };

            const openCamera = async () => {
                if (window.cordova && navigator.camera && window.Camera) {
                    const f = await cordovaGetJpegFile(Camera.PictureSourceType.CAMERA);
                    if (f) return await sendMedia(f);
                }
                try { cameraInputRef.current?.click(); } catch (e) {}
            };



            const sendAudio = async (blob, durationMs) => {
                if (!blob || !activeConvId) return;
                if (!ready) return;

                const conv = convs.find(c => c.id === activeConvId);
                if (!conv) return;
                const otherUid = getOtherUid(conv);
                if (!otherUid) return;

                setBusy(true);
                try {
                    console.log('Sending audio, blob size:', blob.size, 'type:', blob.type, 'duration:', durationMs);
                    const msgRef = convCollection.doc(activeConvId).collection('messages').doc();
                    const msgId = msgRef.id;

                    const bytes = new Uint8Array(await blob.arrayBuffer());
                    console.log('Audio bytes length:', bytes.length);
                    const fullEnc = await encryptBytesFor(otherUid, bytes);
                    const fullCiphertext = bytesToBase64(fullEnc.cipherBytes);
                    if (fullCiphertext.length > MEDIA_B64_LIMIT) {
                        showToast('Audio zu groÃŸ');
                        return;
                    }

                    await msgRef.set({
                        senderId: user.uid,
                        kind: 'aud',
                        fullCiphertext,
                        ivFull: fullEnc.ivB64,
                        mime: blob.type || 'audio/webm',
                        durationMs: Math.round(durationMs || 0),
                        playedBy: [],
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    console.log('Audio message saved successfully');

                    await convCollection.doc(activeConvId).update({
                        lastMessageAt: firebase.firestore.FieldValue.serverTimestamp(),
                        lastSenderId: user.uid
                    });

                    setTimeout(() => {
                        if (scrollRef.current) scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
                    }, 60);
                } catch (e) {
                    console.error('Audio upload error:', e);
                    showToast('Upload fehlgeschlagen: ' + (e.message || ''));
                } finally {
                    setBusy(false);
                }
            };

            const encodeWavFromFloats = (floatChunks, sampleRate) => {
                try {
                    const chunks = floatChunks || [];
                    const total = chunks.reduce((a, c) => a + (c?.length || 0), 0);
                    const pcm = new Int16Array(total);
                    let o = 0;
                    for (const c of chunks) {
                        if (!c) continue;
                        for (let i = 0; i < c.length; i++) {
                            let s = c[i];
                            s = Math.max(-1, Math.min(1, s));
                            pcm[o++] = s < 0 ? Math.round(s * 0x8000) : Math.round(s * 0x7FFF);
                        }
                    }
                    const buffer = new ArrayBuffer(44 + pcm.length * 2);
                    const view = new DataView(buffer);
                    const writeStr = (off, str) => {
                        for (let i = 0; i < str.length; i++) view.setUint8(off + i, str.charCodeAt(i));
                    };
                    writeStr(0, 'RIFF');
                    view.setUint32(4, 36 + pcm.length * 2, true);
                    writeStr(8, 'WAVE');
                    writeStr(12, 'fmt ');
                    view.setUint32(16, 16, true);
                    view.setUint16(20, 1, true);
                    view.setUint16(22, 1, true);
                    view.setUint32(24, sampleRate || 44100, true);
                    view.setUint32(28, (sampleRate || 44100) * 2, true);
                    view.setUint16(32, 2, true);
                    view.setUint16(34, 16, true);
                    writeStr(36, 'data');
                    view.setUint32(40, pcm.length * 2, true);
                    let pos = 44;
                    for (let i = 0; i < pcm.length; i++) {
                        view.setInt16(pos, pcm[i], true);
                        pos += 2;
                    }
                    return new Blob([buffer], { type: 'audio/wav' });
                } catch (e) {
                    return null;
                }
            };
            // Cordova: Native Audio Record (cordova-plugin-media + cordova-plugin-file)
            const cordovaReadFileToBlob = (filePath, mimeHint) => new Promise((resolve, reject) => {
                try {
                    if (!window.resolveLocalFileSystemURL) return reject(new Error('no-fs'));
                    window.resolveLocalFileSystemURL(filePath, (entry) => {
                        entry.file((file) => {
                            const r = new FileReader();
                            r.onloadend = () => {
                                try {
                                    const mime = mimeHint || file.type || 'audio/3gpp';
                                    resolve(new Blob([r.result], { type: mime }));
                                } catch (e) { reject(e); }
                            };
                            r.onerror = () => reject(new Error('read-failed'));
                            r.readAsArrayBuffer(file);
                        }, reject);
                    }, reject);
                } catch (e) { reject(e); }
            });

            const cordovaDeleteFile = (filePath) => new Promise((resolve) => {
                try {
                    if (!window.resolveLocalFileSystemURL) return resolve(false);
                    window.resolveLocalFileSystemURL(filePath, (entry) => {
                        entry.remove(() => resolve(true), () => resolve(false));
                    }, () => resolve(false));
                } catch (e) { resolve(false); }
            });

            const startRecCordova = async () => {
                try {
                    if (!window.cordova || !window.Media || !window.cordova.file) {
                        showToast('Aufnahme nicht verfÃ¼gbar.');
                        return;
                    }

                    const perms = window.cordova?.plugins?.permissions;
                    if (perms && perms.RECORD_AUDIO) {
                        await new Promise((resolve) => {
                            try {
                                perms.requestPermission(perms.RECORD_AUDIO, () => resolve(true), () => resolve(false));
                            } catch (e) { resolve(false); }
                        });
                    }

                    const dir = window.cordova.file.cacheDirectory || window.cordova.file.dataDirectory;
                    if (!dir) {
                        showToast('Speicherpfad fehlt.');
                        return;
                    }

                    const ext = (window.cordova.platformId === 'android') ? '3gp' : 'm4a';
                    const mime = (ext === 'm4a') ? 'audio/mp4' : 'audio/3gpp';
                    const filePath = `${dir}rec_${Date.now()}.${ext}`;

                    const mediaObj = new Media(filePath, () => {}, () => {});
                    mediaObj.startRecord();

                    recRef.current.mode = 'cordova';
                    recRef.current.mediaObj = mediaObj;
                    recRef.current.filePath = filePath;
                    recRef.current.mime = mime;
                    recRef.current.startedAt = Date.now();
                    setRecOn(true);
                } catch (e) {
                    showToast('Aufnahme fehlgeschlagen');
                }
            };



            const startRec = async () => {
                if (!ready || !activeConvId) return;

                if (window.cordova && window.Media && window.cordova?.file && window.resolveLocalFileSystemURL) {
                    await startRecCordova();
                    return;
                }

                if (!navigator.mediaDevices?.getUserMedia) {
                    showToast('Mikrofon nicht verfÃ¼gbar.');
                    return;
                }

                const proto = (location.protocol || '').toLowerCase();
                const host = (location.hostname || '').toLowerCase();
                const isProbablySecure = !!window.isSecureContext
                    || proto === 'https:'
                    || proto === 'capacitor:'
                    || proto === 'ionic:'
                    || host === 'localhost'
                    || host === '127.0.0.1';

                if (!isProbablySecure) {
                    showToast('Mikrofon benÃ¶tigt HTTPS/localhost (APK: AssetLoader/Capacitor).');
                    return;
                }

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
                    });

                    recRef.current.discard = false;
                    recRef.current.stream = stream;
                    recRef.current.startedAt = Date.now();

                    if (window.MediaRecorder) {
                        const mimeType = pickAudioMime();
                        const rec = new MediaRecorder(stream, mimeType ? { mimeType } : undefined);

                        recRef.current.mode = 'media';
                        recRef.current.recorder = rec;
                        recRef.current.chunks = [];
                        recRef.current.mime = mimeType || rec.mimeType || 'audio/webm';

                        rec.ondataavailable = (e) => {
                            if (e.data && e.data.size > 0) recRef.current.chunks.push(e.data);
                        };
                        rec.onstop = async () => {
                            const discard = !!recRef.current.discard;
                            try { recRef.current.stream?.getTracks?.().forEach(t => t.stop()); } catch (e) {}
                            recRef.current.stream = null;
                            recRef.current.recorder = null;

                            if (discard) return;

                            try {
                                const blob = new Blob(recRef.current.chunks || [], { type: recRef.current.mime || 'audio/webm' });
                                const durMs = Math.max(0, Date.now() - (recRef.current.startedAt || Date.now()));
                                if (blob.size < 1200) return;
                                await sendAudio(blob, durMs);
                            } catch (e) {
                                showToast('Aufnahme fehlgeschlagen');
                            }
                        };

                        rec.start(250);
                        setRecOn(true);
                        return;
                    }

                    // Fallback: WAV (fÃ¼r WebViews ohne MediaRecorder)
                    const AC = window.AudioContext || window.webkitAudioContext;
                    if (!AC) {
                        try { stream.getTracks().forEach(t => t.stop()); } catch (e) {}
                        showToast('Mikrofon nicht verfÃ¼gbar.');
                        return;
                    }

                    const ctx = new AC();
                    const source = ctx.createMediaStreamSource(stream);
                    const proc = ctx.createScriptProcessor(4096, 1, 1);
                    const floats = [];

                    proc.onaudioprocess = (e) => {
                        try {
                            if (recRef.current.discard) return;
                            const ch0 = e.inputBuffer.getChannelData(0);
                            floats.push(new Float32Array(ch0));
                        } catch (err) {}
                    };

                    source.connect(proc);
                    proc.connect(ctx.destination);

                    recRef.current.mode = 'wav';
                    recRef.current.audioCtx = ctx;
                    recRef.current.processor = proc;
                    recRef.current.sourceNode = source;
                    recRef.current.floatChunks = floats;
                    recRef.current.sampleRate = ctx.sampleRate || 44100;

                    setRecOn(true);
                } catch (e) {
                    showToast('Mikrofon blockiert.');
                }
            };

            const stopRec = (send = true) => {
                try { recRef.current.discard = !send; } catch (e) {}

                const mode = recRef.current.mode;

                if (mode === 'cordova') {
                    const discard = !!recRef.current.discard;
                    const mediaObj = recRef.current.mediaObj;
                    const filePath = recRef.current.filePath;
                    const mime = recRef.current.mime || 'audio/3gpp';
                    const startedAt = recRef.current.startedAt || Date.now();

                    try { mediaObj?.stopRecord(); } catch (e) {}

                    (async () => {
                        try {
                            if (discard) {
                                if (filePath) await cordovaDeleteFile(filePath);
                                return;
                            }
                            if (!filePath) return;

                            const blob = await cordovaReadFileToBlob(filePath, mime);
                            const durMs = Math.max(0, Date.now() - startedAt);
                            if (blob && blob.size >= 1200) {
                                await sendAudio(blob, durMs);
                            }
                        } catch (e) {
                            showToast('Aufnahme fehlgeschlagen');
                        } finally {
                            try { if (filePath) await cordovaDeleteFile(filePath); } catch (e) {}
                        }
                    })();

                    setRecOn(false);
                    return;
                }

                if (mode === 'media') {
                    try { recRef.current.recorder?.stop(); } catch (e) {}
                    setRecOn(false);
                    return;
                }

                if (mode === 'wav') {
                    (async () => {
                        const discard = !!recRef.current.discard;
                        const startedAt = recRef.current.startedAt || Date.now();

                        try { recRef.current.processor?.disconnect?.(); } catch (e) {}
                        try { recRef.current.sourceNode?.disconnect?.(); } catch (e) {}
                        try { await recRef.current.audioCtx?.close?.(); } catch (e) {}
                        try { recRef.current.stream?.getTracks?.().forEach(t => t.stop()); } catch (e) {}

                        const floats = recRef.current.floatChunks || [];
                        const sr = recRef.current.sampleRate || 44100;

                        recRef.current.stream = null;
                        recRef.current.audioCtx = null;
                        recRef.current.processor = null;
                        recRef.current.sourceNode = null;
                        recRef.current.floatChunks = null;

                        if (discard) return;

                        try {
                            const blob = encodeWavFromFloats(floats, sr);
                            const durMs = Math.max(0, Date.now() - startedAt);
                            if (!blob || blob.size < 1200) return;
                            await sendAudio(blob, durMs);
                        } catch (e) {
                            showToast('Aufnahme fehlgeschlagen');
                        }
                    })();
                    setRecOn(false);
                    return;
                }

                setRecOn(false);
            };


            const formatDur = (ms) => {
                const s = Math.max(0, Math.round((ms || 0) / 1000));
                const mm = String(Math.floor(s / 60)).padStart(2, '0');
                const ss = String(s % 60).padStart(2, '0');
                return `${mm}:${ss}`;
            };

            const markPlayedAndMaybeDelete = async (msg) => {
                try {
                    setHiddenIds(prev => ({ ...prev, [msg.id]: true }));

                    const msgDoc = convCollection.doc(activeConvId).collection('messages').doc(msg.id);
                    await msgDoc.update({ playedBy: firebase.firestore.FieldValue.arrayUnion(user.uid) }).catch(()=>{});

                    const convSnap = await convCollection.doc(activeConvId).get();
                    const members = (convSnap.data()?.memberIds) || [];

                    const snap2 = await msgDoc.get();
                    const d2 = snap2.data() || {};
                    const playedBy = d2.playedBy || [];

                    if (members.length && members.every(u => playedBy.includes(u))) {
                        // Kein Storage-Cleanup nÃ¶tig: Medien werden inline (Base64) gespeichert
                        await msgDoc.delete().catch(()=>{});
                    }
                } catch (e) {}
            };

            const playAudio = async (msg) => {
                if (!ready || !msg?.ivFull) return;
                if (!msg.fullCiphertext && !msg.storagePath) return;
                if (!activeConvId) return;
                if (playBusyId) return;

                const conv = convs.find(c => c.id === activeConvId);
                if (!conv) return;
                const otherUid = getOtherUid(conv);
                if (!otherUid) return;

                setPlayBusyId(msg.id);
                try {
                    let bytes = null;
                    if (msg.fullCiphertext) {
                        bytes = await decryptBytesFrom(otherUid, msg.fullCiphertext, msg.ivFull);
                    } else if (msg.storagePath) {
                        const url = await storage.ref(msg.storagePath).getDownloadURL();
                        const resp = await fetch(url);
                        const encBuf = await resp.arrayBuffer();
                        const key = await getSharedKey(otherUid);
                        const iv = base64ToBytes(msg.ivFull);
                        const pt = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, encBuf);
                        bytes = new Uint8Array(pt);
                    } else {
                        throw new Error('Media content not available');
                    }
                    
                    if (!bytes || bytes.length === 0) {
                        throw new Error('Empty audio data');
                    }
                    
                    const blob = new Blob([bytes], { type: msg.mime || 'audio/webm' });
                    const objectUrl = URL.createObjectURL(blob);

                    const a = new Audio();
                    a.preload = 'auto';
                    
                    a.onloadeddata = () => {
                        console.log('Audio loaded, duration:', a.duration);
                    };
                    
                    a.onended = () => {
                        try { URL.revokeObjectURL(objectUrl); } catch (e) {}
                        setPlayBusyId(null);
                        markPlayedAndMaybeDelete(msg);
                    };
                    
                    a.onerror = (e) => {
                        console.error('Audio playback error:', e);
                        try { URL.revokeObjectURL(objectUrl); } catch (e) {}
                        setPlayBusyId(null);
                        showToast('Wiedergabe fehlgeschlagen');
                    };

                    a.src = objectUrl;
                    await a.play();
                } catch (e) {
                    console.error('Play audio error:', e);
                    showToast('Wiedergabe fehlgeschlagen: ' + (e.message || ''));
                    setPlayBusyId(null);
                }
            };

            useEffect(() => {
                // Init on open
                ensureSecretSetup();
            }, []);
            useEffect(() => {
                return () => {
                    try {
                        if (recRef.current && recRef.current.recorder) {
                            recRef.current.discard = true;
                            recRef.current.recorder.stop();
                        }
                    } catch (e) {}
                    try {
                        recRef.current?.stream?.getTracks?.().forEach(t => t.stop());
                    } catch (e) {}
                    if (overlayObjectUrlRef.current) {
                        URL.revokeObjectURL(overlayObjectUrlRef.current);
                        overlayObjectUrlRef.current = null;
                    }
                };
            }, []);


            useEffect(() => {
                if (!ready) return;

                // Wichtig: bei (Re-)Subscribe initiale Ã„nderungen NICHT als "neu" bewerten
                listLoadedRef.current = false;

                const unsub = convCollection.where('memberIds', 'array-contains', user.uid).onSnapshot(async (snap) => {
                    const items = snap.docs.map(d => ({ id: d.id, ...d.data() }));
                    items.sort((a,b) => {
                        const ta = a.lastMessageAt?.toMillis?.() || 0;
                        const tb = b.lastMessageAt?.toMillis?.() || 0;
                        return tb - ta;
                    });
                    setConvs(items);

                    // Profiles nachziehen
                    items.forEach(c => ensureProfile(getOtherUid(c)));

                    // Notifications: nur nach initialem Load, nur wenn lastMessage neu und von anderer Person
                    if (listLoadedRef.current) {
                        snap.docChanges().forEach(ch => {
                            if (ch.type !== 'modified' && ch.type !== 'added') return;
                            const d = ch.doc.data() || {};
                            if (d.lastSenderId === user.uid) return;
                            const ts = d.lastMessageAt?.toMillis?.() || 0;
                            const prevTs = lastNotifiedRef.current[ch.doc.id] || 0;
                            if (ts && ts > prevTs) {
                                lastNotifiedRef.current[ch.doc.id] = ts;
                                const otherUid = (d.memberIds || []).find(x => x !== user.uid);
                                const name = profilesRef.current[otherUid]?.username || 'Neuer Eintrag';
                                notify('PlanWise', `Eintrag von ${name}`);
                            }
                        });
                    } else {
                        // Initiale Marker setzen
                        items.forEach(c => {
                            const ts = c.lastMessageAt?.toMillis?.() || 0;
                            lastNotifiedRef.current[c.id] = ts;
                        });
                        listLoadedRef.current = true;
                    }
                });

                return () => unsub();
            }, [ready, notificationsEnabled]);

            useEffect(() => {
                if (!ready || !activeConvId) return;

                const conv = convs.find(c => c.id === activeConvId);
                if (!conv) return;
                const otherUid = getOtherUid(conv);
                if (!otherUid) return;

                const unsub = convCollection.doc(activeConvId).collection('messages').orderBy('createdAt', 'asc').limitToLast(200).onSnapshot(async (snap) => {
                    const docs = snap.docs.map(d => ({ id: d.id, ...d.data() }));
                    const hydrated = await Promise.all(docs.map(async (m) => {
                        // Audio-Eintrag
                        if (m.kind === 'aud') {
                            return { ...m, kind: 'aud' };
                        }

                        // Bild-Eintrag
                        if (isImageMessage(m)) {
                            let thumbDataUrl = null;
                            if (m.thumbCiphertext && m.thumbIv) {
                                try {
                                    const bytes = await decryptBytesFrom(otherUid, m.thumbCiphertext, m.thumbIv);
                                    const mime = m.thumbMime || 'image/jpeg';
                                    thumbDataUrl = `data:${mime};base64,${bytesToBase64(bytes)}`;
                                } catch (e) {}
                            }
                            return { ...m, kind: 'img', thumbDataUrl };
                        }

                        // Text-Eintrag (Fallback)
                        try {
                            const text = await decryptFrom(otherUid, m.ciphertext, m.iv);
                            return { ...m, kind: 'text', text, _ok: true };
                        } catch (e) {
                            return { ...m, kind: 'text', text: '[Nicht lesbar]', _ok: false };
                        }
                    }));
                    setMessages(hydrated);
                    setTimeout(() => {
                        if (scrollRef.current) scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
                    }, 50);

                    // Notify for newly added messages (current view)
                    if (notificationsEnabled && Notification?.permission === 'granted') {
                        snap.docChanges().forEach(ch => {
                            if (ch.type !== 'added') return;
                            const d = ch.doc.data() || {};
                            if (d.senderId === user.uid) return;
                            // initial load -> createdAt kann null sein, daher "nichts"
                            if (d.createdAt && d.createdAt.toMillis) {
                                notify('PlanWise', `Neuer Eintrag von ${profiles[otherUid]?.username || shortUid(otherUid)}`);
                            }
                        });
                    }
                });

                return () => unsub();
            }, [ready, activeConvId, convs.length]);

            const activeConv = convs.find(c => c.id === activeConvId);
            const activeOtherUid = activeConv ? getOtherUid(activeConv) : null;
            const activeName = activeOtherUid ? (profiles[activeOtherUid]?.username || shortUid(activeOtherUid)) : 'â€”';

            return (
                <div className="fixed inset-0 z-[120] bg-[#f8f9fb] dark:bg-[#000000] flex flex-col">
                    {/* Topbar */}
                    <div className="px-6 py-5 border-b border-[#e2e8f0] dark:border-[#1f1f1f] flex items-center justify-between bg-[#f8f9fb] dark:bg-[#000000]">
                        <div className="flex items-center gap-3">
                            {view === 'detail' ? (
                                <button onClick={() => { if (recOn) stopRec(false); setView('list'); setActiveConvId(null); }} className="p-2 -ml-2 rounded-full hover:bg-gray-50 dark:hover:bg-[#1E1E1E]">
                                    <Icon name="chevronLeft" />
                                </button>
                            ) : (
                                <div className="w-10 h-10 rounded-2xl bg-gray-50 dark:bg-[#0f0f0f] flex items-center justify-center">
                                    <Icon name="lock" />
                                </div>
                            )}
                            <div>
                                <div className="font-bold text-lg dark:text-white">{view === 'detail' ? activeName : 'Archiv'}</div>
                                <div className="text-[10px] uppercase tracking-widest text-gray-400">{ready ? 'Aktiv' : 'Startâ€¦'}</div>
                            </div>
                        </div>
                        <div className="flex items-center gap-2">
                            <button
                                onClick={() => { notificationsEnabled ? setNotificationsEnabled(false) : requestNotifications(); }}
                                className={`p-3 rounded-2xl shadow-sm ${notificationsEnabled ? 'bg-black text-white dark:bg-white dark:text-black' : 'bg-gray-100 dark:bg-[#0f0f0f] dark:text-white'}`}
                                title="Benachrichtigungen"
                            >
                                <Icon name="bell" />
                            </button>
                            <button onClick={() => { if (recOn) stopRec(false); onClose(); }} className="p-3 bg-gray-100 dark:bg-[#0f0f0f] dark:text-[#e8ecf5] rounded-2xl shadow-sm">
                                <Icon name="x" />
                            </button>
                        </div>
                    </div>

                    {/* Content */}
                    {view === 'list' ? (
                        <div className="p-6 overflow-y-auto flex-1 bg-[#F8F9FA] dark:bg-[#000000]">
                            <div className="bg-[#ffffff] dark:bg-[#0f0f0f] p-5 rounded-[28px] shadow-sm mb-6">
                                <div className="text-xs font-bold uppercase text-gray-400 mb-2">Dein Code</div>
                                <div className="flex items-center justify-between gap-3">
                                    <div className="font-bold tracking-wider dark:text-white">{mySecretId || 'â€”'}</div>
                                    <button
                                        onClick={() => { if (mySecretId) { navigator.clipboard.writeText(mySecretId); showToast('Code kopiert'); } }}
                                        className="text-xs font-bold bg-gray-100 dark:bg-[#1a1a1a] dark:text-[#e8ecf5] px-3 py-2 rounded-xl"
                                    >
                                        Kopieren
                                    </button>
                                </div>
</div>

                            <div className="bg-[#ffffff] dark:bg-[#0f0f0f] p-5 rounded-[28px] shadow-sm mb-6">
                                <div className="text-xs font-bold uppercase text-gray-400 mb-3">Neue VerknÃ¼pfung (nur via Code)</div>
                                <div className="flex gap-2 items-center">
                                    
                                    <input
                                        className="flex-1 bg-gray-50 dark:bg-[#1a1a1a] dark:text-[#e8ecf5] rounded-2xl px-4 py-3 text-sm font-bold outline-none"
                                        placeholder="Code oder UID"
                                        value={idInput}
                                        onChange={e => setIdInput(e.target.value)}
                                    />
                                    <button
                                        disabled={busy || !ready}
                                        onClick={connectById}
                                        className="bg-[#2563eb] hover:bg-[#1d4ed8] dark:bg-[#4da3ff] dark:hover:bg-[#3b8fe7] text-white dark:text-[#000000] transition-colors px-4 rounded-2xl font-bold"
                                    >
                                        {busy ? 'â€¦' : 'Verbinden'}
                                    </button>
                                </div>
                            </div>

                            <div className="text-xs font-bold uppercase text-gray-400 mb-3 ml-1">VerknÃ¼pfungen</div>
                            <div className="space-y-3">
                                {convs.length === 0 ? (
                                    <div className="text-center py-10 opacity-50 border-2 border-dashed dark:border-[#1f1f1f] rounded-3xl text-sm dark:text-gray-400">
                                        Keine Verbindungen
                                    </div>
                                ) : convs.map(c => {
                                    const other = getOtherUid(c);
                                    const name = profiles[other]?.username || shortUid(other);
                                    const last = c.lastMessageAt?.toDate?.() ? c.lastMessageAt.toDate().toLocaleString('de-DE', { day:'2-digit', month:'2-digit', hour:'2-digit', minute:'2-digit' }) : '';
                                    return (
                                        <button key={c.id} onClick={() => { setActiveConvId(c.id); setView('detail'); }} className="w-full text-left bg-[#ffffff] dark:bg-[#0f0f0f] p-5 rounded-[28px] shadow-sm flex items-center justify-between">
                                            <div className="flex items-center gap-3">
                                                <div className="w-10 h-10 rounded-2xl bg-gray-50 dark:bg-[#1a1a1a] flex items-center justify-center">
                                                    <Icon name="user" />
                                                </div>
                                                <div>
                                                    <div className="font-bold dark:text-white">{name}</div>
                                                    <div className="text-[11px] text-gray-400">{profiles[other]?.secretId ? `Code: ${profiles[other].secretId}` : shortUid(other)}</div>
                                                </div>
                                            </div>
                                            <div className="text-[11px] text-gray-400">{last}</div>
                                        </button>
                                    );
                                })}
                            </div>
                        </div>
                    ) : (
                        <div className="flex-1 flex flex-col bg-[#F8F9FA] dark:bg-[#000000]">
                            <div ref={scrollRef} className="flex-1 overflow-y-auto p-6 space-y-3">
                                {messages.length === 0 ? (
                                    <div className="text-center py-10 opacity-50 border-2 border-dashed dark:border-[#1f1f1f] rounded-3xl text-sm dark:text-gray-400">
                                        Keine EintrÃ¤ge
                                    </div>
                                ) : messages.filter(m => !hiddenIds[m.id]).map(m => {
                                    const mine = m.senderId === user.uid;
                                    return (
                                        <div key={m.id} className={`flex ${mine ? 'justify-end' : 'justify-start'}`}>
                                            <div className={`max-w-[80%] rounded-3xl ${m.kind === 'img' ? 'p-2' : (m.kind === 'aud' ? 'px-3 py-2' : 'px-4 py-3')} shadow-sm ${mine ? 'bg-black text-white dark:bg-white dark:text-black' : 'bg-white dark:bg-[#0f0f0f] dark:text-white'}`}>
                                                {m.kind === 'img' ? (
                                                    <button type="button" onClick={() => openMedia(m)} className="block">
                                                        {m.thumbDataUrl ? (
                                                            <img src={m.thumbDataUrl} className="w-44 h-44 object-cover rounded-2xl filter blur-sm" alt="Verschwommene Bildvorschau, Tippen zum Anzeigen" />
                                                        ) : (
                                                            <div className="w-44 h-44 rounded-2xl bg-gray-200 dark:bg-[#1a1a1a] flex items-center justify-center">
                                                                <Icon name="image" />
                                                            </div>
                                                        )}
                                                    </button>
                                                ) : m.kind === 'aud' ? (
                                                    <button
                                                        type="button"
                                                        onClick={() => playAudio(m)}
                                                        className="flex items-center gap-3"
                                                        title="Audio abspielen"
                                                    >
                                                        <div className={`w-10 h-10 rounded-2xl flex items-center justify-center ${mine ? 'bg-white/15 dark:bg-black/15' : 'bg-gray-100 dark:bg-[#1a1a1a]'}`}>
                                                            {playBusyId === m.id ? (
                                                                <div className="w-5 h-5 border-2 border-current border-t-transparent rounded-full animate-spin"></div>
                                                            ) : (
                                                                <Icon name="play" />
                                                            )}
                                                        </div>
                                                        {/* Audio waveform visualization */}
                                                        <div className="flex items-center gap-0.5 h-8">
                                                            {[3, 6, 4, 8, 5, 7, 4, 6, 3, 5, 7, 6, 4, 5, 8, 6].map((height, idx) => (
                                                                <div 
                                                                    key={idx}
                                                                    className={`w-0.5 rounded-full transition-all ${playBusyId === m.id ? 'animate-pulse' : ''}`}
                                                                    style={{
                                                                        height: `${height * 2}px`,
                                                                        backgroundColor: mine ? 'rgba(255,255,255,0.5)' : 'rgba(0,0,0,0.3)'
                                                                    }}
                                                                />
                                                            ))}
                                                        </div>
                                                        <div className={`text-xs font-medium ${mine ? 'opacity-80' : 'opacity-60'}`}>{formatDur(m.durationMs || 0)}</div>
                                                    </button>
                                                ) : (
                                                    <div className={`text-sm leading-snug ${m._ok ? '' : 'opacity-70'}`}>{m.text}</div>
                                                )}
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                            <div className="p-4 border-t border-[#e2e8f0] dark:border-[#1f1f1f] bg-[#f8f9fb] dark:bg-[#000000]">
                                <div className="flex gap-2 items-center">
                                    <input
                                        ref={libraryInputRef}
                                        type="file"
                                        accept="image/*"
                                        className="hidden"
                                        onChange={async (e) => {
                                            const f = e.target.files && e.target.files[0];
                                            e.target.value = '';
                                            if (f) await sendMedia(f);
                                        }}
                                    />
                                    <input
                                        ref={cameraInputRef}
                                        type="file"
                                        accept="image/*"
                                        capture="environment"
                                        className="hidden"
                                        onChange={async (e) => {
                                            const f = e.target.files && e.target.files[0];
                                            e.target.value = '';
                                            if (f) await sendMedia(f);
                                        }}
                                    />
                                    <button
                                        type="button"
                                        disabled={busy || !ready || !activeConvId || recOn}
                                        onClick={openGallery}
                                        className="p-3 rounded-2xl bg-gray-100 dark:bg-[#0f0f0f] dark:text-[#e8ecf5] shadow-sm disabled:opacity-50"
                                    >
                                        <Icon name="image" />
                                    </button>
                                    <button
                                        type="button"
                                        disabled={busy || !ready || !activeConvId || recOn}
                                        onClick={openCamera}
                                        className="p-3 rounded-2xl bg-gray-100 dark:bg-[#0f0f0f] dark:text-[#e8ecf5] shadow-sm disabled:opacity-50"
                                    >
                                        <Icon name="camera" />
                                    </button>
                                    <button
                                        type="button"
                                        disabled={busy || !ready || !activeConvId}
                                        onPointerDown={(e) => { e.preventDefault(); e.stopPropagation(); recOn ? stopRec(true) : startRec(); }}
                                        className={`p-3 rounded-2xl shadow-sm ${recOn ? 'bg-black text-white dark:bg-white dark:text-black animate-pulse' : 'bg-gray-100 dark:bg-[#0f0f0f] dark:text-white'} disabled:opacity-50`}
                                    >
                                        <Icon name={recOn ? 'stop' : 'mic'} />
                                    </button>
                                    <input
                                        className="flex-1 bg-gray-100 dark:bg-[#0f0f0f] dark:text-[#e8ecf5] rounded-2xl px-4 py-3 text-sm font-bold outline-none"
                                        placeholder="Eintragâ€¦"
                                        value={draft}
                                        onChange={e => setDraft(e.target.value)}
                                        onKeyDown={(e) => { if (e.key === 'Enter') sendMessage(); }}
                                    />
                                    <button
                                        disabled={busy || !draft.trim()}
                                        onClick={sendMessage}
                                        className="p-3 rounded-2xl bg-black text-white dark:bg-white dark:text-black shadow-sm"
                                    >
                                        <Icon name="send" />
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {mediaOverlay && (
                        <div
                            className="fixed inset-0 z-[200] bg-black/80 flex items-center justify-center fade-in"
                            onClick={() => {
                                if (!mediaOverlay) return;
                                const openedAt = mediaOverlay.openedAt || 0;
                                if (openedAt && (Date.now() - openedAt) < 450) return;
                                if (mediaOverlay.loading) { closeMedia(); return; }
                                deleteMedia(mediaOverlay.msg);
                            }}
                        >
                            {mediaOverlay.loading ? (
                                <div className="w-12 h-12 border-4 border-white/30 border-t-white rounded-full animate-spin"></div>
                            ) : (
                                <img src={mediaOverlay.url} className="max-w-[92vw] max-h-[92vh] rounded-3xl shadow-2xl" />
                            )}
                        </div>
                    )}

                </div>
            );
        };

        // --- TIME TRACKING PANEL ---
        const TimeTrackingPanel = ({ user, db, onClose, showToast }) => {
            const [activeSession, setActiveSession] = useState(null);
            const [timeEntries, setTimeEntries] = useState([]);
            const [loading, setLoading] = useState(true);
            const [currentTime, setCurrentTime] = useState(new Date());
            const [showHistory, setShowHistory] = useState(false);
            const [selectedMonth, setSelectedMonth] = useState(new Date());
            const [viewType, setViewType] = useState('month'); // 'week', 'month', 'year'
            const [editingEntry, setEditingEntry] = useState(null);
            const [editForm, setEditForm] = useState({ clockIn: '', clockOut: '', notes: '' });

            // Update current time every second when session is active
            useEffect(() => {
                if (!activeSession) return;
                const timer = setInterval(() => setCurrentTime(new Date()), 1000);
                return () => clearInterval(timer);
            }, [activeSession]);

            // Load active session and recent entries
            useEffect(() => {
                if (!user) return;
                const unsubActive = db.collection('timeTracking')
                    .where('userId', '==', user.uid)
                    .where('clockOut', '==', null)
                    .limit(1)
                    .onSnapshot(snap => {
                        if (!snap.empty) {
                            const doc = snap.docs[0];
                            setActiveSession({ id: doc.id, ...doc.data() });
                        } else {
                            setActiveSession(null);
                        }
                        setLoading(false);
                    }, err => {
                        console.error('Error loading active session:', err);
                        showToast('Fehler beim Laden der aktiven Sitzung');
                        setLoading(false);
                    });

                // Calculate date range based on view type
                let startDate, endDate;
                if (viewType === 'week') {
                    // Get start of week (Monday)
                    const day = selectedMonth.getDay();
                    const diff = selectedMonth.getDate() - day + (day === 0 ? -6 : 1);
                    startDate = new Date(selectedMonth.getFullYear(), selectedMonth.getMonth(), diff);
                    endDate = new Date(startDate);
                    endDate.setDate(startDate.getDate() + 6);
                    endDate.setHours(23, 59, 59, 999);
                } else if (viewType === 'month') {
                    startDate = new Date(selectedMonth.getFullYear(), selectedMonth.getMonth(), 1);
                    endDate = new Date(selectedMonth.getFullYear(), selectedMonth.getMonth() + 1, 0, 23, 59, 59);
                } else { // year
                    startDate = new Date(selectedMonth.getFullYear(), 0, 1);
                    endDate = new Date(selectedMonth.getFullYear(), 11, 31, 23, 59, 59);
                }

                // Simple query without composite index requirement
                const unsubEntries = db.collection('timeTracking')
                    .where('userId', '==', user.uid)
                    .onSnapshot(snap => {
                        // Filter by date range and sort in memory
                        const allEntries = snap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        const filteredEntries = allEntries
                            .filter(entry => {
                                if (!entry.clockIn) return false;
                                const entryDate = entry.clockIn.toDate ? entry.clockIn.toDate() : new Date(entry.clockIn);
                                return entryDate >= startDate && entryDate <= endDate;
                            })
                            .sort((a, b) => {
                                // Sort by clockIn descending (newest first)
                                const dateA = a.clockIn?.toMillis ? a.clockIn.toMillis() : 0;
                                const dateB = b.clockIn?.toMillis ? b.clockIn.toMillis() : 0;
                                return dateB - dateA;
                            });
                        setTimeEntries(filteredEntries);
                    }, err => {
                        console.error('Error loading time entries:', err);
                        showToast('Fehler beim Laden der Historie');
                    });

                return () => { unsubActive(); unsubEntries(); };
            }, [user, selectedMonth, viewType]);

            const clockIn = async () => {
                if (activeSession || !user) return;
                try {
                    console.log('Attempting to clock in for user:', user.uid);
                    const docRef = await db.collection('timeTracking').add({
                        userId: user.uid,
                        userName: user.displayName || 'Unbekannt',
                        clockIn: firebase.firestore.FieldValue.serverTimestamp(),
                        clockOut: null,
                        duration: null,
                        notes: '',
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    console.log('Clock in successful, doc ID:', docRef.id);
                    showToast('âœ“ Eingestempelt');
                } catch (err) {
                    console.error('Clock in error:', err);
                    showToast('Fehler beim Einstempeln: ' + err.message);
                }
            };

            const clockOut = async () => {
                if (!activeSession || !user) return;
                try {
                    console.log('Attempting to clock out, session ID:', activeSession.id);
                    const clockOutTime = firebase.firestore.Timestamp.now();
                    const clockInTime = activeSession.clockIn;
                    const durationMs = clockOutTime.toMillis() - clockInTime.toMillis();
                    const durationHours = (durationMs / (1000 * 60 * 60)).toFixed(2);

                    await db.collection('timeTracking').doc(activeSession.id).update({
                        clockOut: clockOutTime,
                        duration: parseFloat(durationHours)
                    });
                    console.log('Clock out successful');
                    showToast(`âœ“ Ausgestempelt (${durationHours}h)`);
                } catch (err) {
                    console.error('Clock out error:', err);
                    showToast('Fehler beim Ausstempeln: ' + err.message);
                }
            };

            const deleteEntry = async (entryId) => {
                if (!confirm('Eintrag wirklich lÃ¶schen?')) return;
                try {
                    console.log('Deleting entry:', entryId);
                    await db.collection('timeTracking').doc(entryId).delete();
                    showToast('âœ“ Eintrag gelÃ¶scht');
                } catch (err) {
                    console.error('Delete error:', err);
                    showToast('Fehler beim LÃ¶schen: ' + err.message);
                }
            };

            const startEdit = (entry) => {
                setEditingEntry(entry.id);
                const clockInDate = entry.clockIn?.toDate ? entry.clockIn.toDate() : new Date(entry.clockIn);
                const clockOutDate = entry.clockOut?.toDate ? entry.clockOut.toDate() : null;
                setEditForm({
                    clockIn: clockInDate.toISOString().slice(0, 16),
                    clockOut: clockOutDate ? clockOutDate.toISOString().slice(0, 16) : '',
                    notes: entry.notes || ''
                });
            };

            const cancelEdit = () => {
                setEditingEntry(null);
                setEditForm({ clockIn: '', clockOut: '', notes: '' });
            };

            const saveEdit = async (entryId) => {
                try {
                    console.log('Saving edit for entry:', entryId);
                    const clockInTime = firebase.firestore.Timestamp.fromDate(new Date(editForm.clockIn));
                    const clockOutTime = editForm.clockOut ? firebase.firestore.Timestamp.fromDate(new Date(editForm.clockOut)) : null;
                    
                    let duration = null;
                    if (clockOutTime) {
                        const durationMs = clockOutTime.toMillis() - clockInTime.toMillis();
                        duration = parseFloat((durationMs / (1000 * 60 * 60)).toFixed(2));
                    }

                    await db.collection('timeTracking').doc(entryId).update({
                        clockIn: clockInTime,
                        clockOut: clockOutTime,
                        duration: duration,
                        notes: editForm.notes
                    });
                    
                    setEditingEntry(null);
                    setEditForm({ clockIn: '', clockOut: '', notes: '' });
                    showToast('âœ“ Eintrag gespeichert');
                } catch (err) {
                    console.error('Save edit error:', err);
                    showToast('Fehler beim Speichern: ' + err.message);
                }
            };

            const getViewLabel = () => {
                if (viewType === 'week') {
                    const day = selectedMonth.getDay();
                    const diff = selectedMonth.getDate() - day + (day === 0 ? -6 : 1);
                    const monday = new Date(selectedMonth.getFullYear(), selectedMonth.getMonth(), diff);
                    const sunday = new Date(monday);
                    sunday.setDate(monday.getDate() + 6);
                    return `${monday.toLocaleDateString('de-DE', { day: '2-digit', month: '2-digit' })} - ${sunday.toLocaleDateString('de-DE', { day: '2-digit', month: '2-digit', year: 'numeric' })}`;
                } else if (viewType === 'month') {
                    return selectedMonth.toLocaleDateString('de-DE', { month: 'long', year: 'numeric' });
                } else {
                    return selectedMonth.getFullYear().toString();
                }
            };

            const navigatePeriod = (direction) => {
                const newDate = new Date(selectedMonth);
                if (viewType === 'week') {
                    newDate.setDate(newDate.getDate() + (direction * 7));
                } else if (viewType === 'month') {
                    newDate.setMonth(newDate.getMonth() + direction);
                } else {
                    newDate.setFullYear(newDate.getFullYear() + direction);
                }
                setSelectedMonth(newDate);
            };

            const formatTime = (timestamp) => {
                if (!timestamp) return '--:--';
                const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
                return date.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
            };

            const formatDate = (timestamp) => {
                if (!timestamp) return '';
                const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
                return date.toLocaleDateString('de-DE', { day: '2-digit', month: '2-digit', year: 'numeric' });
            };

            const formatDuration = (hours) => {
                if (!hours) return '0:00';
                const h = Math.floor(hours);
                const m = Math.round((hours - h) * 60);
                return `${h}:${m.toString().padStart(2, '0')}`;
            };

            const getElapsedTime = () => {
                if (!activeSession || !activeSession.clockIn) return '0:00:00';
                const start = activeSession.clockIn.toDate ? activeSession.clockIn.toDate() : new Date(activeSession.clockIn);
                const diff = Math.max(0, currentTime - start); // Ensure non-negative
                const hours = Math.floor(diff / (1000 * 60 * 60));
                const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((diff % (1000 * 60)) / 1000);
                return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            };

            const totalHours = timeEntries.reduce((sum, entry) => sum + (entry.duration || 0), 0);
            const completedEntries = timeEntries.filter(e => e.clockOut);
            const avgHoursPerDay = completedEntries.length > 0 ? (totalHours / completedEntries.length) : 0;

            // Export time tracking history to CSV
            const exportToCSV = () => {
                if (timeEntries.length === 0) {
                    showToast('Keine EintrÃ¤ge zum Exportieren');
                    return;
                }

                let csvContent = 'Datum,Einstempeln,Ausstempeln,Dauer (Stunden),Notizen\n';
                
                timeEntries.forEach(entry => {
                    const date = formatDate(entry.clockIn);
                    const clockIn = formatTime(entry.clockIn);
                    const clockOut = entry.clockOut ? formatTime(entry.clockOut) : 'Laufend';
                    const duration = entry.duration || '0';
                    const notes = (entry.notes || '').replace(/"/g, '""'); // Escape quotes
                    csvContent += `"${date}","${clockIn}","${clockOut}","${duration}","${notes}"\n`;
                });

                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `zeiterfassung_${getViewLabel().replace(/\s/g, '_')}.csv`;
                link.click();
                URL.revokeObjectURL(url);
                showToast('CSV Export erfolgreich');
            };

            if (loading) {
                return (
                    <div className="fixed inset-0 z-[200] bg-black/50 flex items-end md:items-center justify-center p-4 fade-in">
                        <div className="bg-[#ffffff] dark:bg-[#0f0f0f] rounded-[32px] w-full max-w-md p-8 text-center">
                            <div className="text-gray-400">Lade Zeiterfassung...</div>
                        </div>
                    </div>
                );
            }

            return (
                <div className="fixed inset-0 z-[200] bg-black/50 flex items-end md:items-center justify-center p-4 fade-in">
                    <div className="bg-[#ffffff] dark:bg-[#0f0f0f] rounded-[32px] w-full max-w-md max-h-[90vh] flex flex-col shadow-2xl slide-up">
                        <div className="p-6 border-b border-[#e2e8f0] dark:border-[#1f1f1f] flex justify-between items-center">
                            <h2 className="text-2xl font-bold dark:text-white">â±ï¸ Zeiterfassung</h2>
                            <button onClick={onClose} className="p-2 bg-gray-100 dark:bg-[#1a1a1a] dark:text-[#e8ecf5] rounded-full">
                                <Icon name="x" size={24}/>
                            </button>
                        </div>

                        <div className="flex-1 overflow-y-auto p-6">
                            {/* Active Session */}
                            {activeSession ? (
                                <div className="bg-gradient-to-br from-green-500 to-emerald-600 text-white rounded-3xl p-6 mb-6 shadow-lg">
                                    <div className="flex justify-between items-start mb-4">
                                        <div>
                                            <div className="text-sm opacity-90 mb-1">Aktive Sitzung</div>
                                            <div className="text-3xl font-bold">{getElapsedTime()}</div>
                                        </div>
                                        <div className="w-3 h-3 bg-white rounded-full animate-pulse"></div>
                                    </div>
                                    <div className="text-sm opacity-90 mb-4">
                                        Einstempeln: {formatTime(activeSession.clockIn)} Uhr
                                    </div>
                                    <button 
                                        onClick={clockOut}
                                        className="w-full bg-white text-green-600 font-bold py-3 rounded-2xl shadow-lg hover:shadow-xl transition-all"
                                    >
                                        ðŸ• Ausstempeln
                                    </button>
                                </div>
                            ) : (
                                <div className="bg-gradient-to-br from-blue-500 to-indigo-600 text-white rounded-3xl p-6 mb-6 shadow-lg">
                                    <div className="text-center mb-4">
                                        <div className="text-5xl mb-2">â±ï¸</div>
                                        <div className="text-xl font-bold mb-1">Bereit zum Stempeln</div>
                                        <div className="text-sm opacity-90">Keine aktive Sitzung</div>
                                    </div>
                                    <button 
                                        onClick={clockIn}
                                        className="w-full bg-white text-blue-600 font-bold py-3 rounded-2xl shadow-lg hover:shadow-xl transition-all"
                                    >
                                        ðŸ• Einstempeln
                                    </button>
                                </div>
                            )}

                            {/* Statistics */}
                            <div className="grid grid-cols-2 gap-4 mb-6">
                                <div className="bg-gray-50 dark:bg-[#1a1a1a] rounded-2xl p-4">
                                    <div className="text-xs text-gray-400 mb-1">Gesamt Stunden</div>
                                    <div className="text-2xl font-bold dark:text-white">{formatDuration(totalHours)}</div>
                                </div>
                                <div className="bg-gray-50 dark:bg-[#1a1a1a] rounded-2xl p-4">
                                    <div className="text-xs text-gray-400 mb-1">Ã˜ pro Tag</div>
                                    <div className="text-2xl font-bold dark:text-white">{formatDuration(avgHoursPerDay)}</div>
                                </div>
                            </div>

                            {/* View Type Selector */}
                            <div className="mb-4">
                                <div className="flex gap-2 bg-gray-100 dark:bg-[#1a1a1a] p-1 rounded-xl">
                                    <button 
                                        onClick={() => setViewType('week')}
                                        className={`flex-1 py-2 px-3 rounded-lg text-xs font-bold transition-all ${viewType === 'week' ? 'bg-white dark:bg-[#0f0f0f] text-black dark:text-[#e8ecf5] shadow' : 'text-gray-500'}`}
                                    >
                                        Woche
                                    </button>
                                    <button 
                                        onClick={() => setViewType('month')}
                                        className={`flex-1 py-2 px-3 rounded-lg text-xs font-bold transition-all ${viewType === 'month' ? 'bg-white dark:bg-[#0f0f0f] text-black dark:text-[#e8ecf5] shadow' : 'text-gray-500'}`}
                                    >
                                        Monat
                                    </button>
                                    <button 
                                        onClick={() => setViewType('year')}
                                        className={`flex-1 py-2 px-3 rounded-lg text-xs font-bold transition-all ${viewType === 'year' ? 'bg-white dark:bg-[#0f0f0f] text-black dark:text-[#e8ecf5] shadow' : 'text-gray-500'}`}
                                    >
                                        Jahr
                                    </button>
                                </div>
                            </div>

                            {/* Period Navigator & History Toggle */}
                            <div className="flex justify-between items-center mb-4">
                                <div className="flex items-center gap-2">
                                    <button 
                                        onClick={() => navigatePeriod(-1)}
                                        className="p-2 hover:bg-gray-100 dark:hover:bg-[#2D2D2D] rounded-lg"
                                    >
                                        <Icon name="chevronLeft" size={16}/>
                                    </button>
                                    <span className="text-sm font-bold dark:text-[#e8ecf5] min-w-[180px] text-center">
                                        {getViewLabel()}
                                    </span>
                                    <button 
                                        onClick={() => navigatePeriod(1)}
                                        className="p-2 hover:bg-gray-100 dark:hover:bg-[#2D2D2D] rounded-lg"
                                    >
                                        <Icon name="chevronRight" size={16}/>
                                    </button>
                                </div>
                                <div className="flex gap-2">
                                    <button 
                                        onClick={exportToCSV}
                                        className="text-xs bg-green-500 text-white px-3 py-2 rounded-full font-bold hover:bg-green-600"
                                        title="CSV Export"
                                    >
                                        ðŸ“Š Export
                                    </button>
                                    <button 
                                        onClick={() => setShowHistory(!showHistory)}
                                        className="text-xs bg-[#2563eb] hover:bg-[#1d4ed8] dark:bg-[#4da3ff] dark:hover:bg-[#3b8fe7] text-white dark:text-[#000000] transition-colors px-3 py-2 rounded-full font-bold"
                                    >
                                        {showHistory ? 'Verbergen' : 'Historie'}
                                    </button>
                                </div>
                            </div>

                            {/* History */}
                            {showHistory && (
                                <div className="space-y-2">
                                    <h3 className="text-xs font-bold text-gray-400 uppercase mb-3">EintrÃ¤ge ({timeEntries.length})</h3>
                                    {timeEntries.length === 0 ? (
                                        <div className="text-center py-8 text-gray-400 text-sm">
                                            Keine EintrÃ¤ge fÃ¼r {viewType === 'week' ? 'diese Woche' : viewType === 'month' ? 'diesen Monat' : 'dieses Jahr'}
                                        </div>
                                    ) : (
                                        timeEntries.map(entry => (
                                            <div key={entry.id} className="bg-white dark:bg-[#1a1a1a] border border-[#e2e8f0] dark:border-gray-700 rounded-2xl p-4">
                                                {editingEntry === entry.id ? (
                                                    // Edit Mode
                                                    <div className="space-y-3">
                                                        <div>
                                                            <label className="text-xs text-gray-400 block mb-1">Einstempeln</label>
                                                            <input 
                                                                type="datetime-local" 
                                                                value={editForm.clockIn}
                                                                onChange={(e) => setEditForm({...editForm, clockIn: e.target.value})}
                                                                className="w-full bg-gray-50 dark:bg-[#0f0f0f] px-3 py-2 rounded-lg text-sm dark:text-[#e8ecf5] outline-none"
                                                            />
                                                        </div>
                                                        <div>
                                                            <label className="text-xs text-gray-400 block mb-1">Ausstempeln</label>
                                                            <input 
                                                                type="datetime-local" 
                                                                value={editForm.clockOut}
                                                                onChange={(e) => setEditForm({...editForm, clockOut: e.target.value})}
                                                                className="w-full bg-gray-50 dark:bg-[#0f0f0f] px-3 py-2 rounded-lg text-sm dark:text-[#e8ecf5] outline-none"
                                                            />
                                                        </div>
                                                        <div>
                                                            <label className="text-xs text-gray-400 block mb-1">Notizen</label>
                                                            <input 
                                                                type="text" 
                                                                value={editForm.notes}
                                                                onChange={(e) => setEditForm({...editForm, notes: e.target.value})}
                                                                placeholder="Optional..."
                                                                className="w-full bg-gray-50 dark:bg-[#0f0f0f] px-3 py-2 rounded-lg text-sm dark:text-[#e8ecf5] outline-none"
                                                            />
                                                        </div>
                                                        <div className="flex gap-2">
                                                            <button 
                                                                onClick={() => saveEdit(entry.id)}
                                                                className="flex-1 bg-green-500 text-white py-2 rounded-lg text-xs font-bold hover:bg-green-600"
                                                            >
                                                                âœ“ Speichern
                                                            </button>
                                                            <button 
                                                                onClick={cancelEdit}
                                                                className="flex-1 bg-gray-300 dark:bg-gray-600 text-gray-700 dark:text-[#e8ecf5] py-2 rounded-lg text-xs font-bold hover:bg-gray-400 dark:hover:bg-gray-700"
                                                            >
                                                                Abbrechen
                                                            </button>
                                                        </div>
                                                    </div>
                                                ) : (
                                                    // View Mode
                                                    <>
                                                        <div className="flex justify-between items-start mb-2">
                                                            <div className="text-sm font-bold dark:text-white">
                                                                {formatDate(entry.clockIn)}
                                                            </div>
                                                            {entry.duration && (
                                                                <div className="text-sm font-bold text-green-600">
                                                                    {formatDuration(entry.duration)}
                                                                </div>
                                                            )}
                                                        </div>
                                                        <div className="flex items-center gap-4 text-xs text-gray-500 mb-3">
                                                            <div className="flex items-center gap-1">
                                                                <span>ðŸ• {formatTime(entry.clockIn)}</span>
                                                            </div>
                                                            {entry.clockOut ? (
                                                                <div className="flex items-center gap-1">
                                                                    <span>â†’ {formatTime(entry.clockOut)}</span>
                                                                </div>
                                                            ) : (
                                                                <div className="text-orange-500 font-bold">â— Aktiv</div>
                                                            )}
                                                        </div>
                                                        {entry.notes && (
                                                            <div className="text-xs text-gray-400 mb-3 italic">"{entry.notes}"</div>
                                                        )}
                                                        <div className="flex gap-2 border-t border-[#e2e8f0] dark:border-gray-700 pt-3">
                                                            <button 
                                                                onClick={() => startEdit(entry)}
                                                                className="flex-1 bg-blue-50 dark:bg-blue-900/20 text-blue-600 dark:text-blue-400 py-2 rounded-lg text-xs font-bold hover:bg-blue-100 dark:hover:bg-blue-900/30"
                                                            >
                                                                âœï¸ Bearbeiten
                                                            </button>
                                                            <button 
                                                                onClick={() => deleteEntry(entry.id)}
                                                                className="flex-1 bg-red-50 dark:bg-red-900/20 text-red-600 dark:text-red-400 py-2 rounded-lg text-xs font-bold hover:bg-red-100 dark:hover:bg-red-900/30"
                                                            >
                                                                ðŸ—‘ï¸ LÃ¶schen
                                                            </button>
                                                        </div>
                                                    </>
                                                )}
                                            </div>
                                        ))
                                    )}
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // --- APP ---
        const App = () => {
            const [user, setUser] = useState(null);
            const [userData, setUserData] = useState({});
            const [categories, setCategories] = useState(DEFAULT_CATEGORIES);
            const [isDemo, setIsDemo] = useState(false);
            const [darkMode, setDarkMode] = useState(localStorage.getItem('theme') === 'dark');
            
            const [deviceReady, setDeviceReady] = useState(!window.cordova);

            useEffect(() => {
                if (!window.cordova) return;
                const onReady = () => setDeviceReady(true);
                document.addEventListener('deviceready', onReady, false);
                return () => document.removeEventListener('deviceready', onReady, false);
            }, []);

            const [myCalendars, setMyCalendars] = useState([]);
            const [activeCalendarId, setActiveCalendarId] = useState(null);
            const [events, setEvents] = useState([]);
            const [requests, setRequests] = useState([]);
            
            // Shift Plan & Drag Selection
            const [shiftMode, setShiftMode] = useState(false);
            const [showShiftSelector, setShowShiftSelector] = useState(false);
            const [dragSelection, setDragSelection] = useState({ start: null, end: null, isDragging: false });
            
            // Standard UI
            const [currentDate, setCurrentDate] = useState(new Date());
            const [selectedDate, setSelectedDate] = useState(new Date());
            const [showAddEventModal, setShowAddEventModal] = useState(false);
            const [showSettingsModal, setShowSettingsModal] = useState(false);
            const [showCategoryEditor, setShowCategoryEditor] = useState(false);
            const [showSearchModal, setShowSearchModal] = useState(false);
            const [showCalendarSwitcher, setShowCalendarSwitcher] = useState(false);
            const [showRequestPopup, setShowRequestPopup] = useState(false);
            const [toast, setToast] = useState(null);
            const [expandedEventId, setExpandedEventId] = useState(null);
            // Archiv (Hidden)
            const [showVaultPanel, setShowVaultPanel] = useState(false);
            // Time Tracking
            const [showTimeTrackingPanel, setShowTimeTrackingPanel] = useState(false);
            const [notificationsEnabled, setNotificationsEnabled] = useState(localStorage.getItem('pw_notify') === '1');
            const secretHoldTimerRef = useRef(null);
            const secretHoldTriggeredRef = useRef(false);
            const secretNotifRef = useRef({ loaded: false, last: {} });
            const [showExportMenu, setShowExportMenu] = useState(false);
            const [showAvailabilityModal, setShowAvailabilityModal] = useState(false);
            const [availabilityProposal, setAvailabilityProposal] = useState({ title: '', dates: [], votes: {}, targetCalId: '' });
            
            // New Features
            const [searchQuery, setSearchQuery] = useState('');
            const [showSearchPanel, setShowSearchPanel] = useState(false);
            const [calendarView, setCalendarView] = useState('month'); // 'month' or 'week'
            const [showBackupModal, setShowBackupModal] = useState(false);
            
            // New Features State
            const [quickAddInput, setQuickAddInput] = useState('');
            const [showTemplatesModal, setShowTemplatesModal] = useState(false);
            const [showHabitsModal, setShowHabitsModal] = useState(false);
            const [habits, setHabits] = useState([]);
            const [habitLogs, setHabitLogs] = useState([]);
            const [themeMode, setThemeMode] = useState(localStorage.getItem('themeMode') || 'light');
            const [themePalette, setThemePalette] = useState(localStorage.getItem('themePalette') || 'default');
            const [templates, setTemplates] = useState([]);
            const [multiSelectMode, setMultiSelectMode] = useState(false);
            const [selectedEventIds, setSelectedEventIds] = useState([]);
            const [showConflictModal, setShowConflictModal] = useState(false);
            const [conflictData, setConflictData] = useState(null);


            const [todayBlinkToken, setTodayBlinkToken] = useState(0);
            const triggerTodayBlink = () => {
                const t = Date.now();
                setTodayBlinkToken(t);
                setTimeout(() => setTodayBlinkToken(cur => (cur === t ? 0 : cur)), 12000);
            };

            useEffect(() => {
                localStorage.setItem('pw_notify', notificationsEnabled ? '1' : '0');
            }, [notificationsEnabled]);

            // Berechtigungen beim Start (Kamera/Mikrofon/Speicher)
            const [permGateOpen, setPermGateOpen] = useState(false);
            const [permGateBusy, setPermGateBusy] = useState(false);
            const [permInfo, setPermInfo] = useState({ cam: 'unbekannt', mic: 'unbekannt', store: 'unbekannt' });

            // Cordova (Android): Runtime-Permissions via cordova-plugin-android-permissions
            const isCordovaAndroid = !!window.cordova && deviceReady && (window.cordova.platformId === 'android');
            const cordovaPerms = isCordovaAndroid && window.cordova.plugins && window.cordova.plugins.permissions ? window.cordova.plugins.permissions : null;

            const cordovaHasPerm = (perm) => new Promise((resolve) => {
                if (!cordovaPerms || !perm) return resolve(false);
                try {
                    cordovaPerms.hasPermission(perm, (s) => resolve(!!s.hasPermission), () => resolve(false));
                } catch (e) { resolve(false); }
            });

            const cordovaRequestPerms = (perms) => new Promise((resolve) => {
                if (!cordovaPerms || !perms || !perms.length) return resolve(true);
                try {
                    cordovaPerms.requestPermissions(perms, () => resolve(true), () => resolve(false));
                } catch (e) { resolve(false); }
            });

            const getWantedPerms = () => {
                if (!cordovaPerms) return [];
                const p = cordovaPerms;
                const list = [];
                if (p.CAMERA) list.push(p.CAMERA);
                if (p.RECORD_AUDIO) list.push(p.RECORD_AUDIO);
                if (p.POST_NOTIFICATIONS) list.push(p.POST_NOTIFICATIONS);
                if (p.READ_MEDIA_IMAGES) list.push(p.READ_MEDIA_IMAGES);
                else if (p.READ_EXTERNAL_STORAGE) list.push(p.READ_EXTERNAL_STORAGE);
                if (p.READ_MEDIA_AUDIO) list.push(p.READ_MEDIA_AUDIO);
                return list;
            };


            const queryPerm = async (name) => {
                try {
                    if (!navigator.permissions?.query) return 'unbekannt';
                    const r = await navigator.permissions.query({ name });
                    return r?.state || 'unbekannt';
                } catch (e) {
                    return 'unbekannt';
                }
            };

            const refreshPermInfo = async () => {
                if (cordovaPerms) {
                    const camOk = await cordovaHasPerm(cordovaPerms.CAMERA);
                    const micOk = await cordovaHasPerm(cordovaPerms.RECORD_AUDIO);

                    let storeOk = false;
                    if (cordovaPerms.READ_MEDIA_IMAGES) storeOk = await cordovaHasPerm(cordovaPerms.READ_MEDIA_IMAGES);
                    else if (cordovaPerms.READ_EXTERNAL_STORAGE) storeOk = await cordovaHasPerm(cordovaPerms.READ_EXTERNAL_STORAGE);

                    setPermInfo({
                        mic: micOk ? 'aktiv' : 'nicht aktiv',
                        cam: camOk ? 'aktiv' : 'nicht aktiv',
                        store: storeOk ? 'aktiv' : 'nicht aktiv'
                    });
                    return;
                }

                const mic = await queryPerm('microphone');
                // 'camera' wird nicht Ã¼berall unterstÃ¼tzt
                const cam = await queryPerm('camera');

                let store = 'unbekannt';
                try {
                    if (navigator.storage?.persisted) {
                        const persisted = await navigator.storage.persisted();
                        store = persisted ? 'aktiv' : 'nicht aktiv';
                    }
                } catch (e) {}

                setPermInfo({
                    mic: mic === 'granted' ? 'aktiv' : (mic === 'denied' ? 'blockiert' : 'unbekannt'),
                    cam: cam === 'granted' ? 'aktiv' : (cam === 'denied' ? 'blockiert' : 'unbekannt'),
                    store
                });
            };

            useEffect(() => {
                if (!user || isDemo) return;
                // bei jedem Start prÃ¼fen; Overlay nur bis erfolgreich
                refreshPermInfo().finally(() => {
                    if (localStorage.getItem('pw_perm_done') !== '1') setPermGateOpen(true);
                });
            }, [user, isDemo]);

            const requestStartupPerms = async () => {
                // Cordova (Android): direkt via Runtime-Permissions (ohne Secure-Context-Anforderung)
                if (cordovaPerms) {
                    setPermGateBusy(true);
                    const ok = await cordovaRequestPerms(getWantedPerms());
                    await refreshPermInfo();
                    setPermGateBusy(false);

                    if (ok) {
                        localStorage.setItem('pw_perm_done', '1');
                        setPermGateOpen(false);
                        showToast('Berechtigungen gesetzt.');
                    } else {
                        showToast('Berechtigungen verweigert.');
                    }
                    return;
                }

                if (!navigator.mediaDevices?.getUserMedia) {
                    showToast('Kamera/Mikrofon im Browser nicht verfÃ¼gbar.');
                    return;
                }

                const proto = (location.protocol || '').toLowerCase();
                const host = (location.hostname || '').toLowerCase();
                const isProbablySecure = !!window.isSecureContext
                    || proto === 'https:'
                    || proto === 'capacitor:'
                    || proto === 'ionic:'
                    || host === 'localhost'
                    || host === '127.0.0.1';

                if (!isProbablySecure) {
                    showToast('BenÃ¶tigt HTTPS/localhost (APK: AssetLoader/Capacitor).');
                    return;
                }

                setPermGateBusy(true);

                let micOk = false;
                let camOk = false;

                try {
                    const s = await navigator.mediaDevices.getUserMedia({ audio: true });
                    micOk = true;
                    try { s.getTracks().forEach(t => t.stop()); } catch(e){}
                } catch (e) {}

                try {
                    const s = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
                    camOk = true;
                    try { s.getTracks().forEach(t => t.stop()); } catch(e){}
                } catch (e) {}

                try {
                    if (navigator.storage?.persist) await navigator.storage.persist();
                } catch (e) {}

                await refreshPermInfo();

                if (micOk && camOk) {
                    localStorage.setItem('pw_perm_done', '1');
                    setPermGateOpen(false);
                    showToast('Berechtigungen aktiv.');
                } else {
                    showToast('Berechtigungen unvollstÃ¤ndig.');
                }

                setPermGateBusy(false);
            };


            const [newEvent, setNewEvent] = useState({ title: '', description: '', time: '12:00', durationMin: 60, category: 'Arbeit', subCategory: '', targetCalId: '', recurrence: null, recurrenceEndDate: null, reminders: [], emoji: '', isFocus: false });
            const [todos, setTodos] = useState([]);
            const [showTodoModal, setShowTodoModal] = useState(false);
            const [newTodo, setNewTodo] = useState({ title: '', description: '', dueDate: '', assignedTo: '', targetCalId: '', checklist: [], completed: false });
            const [proposals, setProposals] = useState([]);
            const [searchName, setSearchName] = useState('');
            const [expandedSettingsId, setExpandedSettingsId] = useState(null);
            const [editName, setEditName] = useState('');
            const [editCalendarName, setEditCalendarName] = useState('');
            
            // Neue Search States
            const [calendarSearchTerm, setCalendarSearchTerm] = useState('');
            const [memberAddName, setMemberAddName] = useState('');

            const [newCatName, setNewCatName] = useState('');
            const [newSubCatName, setNewSubCatName] = useState('');
            const [expandedCatEdit, setExpandedCatEdit] = useState(null);
            const [newShift, setNewShift] = useState({ name: '', time: '', color: '#10B981' });

            const showToast = (msg) => { setToast(msg); setTimeout(() => setToast(null), 3000); };
            const requestNotifications = async () => {
                if (!('Notification' in window)) {
                    showToast('Browser unterstÃ¼tzt keine Benachrichtigungen.');
                    return;
                }
                const perm = await Notification.requestPermission();
                if (perm === 'granted') {
                    setNotificationsEnabled(true);
                    showToast('Benachrichtigungen aktiviert.');
                } else {
                    setNotificationsEnabled(false);
                    showToast('Benachrichtigungen nicht freigegeben.');
                }
            };

            const activeCalendar = myCalendars.find(c => c.id === activeCalendarId);
            const hasShiftPlan = !!activeCalendar?.shiftEnabled;

            useEffect(() => { document.getElementById('loading').style.display = 'none'; }, []);
            
            // Theme System Effect
            useEffect(() => {
                let effectiveDarkMode = darkMode;
                
                // Handle auto mode
                if (themeMode === 'auto') {
                    // Check prefers-color-scheme
                    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                        effectiveDarkMode = true;
                    } else {
                        // Also check time-based (dark between 20:00-06:00)
                        const hour = new Date().getHours();
                        effectiveDarkMode = hour >= 20 || hour < 6;
                    }
                } else {
                    effectiveDarkMode = themeMode === 'dark';
                }
                
                // Apply theme
                document.body.className = `transition-colors duration-300 ${effectiveDarkMode ? 'bg-[#000000] text-[#e8ecf5] dark' : 'bg-[#f8f9fb] text-[#1e293b]'}`;
                
                // Apply palette
                const root = document.documentElement;
                root.className = '';
                if (themePalette && themePalette !== 'default') {
                    root.classList.add(`palette-${themePalette}`);
                }
                if (effectiveDarkMode) {
                    root.classList.add('dark');
                }
                
                // Save to localStorage
                localStorage.setItem('theme', effectiveDarkMode ? 'dark' : 'light');
                localStorage.setItem('themeMode', themeMode);
                localStorage.setItem('themePalette', themePalette);
            }, [darkMode, themeMode, themePalette]);

            useEffect(() => {
                return auth.onAuthStateChanged((u) => {
                    setUser(u);
                    if (u) {
                        setEditName(u.displayName || '');
                        return db.collection('users').doc(u.uid).onSnapshot(d => {
                            if(d.exists) {
                            const data = d.data();
                            setUserData(data);
                            if(data.categories) setCategories(data.categories);

                            // Backfill Secret-ID (fÃ¼r bestehende Accounts)
                            if (!data.secretId) {
                                const sid = generateSecretId();
                                db.collection('users').doc(u.uid).update({ secretId: sid }).catch(()=>{});
                            }
                        }
                        });
                    }
                });
            }, [isDemo]);

            useEffect(() => {
                if (!user || isDemo) return;
                const q = db.collection('calendars').where('memberIds', 'array-contains', user.uid);
                return q.onSnapshot(snapshot => {
                    const cals = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    setMyCalendars(cals);
                    if (!activeCalendarId && cals.length > 0) setActiveCalendarId(cals[0].id);
                    else if (cals.length === 0) createNewCalendar('Mein Kalender');
                    
                    if (activeCalendarId !== ALL_CALENDARS && activeCalendarId && !cals.find(c => c.id === activeCalendarId)) {
                        setActiveCalendarId(cals.length > 0 ? cals[0].id : null);
                    }
                });
            }, [user, isDemo, activeCalendarId]);

            useEffect(() => {
                if (!user || isDemo) return;

                // Initiale Snapshot-Loads nicht als "neu" behandeln
                secretNotifRef.current.loaded = false;

                const q = db.collection('secretConversations').where('memberIds', 'array-contains', user.uid);
                return q.onSnapshot((snap) => {
                    const docs = snap.docs.map(d => ({ id: d.id, ...d.data() }));

                    if (!secretNotifRef.current.loaded) {
                        docs.forEach(c => {
                            const ts = c.lastMessageAt?.toMillis?.() || 0;
                            secretNotifRef.current.last[c.id] = ts;
                        });
                        secretNotifRef.current.loaded = true;
                        return;
                    }

                    snap.docChanges().forEach(ch => {
                        if (ch.type !== 'modified' && ch.type !== 'added') return;
                        const d = ch.doc.data() || {};
                        if (d.lastSenderId === user.uid) return;

                        const ts = d.lastMessageAt?.toMillis?.() || 0;
                        const prev = secretNotifRef.current.last[ch.doc.id] || 0;
                        if (ts && ts > prev) {
                            secretNotifRef.current.last[ch.doc.id] = ts;

                            // UI-Signal: heutiges Datum hervorheben
                            triggerTodayBlink();

                            // Optional: System-Notification (nur wenn freigegeben)
                            if (notificationsEnabled && ('Notification' in window) && Notification.permission === 'granted') {
                                try { new Notification('PlanWise', { body: 'Neuer Eintrag' }); } catch(e){}
                            }
                        }
                    });
                });
            }, [user, isDemo, notificationsEnabled]);
            useEffect(() => {
                if (isDemo && activeCalendarId === 'demo') {
                    setEvents([{id: '1', title: 'Demo', date: new Date(), time: '10:00', category: 'Arbeit', createdByName: 'Demo', calendarId: 'demo'}]);
                    setMyCalendars([{id: 'demo', name: 'Demo Kalender', color: CALENDAR_COLORS[1].hex, members: []}]);
                    return;
                }
                if (!user || myCalendars.length === 0) return;

                const calendarsToFetch = activeCalendarId === ALL_CALENDARS ? myCalendars : myCalendars.filter(c => c.id === activeCalendarId);
                const unsubscribers = calendarsToFetch.map(cal => {
                    const unsub1 = db.collection('calendars').doc(cal.id).collection('events').onSnapshot(snap => {
                        const newEvents = snap.docs.map(d => ({ id: d.id, ...d.data(), date: d.data().date?.toDate(), calendarId: cal.id }));
                        setEvents(prev => {
                            const others = prev.filter(p => p.calendarId !== cal.id);
                            return [...others, ...newEvents];
                        });
                    });
                    const unsub2 = db.collection('calendars').doc(cal.id).collection('requests').onSnapshot(snap => {
                        const reqs = snap.docs.map(d => ({ id: d.id, ...d.data(), date: d.data().date?.toDate(), calendarId: cal.id }));
                        setRequests(prev => {
                            const others = prev.filter(p => p.calendarId !== cal.id);
                            const merged = [...others, ...reqs];
                            if (merged.length > 0 && !showRequestPopup) setShowRequestPopup(true);
                            return merged;
                        });
                    });
                    return () => { unsub1(); unsub2(); };
                });
                return () => unsubscribers.forEach(u => u());
            }, [activeCalendarId, myCalendars, user, isDemo]);

            // Load TODOs
            useEffect(() => {
                if (!user || isDemo) return;
                if (myCalendars.length === 0) return;

                const calendarsToFetch = activeCalendarId === ALL_CALENDARS ? myCalendars : myCalendars.filter(c => c.id === activeCalendarId);
                const unsubscribers = calendarsToFetch.map(cal => {
                    return db.collection('calendars').doc(cal.id).collection('todos').onSnapshot(snap => {
                        const newTodos = snap.docs.map(d => ({ id: d.id, ...d.data(), dueDate: d.data().dueDate?.toDate(), calendarId: cal.id }));
                        setTodos(prev => {
                            const others = prev.filter(p => p.calendarId !== cal.id);
                            return [...others, ...newTodos];
                        });
                    });
                });
                return () => unsubscribers.forEach(u => u());
            }, [activeCalendarId, myCalendars, user, isDemo]);
            
            // Load Habits
            useEffect(() => {
                if (!user || isDemo) return;
                const unsubHabits = db.collection('users').doc(user.uid).collection('habits').onSnapshot(snap => {
                    const newHabits = snap.docs.map(d => ({ id: d.id, ...d.data() }));
                    setHabits(newHabits);
                });
                const unsubLogs = db.collection('users').doc(user.uid).collection('habitLogs').onSnapshot(snap => {
                    const logs = snap.docs.map(d => ({ id: d.id, ...d.data(), date: d.data().date?.toDate() }));
                    setHabitLogs(logs);
                });
                return () => { unsubHabits(); unsubLogs(); };
            }, [user, isDemo]);
            
            // Load Templates
            useEffect(() => {
                if (!user || isDemo) return;
                const unsub = db.collection('users').doc(user.uid).collection('templates').onSnapshot(snap => {
                    const userTemplates = snap.docs.map(d => ({ id: d.id, ...d.data() }));
                    setTemplates([...DEFAULT_TEMPLATES, ...userTemplates]);
                });
                return () => unsub();
            }, [user, isDemo]);

            // Schedule Notifications for Events with Reminders
            useEffect(() => {
                if (!notificationsEnabled || !('Notification' in window)) return;
                if (Notification.permission !== 'granted') return;

                const scheduleNotification = (event, reminderMinutes) => {
                    const eventTime = event.date.getTime();
                    const notifyTime = eventTime - (reminderMinutes * 60 * 1000);
                    const delay = notifyTime - Date.now();

                    if (delay > 0 && delay < (7 * MS_PER_DAY)) { // Within 1 week
                        setTimeout(() => {
                            try {
                                // Format reminder time appropriately
                                let timeText = '';
                                if (reminderMinutes >= 10080) { // 1 week or more
                                    const weeks = Math.floor(reminderMinutes / 10080);
                                    timeText = `${weeks} Woche${weeks > 1 ? 'n' : ''}`;
                                } else if (reminderMinutes >= 1440) {
                                    const days = Math.floor(reminderMinutes / 1440);
                                    timeText = `${days} Tag${days > 1 ? 'en' : ''}`;
                                } else if (reminderMinutes >= 60) {
                                    const hours = Math.floor(reminderMinutes / 60);
                                    timeText = `${hours} Stunde${hours > 1 ? 'n' : ''}`;
                                } else {
                                    timeText = `${reminderMinutes} Minute${reminderMinutes > 1 ? 'n' : ''}`;
                                }
                                
                                new Notification('Erinnerung: ' + event.title, {
                                    body: `Beginnt in ${timeText}`,
                                    tag: event.id + '-' + reminderMinutes,
                                    requireInteraction: true
                                });
                            } catch (e) {}
                        }, delay);
                    }
                };

                events.forEach(event => {
                    if (event.reminders && Array.isArray(event.reminders)) {
                        event.reminders.forEach(reminder => {
                            scheduleNotification(event, reminder);
                        });
                    }
                });
            }, [events, notificationsEnabled]);

            // Load Proposals (Availability Polls)
            useEffect(() => {
                if (!user || isDemo) return;
                if (myCalendars.length === 0) return;

                const calendarsToFetch = activeCalendarId === ALL_CALENDARS ? myCalendars : myCalendars.filter(c => c.id === activeCalendarId);
                const unsubscribers = calendarsToFetch.map(cal => {
                    return db.collection('calendars').doc(cal.id).collection('proposals').onSnapshot(snap => {
                        const newProposals = snap.docs.map(d => ({ 
                            id: d.id, 
                            ...d.data(), 
                            dates: (d.data().dates || []).map(ts => ts.toDate()),
                            calendarId: cal.id 
                        }));
                        setProposals(prev => {
                            const others = prev.filter(p => p.calendarId !== cal.id);
                            return [...others, ...newProposals];
                        });
                    });
                });
                return () => unsubscribers.forEach(u => u());
            }, [activeCalendarId, myCalendars, user, isDemo]);

            // --- TOUCH / DRAG FIX (WICHTIG) ---
            const handleTouchMove = (e) => {
                if (!dragSelection.isDragging) return;
                
                // Verhindert Scrollen beim "Malen"
                if (e.cancelable) e.preventDefault();

                const touch = e.touches[0];
                const target = document.elementFromPoint(touch.clientX, touch.clientY);
                
                if (target) {
                    const btn = target.closest('button[data-date]');
                    if (btn) {
                        const dateStr = btn.getAttribute('data-date');
                        const d = new Date(dateStr);
                        setDragSelection(prev => ({ ...prev, end: d }));
                    }
                }
            };

            const isWorkCalendarActive = () => {
                if (activeCalendarId === ALL_CALENDARS) return false;
                const cal = myCalendars.find(c => c.id === activeCalendarId);
                const n = (cal?.name || '').toLowerCase();
                return !!cal?.isWorkCalendar || n.includes('arbeit') || n.includes('work');
            };

            const startSecretHold = (d) => {
                // Hidden trigger: 3 Sekunden Langdruck auf den 5. (nur im Arbeitskalender)
                if (!user || isDemo) return;
                if (shiftMode) return;
                if (!isWorkCalendarActive()) return;
                if (d.getDate() !== 5) return;
                if (!canUseSecretCrypto()) {
                    showToast('Archiv: benÃ¶tigt HTTPS/localhost (WebCrypto).');
                    return;
                }

                if (secretHoldTimerRef.current) clearTimeout(secretHoldTimerRef.current);
                secretHoldTriggeredRef.current = false;

                secretHoldTimerRef.current = setTimeout(() => {
                    secretHoldTriggeredRef.current = true;
                    setShowVaultPanel(true);
                }, 3000);
            };

            const cancelSecretHold = () => {
                if (secretHoldTimerRef.current) {
                    clearTimeout(secretHoldTimerRef.current);
                    secretHoldTimerRef.current = null;
                }
            };

            const handlePointerDown = (d) => {
                startSecretHold(d);

                if (shiftMode && hasShiftPlan) {
                    setDragSelection({ start: d, end: d, isDragging: true });
                } else {
                    setSelectedDate(d);
                }
            };

            const handlePointerEnter = (d) => {
                if (dragSelection.isDragging) {
                    setDragSelection(prev => ({ ...prev, end: d }));
                }
            };

            // Global Touch End Listener to stop painting
            useEffect(() => {
                const handleGlobalUp = () => {
                    // Stoppt Langdruck-Trigger sauber
                    cancelSecretHold();

                    if (showShiftSelector) return;
                    if (dragSelection.isDragging && dragSelection.start && dragSelection.end) {
                        setDragSelection(prev => ({ ...prev, isDragging: false }));
                        setShowShiftSelector(true);
                    } else {
                        setDragSelection({ start: null, end: null, isDragging: false });
                    }
                };
                window.addEventListener('mouseup', handleGlobalUp);
                window.addEventListener('touchend', handleGlobalUp);
                return () => {
                    window.removeEventListener('mouseup', handleGlobalUp);
                    window.removeEventListener('touchend', handleGlobalUp);
                };
            }, [dragSelection, showShiftSelector]);

            const getDatesInRange = (start, end) => {
                if (!start || !end) return [];
                const dates = [];
                const s = new Date(Math.min(start, end));
                const e = new Date(Math.max(start, end));
                while (s <= e) {
                    dates.push(new Date(s));
                    s.setDate(s.getDate() + 1);
                }
                return dates;
            };

            const isInSelection = (d) => {
                if (!dragSelection.start || !dragSelection.end) return false;
                const s = new Date(Math.min(dragSelection.start, dragSelection.end));
                const e = new Date(Math.max(dragSelection.start, dragSelection.end));
                return d >= s && d <= e;
            };

            // --- DATA FUNCTIONS ---
            const createNewCalendar = async (name) => {
                if (!user || isDemo) return;
                await db.collection('calendars').add({
                    name: name, color: CALENDAR_COLORS[Math.floor(Math.random()*CALENDAR_COLORS.length)].hex, 
                    createdBy: user.uid, createdAt: firebase.firestore.FieldValue.serverTimestamp(), 
                    members: [{ uid: user.uid, role: ROLES.ADMIN, name: user.displayName }], memberIds: [user.uid], isWorkCalendar: false
                });
                showToast("Kalender erstellt");
            };

            const updateCalendar = async (calId, data) => {
                if (!user || isDemo) return;
                try {
                    await db.collection('calendars').doc(calId).update(data);
                    showToast("Aktualisiert");
                } catch(e) { showToast("Fehler"); }
            };

            const handleDeleteCalendar = async (calId) => {
                if (!user || !calId) return;
                
                const calendar = myCalendars.find(c => c && c.id === calId);
                const calName = calendar?.name || 'Kalender';
                
                // Double confirmation for safety
                if (!confirm(`WARNUNG: "${calName}" unwiderruflich lÃ¶schen?\n\nAlle Termine und Daten gehen verloren!`)) return;
                if (!confirm(`Sind Sie wirklich sicher? Diese Aktion kann nicht rÃ¼ckgÃ¤ngig gemacht werden!`)) return;
                
                try {
                    if (!db) {
                        showToast('Datenbank nicht verfÃ¼gbar');
                        return;
                    }
                    setExpandedSettingsId(null);
                    await db.collection('calendars').doc(calId).delete();
                    showToast("Kalender gelÃ¶scht");
                } catch(e) {
                    console.error('Delete calendar error:', e);
                    showToast("Fehler beim LÃ¶schen: " + (e.message || 'Unbekannter Fehler'));
                }
            };

            // MEMBER FUNCTIONS
            const addMemberToCalendar = async (calId) => {
                if (!memberAddName.trim()) return;
                try {
                    const snap = await db.collection('users').where('username', '==', memberAddName.trim()).get();
                    if (snap.empty) { showToast("User nicht gefunden"); return; }
                    const newUser = snap.docs[0].data();
                    
                    const cal = myCalendars.find(c => c.id === calId);
                    if (cal?.memberIds?.includes(newUser.uid)) { showToast("Bereits Mitglied"); return; }
                    
                    await db.collection('calendars').doc(calId).update({
                        memberIds: firebase.firestore.FieldValue.arrayUnion(newUser.uid),
                        members: firebase.firestore.FieldValue.arrayUnion({ uid: newUser.uid, name: newUser.username, role: ROLES.EDITOR })
                    });
                    setMemberAddName('');
                    showToast("HinzugefÃ¼gt");
                } catch(e) { showToast("Fehler"); }
            };

            const removeMemberFromCalendar = async (calId, memberUid) => {
                if (!confirm("Mitglied entfernen?")) return;
                const cal = myCalendars.find(c => c.id === calId);
                if (!cal) { showToast("Kalender nicht gefunden"); return; }
                const updatedMembers = cal.members.filter(m => m.uid !== memberUid);
                const updatedIds = cal.memberIds.filter(id => id !== memberUid);
                await db.collection('calendars').doc(calId).update({ members: updatedMembers, memberIds: updatedIds });
            };

            const handleCreateEvent = async (isRequest = false) => {
                if(isDemo) return;
                let targetId = activeCalendarId === ALL_CALENDARS ? newEvent.targetCalId : activeCalendarId;
                if (!targetId) { showToast("Bitte Kalender wÃ¤hlen"); return; }

                const d = new Date(selectedDate);
                const [h,m] = newEvent.time.split(':');
                d.setHours(parseInt(h), parseInt(m));
                
                const coll = isRequest ? 'requests' : 'events';
                await db.collection('calendars').doc(targetId).collection(coll).add({
                    title: newEvent.title, description: newEvent.description || '', date: firebase.firestore.Timestamp.fromDate(d), 
                    category: newEvent.category, subCategory: newEvent.subCategory, createdBy: user.uid, createdByName: user.displayName, 
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(), 
                    recurrence: newEvent.recurrence || null,
                    recurrenceEndDate: newEvent.recurrenceEndDate ? firebase.firestore.Timestamp.fromDate(new Date(newEvent.recurrenceEndDate)) : null,
                    recurrenceExceptions: [],
                    reminders: newEvent.reminders || [],
                    durationMin: newEvent.durationMin || 60,
                    emoji: newEvent.emoji || '',
                    isFocus: newEvent.isFocus || false
                });
                setShowAddEventModal(false);
                setNewEvent({ ...newEvent, title: '', description: '', reminders: [], recurrence: null, recurrenceEndDate: null, durationMin: 60, emoji: '', isFocus: false });
                showToast(isRequest ? "Anfrage gesendet" : "Gespeichert");
            };

            const handleDeleteEvent = async (ev, isReq) => {
                 if(isDemo) return;
                 if(!confirm(isReq ? "Anfrage lÃ¶schen?" : "Termin lÃ¶schen?")) return;
                 
                 try {
                     if (!db) {
                         showToast('Datenbank nicht verfÃ¼gbar');
                         return;
                     }
                     if (!ev || !ev.id) {
                         showToast('UngÃ¼ltiges Event');
                         return;
                     }
                     
                     const calId = ev.calendarId || activeCalendarId;
                     if (!calId) {
                         showToast('Kalender nicht gefunden');
                         return;
                     }
                     
                     const coll = isReq ? 'requests' : 'events';
                     await db.collection('calendars').doc(calId).collection(coll).doc(ev.id).delete();
                     showToast(isReq ? "Anfrage gelÃ¶scht" : "Termin gelÃ¶scht");
                 } catch (err) {
                     console.error('Delete event error:', err);
                     showToast('Fehler beim LÃ¶schen: ' + (err.message || 'Unbekannter Fehler'));
                 }
            };

            const handleAcceptRequest = async (req) => {
                 await db.collection('calendars').doc(req.calendarId).collection('events').add({ ...req, id: null });
                 await handleDeleteEvent(req, true);
                 showToast("Angenommen");
            };
            const handleDeclineRequest = async (reqId) => {
                const req = requests.find(r => r.id === reqId);
                if (!req) { showToast("Anfrage nicht gefunden"); return; }
                await handleDeleteEvent(req, true);
            };
            
            // Allow request creator to edit their request
            const handleEditRequest = async (req, updates) => {
                if(isDemo) return;
                if (req.createdBy !== user.uid) {
                    showToast("Nur der Ersteller kann diese Anfrage bearbeiten");
                    return;
                }
                try {
                    await db.collection('calendars').doc(req.calendarId).collection('requests').doc(req.id).update(updates);
                    showToast("Anfrage aktualisiert");
                } catch(e) {
                    showToast("Fehler beim Aktualisieren");
                }
            };

            const toggleShiftEnabled = async (calId, enabled) => {
                await db.collection('calendars').doc(calId).update({ shiftEnabled: enabled });
            };

            const addShiftDefinition = async (calId) => {
                if (!newShift.name) return;
                const newDef = { ...newShift, id: Date.now().toString() };
                await db.collection('calendars').doc(calId).update({ 
                    shiftDefinitions: firebase.firestore.FieldValue.arrayUnion(newDef) 
                });
                setNewShift({ name: '', time: '', color: '#10B981' });
            };

            const deleteShiftDefinition = async (calId, shiftId) => {
                const cal = myCalendars.find(c => c.id === calId);
                const updated = (cal.shiftDefinitions || []).filter(s => s.id !== shiftId);
                await db.collection('calendars').doc(calId).update({ shiftDefinitions: updated });
            };

            const assignShift = async (shift) => {
                if (!dragSelection.start) return;
                const datesToUpdate = getDatesInRange(dragSelection.start, dragSelection.end);
                const batch = db.batch();
                const eventRef = db.collection('calendars').doc(activeCalendarId).collection('events');

                datesToUpdate.forEach(d => {
                    const existing = events.find(e => e.type === 'shift' && e.date.toDateString() === d.toDateString() && e.calendarId === activeCalendarId);
                    if (existing) batch.delete(eventRef.doc(existing.id));
                    if (shift) {
                        const newDoc = eventRef.doc();
                        batch.set(newDoc, {
                            type: 'shift', shiftId: shift.id, title: shift.name, date: firebase.firestore.Timestamp.fromDate(d),
                            color: shift.color, createdBy: user.uid, createdAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    }
                });
                await batch.commit();
                setShowShiftSelector(false);
                setDragSelection({ start: null, end: null, isDragging: false });
            };

            // CATEGORY LOGIC
            const saveCategories = async (newCats) => {
                setCategories(newCats);
                if(!isDemo && user) await db.collection('users').doc(user.uid).update({ categories: newCats });
            };
            const addMainCategory = () => { if(newCatName.trim()){ saveCategories({ ...categories, [newCatName.trim()]: [] }); setNewCatName(''); }};
            const addSubCategory = (main) => { if(newSubCatName.trim()){ const n={...categories}; n[main]=[...n[main],newSubCatName.trim()]; saveCategories(n); setNewSubCatName(''); }};
            const deleteMainCategory = (c) => { if(confirm("LÃ¶schen?")){ const n={...categories}; delete n[c]; saveCategories(n); }};
            const deleteSubCategory = (m,s) => { const n={...categories}; n[m]=n[m].filter(x=>x!==s); saveCategories(n); };

            // TODO LOGIC
            const handleCreateTodo = async () => {
                if(isDemo || !newTodo.title.trim()) return;
                let targetId = activeCalendarId === ALL_CALENDARS ? newTodo.targetCalId : activeCalendarId;
                if (!targetId) { showToast("Bitte Kalender wÃ¤hlen"); return; }

                await db.collection('calendars').doc(targetId).collection('todos').add({
                    title: newTodo.title,
                    description: newTodo.description || '',
                    dueDate: newTodo.dueDate ? firebase.firestore.Timestamp.fromDate(new Date(newTodo.dueDate)) : null,
                    assignedTo: newTodo.assignedTo || null,
                    checklist: newTodo.checklist || [],
                    completed: false,
                    createdBy: user.uid,
                    createdByName: user.displayName,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                setShowTodoModal(false);
                setNewTodo({ title: '', description: '', dueDate: '', assignedTo: '', targetCalId: '', checklist: [], completed: false });
                showToast("TODO erstellt");
            };

            const toggleTodoComplete = async (todoId, calId, completed) => {
                if(isDemo) return;
                await db.collection('calendars').doc(calId).collection('todos').doc(todoId).update({ completed: !completed });
            };

            const deleteTodo = async (todoId, calId) => {
                if(!confirm("TODO lÃ¶schen?")) return;
                await db.collection('calendars').doc(calId).collection('todos').doc(todoId).delete();
            };

            const updateTodoChecklist = async (todoId, calId, checklist) => {
                if(isDemo) return;
                await db.collection('calendars').doc(calId).collection('todos').doc(todoId).update({ checklist });
            };

            // AVAILABILITY & MEETING POLLING
            const createAvailabilityProposal = async () => {
                if(isDemo || !availabilityProposal.title.trim() || availabilityProposal.dates.length === 0) {
                    showToast("Titel und Termine erforderlich");
                    return;
                }
                
                let targetId = activeCalendarId === ALL_CALENDARS ? availabilityProposal.targetCalId : activeCalendarId;
                if (!targetId) { showToast("Bitte Kalender wÃ¤hlen"); return; }

                const cal = myCalendars.find(c => c.id === targetId);
                const memberIds = cal?.memberIds || [];

                await db.collection('calendars').doc(targetId).collection('proposals').add({
                    title: availabilityProposal.title,
                    dates: availabilityProposal.dates.map(d => firebase.firestore.Timestamp.fromDate(new Date(d))),
                    votes: {},
                    createdBy: user.uid,
                    createdByName: user.displayName,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    memberIds
                });
                
                setShowAvailabilityModal(false);
                setAvailabilityProposal({ title: '', dates: [], votes: {}, targetCalId: '' });
                showToast("Umfrage erstellt");
            };

            const voteOnProposal = async (proposalId, calId, dateIndex, vote) => {
                if(isDemo) return;
                await db.collection('calendars').doc(calId).collection('proposals').doc(proposalId).update({
                    [`votes.${user.uid}.${dateIndex}`]: vote
                });
            };
            
            // --- NEW FEATURES HANDLERS ---
            
            // Quick Add Handler
            const handleQuickAdd = async () => {
                if (!quickAddInput.trim()) return;
                const parsed = parseQuickAdd(quickAddInput);
                
                // Set the newEvent with parsed data
                const eventDate = parsed.date || selectedDate;
                setSelectedDate(eventDate);
                setNewEvent({
                    ...newEvent,
                    title: parsed.title,
                    time: parsed.time || '12:00',
                    durationMin: parsed.durationMin
                });
                
                // Create event directly if we have everything
                if (parsed.time) {
                    let targetId = activeCalendarId === ALL_CALENDARS ? newEvent.targetCalId : activeCalendarId;
                    if (!targetId) {
                        showToast("Bitte Kalender wÃ¤hlen");
                        setShowAddEventModal(true);
                        return;
                    }
                    
                    const d = new Date(eventDate);
                    const [h, m] = parsed.time.split(':');
                    d.setHours(parseInt(h), parseInt(m));
                    
                    // Check conflicts
                    const conflicts = checkEventConflicts(events.filter(e => e.calendarId === targetId), 
                        { time: parsed.time, durationMin: parsed.durationMin }, eventDate);
                    
                    if (conflicts.length > 0) {
                        const freeSlot = findNextFreeSlot(events.filter(e => e.calendarId === targetId), eventDate, parsed.durationMin);
                        setConflictData({
                            conflicts,
                            suggestedTime: freeSlot ? `${freeSlot.getHours().toString().padStart(2, '0')}:${freeSlot.getMinutes().toString().padStart(2, '0')}` : null,
                            eventData: { ...parsed, date: eventDate, targetId }
                        });
                        setShowConflictModal(true);
                        setQuickAddInput('');
                        return;
                    }
                    
                    await db.collection('calendars').doc(targetId).collection('events').add({
                        title: parsed.title,
                        description: '',
                        date: firebase.firestore.Timestamp.fromDate(d),
                        category: newEvent.category,
                        subCategory: newEvent.subCategory,
                        createdBy: user.uid,
                        createdByName: user.displayName,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                        durationMin: parsed.durationMin,
                        emoji: '',
                        isFocus: false,
                        recurrence: null,
                        recurrenceEndDate: null,
                        recurrenceExceptions: [],
                        reminders: []
                    });
                    showToast("âœ“ Termin erstellt");
                    setQuickAddInput('');
                } else {
                    setShowAddEventModal(true);
                }
            };
            
            // Handle conflict resolution
            const handleConflictResolution = async (useSlot) => {
                if (!conflictData) return;
                const { eventData } = conflictData;
                const d = new Date(eventData.date);
                const time = useSlot ? conflictData.suggestedTime : eventData.time;
                const [h, m] = time.split(':');
                d.setHours(parseInt(h), parseInt(m));
                
                await db.collection('calendars').doc(eventData.targetId).collection('events').add({
                    title: eventData.title,
                    description: '',
                    date: firebase.firestore.Timestamp.fromDate(d),
                    category: newEvent.category,
                    subCategory: newEvent.subCategory,
                    createdBy: user.uid,
                    createdByName: user.displayName,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    durationMin: eventData.durationMin,
                    emoji: '',
                    isFocus: false,
                    recurrence: null,
                    recurrenceEndDate: null,
                    recurrenceExceptions: [],
                    reminders: []
                });
                showToast("âœ“ Termin erstellt");
                setShowConflictModal(false);
                setConflictData(null);
            };
            
            // Habit Handlers
            const createHabit = async (name, emoji = '') => {
                if (!name.trim() || isDemo) return;
                await db.collection('users').doc(user.uid).collection('habits').add({
                    name: name.trim(),
                    emoji,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                showToast("Habit erstellt");
            };
            
            const deleteHabit = async (habitId) => {
                if (!confirm("Habit lÃ¶schen?") || isDemo) return;
                await db.collection('users').doc(user.uid).collection('habits').doc(habitId).delete();
                // Also delete all logs
                const logs = await db.collection('users').doc(user.uid).collection('habitLogs')
                    .where('habitId', '==', habitId).get();
                const batch = db.batch();
                logs.docs.forEach(doc => batch.delete(doc.ref));
                await batch.commit();
            };
            
            const logHabit = async (habitId, date = new Date()) => {
                if (isDemo) return;
                const dateStr = date.toISOString().split('T')[0];
                const existing = habitLogs.find(l => l.habitId === habitId && l.date?.toDateString() === date.toDateString());
                
                if (existing) {
                    await db.collection('users').doc(user.uid).collection('habitLogs').doc(existing.id).delete();
                    showToast("âœ“ Entfernt");
                } else {
                    await db.collection('users').doc(user.uid).collection('habitLogs').add({
                        habitId,
                        date: firebase.firestore.Timestamp.fromDate(date),
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    showToast("âœ“ Erledigt");
                }
            };
            
            // Template Handlers
            const applyTemplate = async (template, startDate) => {
                if (isDemo) return;
                let targetId = activeCalendarId === ALL_CALENDARS ? newEvent.targetCalId : activeCalendarId;
                if (!targetId) {
                    showToast("Bitte Kalender wÃ¤hlen");
                    return;
                }
                
                const batch = db.batch();
                const eventRef = db.collection('calendars').doc(targetId).collection('events');
                
                template.events.forEach(tEvent => {
                    const eventDate = new Date(startDate);
                    eventDate.setDate(startDate.getDate() + tEvent.dayOffset);
                    const [h, m] = tEvent.time.split(':');
                    eventDate.setHours(parseInt(h), parseInt(m));
                    
                    const newDoc = eventRef.doc();
                    batch.set(newDoc, {
                        title: tEvent.title,
                        description: '',
                        date: firebase.firestore.Timestamp.fromDate(eventDate),
                        category: tEvent.category,
                        subCategory: tEvent.subCategory,
                        createdBy: user.uid,
                        createdByName: user.displayName,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                        durationMin: tEvent.durationMin || 60,
                        emoji: tEvent.emoji || '',
                        isFocus: tEvent.isFocus || false,
                        recurrence: null,
                        recurrenceEndDate: null,
                        recurrenceExceptions: [],
                        reminders: []
                    });
                });
                
                await batch.commit();
                showToast(`âœ“ Template "${template.name}" angewendet`);
            };
            
            const copyDaySchedule = async (sourceDate, targetDate) => {
                if (isDemo) return;
                let targetId = activeCalendarId === ALL_CALENDARS ? newEvent.targetCalId : activeCalendarId;
                if (!targetId) {
                    showToast("Bitte Kalender wÃ¤hlen");
                    return;
                }
                
                const sourceEvents = events.filter(e => {
                    if (e.calendarId !== targetId) return false;
                    const evDate = e.date instanceof Date ? e.date : (e.date?.toDate ? e.date.toDate() : new Date(e.date));
                    return evDate.toDateString() === sourceDate.toDateString() && e.type !== 'shift';
                });
                
                if (sourceEvents.length === 0) {
                    showToast("Keine Events an diesem Tag");
                    return;
                }
                
                const batch = db.batch();
                const eventRef = db.collection('calendars').doc(targetId).collection('events');
                
                sourceEvents.forEach(ev => {
                    const evDate = ev.date instanceof Date ? new Date(ev.date) : new Date(ev.date.toDate());
                    const newDate = new Date(targetDate);
                    newDate.setHours(evDate.getHours(), evDate.getMinutes());
                    
                    const newDoc = eventRef.doc();
                    batch.set(newDoc, {
                        title: ev.title,
                        description: ev.description || '',
                        date: firebase.firestore.Timestamp.fromDate(newDate),
                        category: ev.category,
                        subCategory: ev.subCategory,
                        createdBy: user.uid,
                        createdByName: user.displayName,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                        durationMin: ev.durationMin || 60,
                        emoji: ev.emoji || '',
                        isFocus: ev.isFocus || false,
                        recurrence: null,
                        recurrenceEndDate: null,
                        recurrenceExceptions: [],
                        reminders: []
                    });
                });
                
                await batch.commit();
                showToast(`âœ“ ${sourceEvents.length} Events kopiert`);
            };
            
            // Drag & Drop Handlers
            const handleEventDragStart = (e, event) => {
                if (!e || !e.dataTransfer || !event) return;
                try {
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('eventId', event.id || '');
                    e.dataTransfer.setData('calendarId', event.calendarId || '');
                } catch (err) {
                    console.error('Drag start error:', err);
                }
            };
            
            const handleDayDrop = async (e, targetDate) => {
                if (!e || !e.dataTransfer) return;
                e.preventDefault();
                
                try {
                    const eventId = e.dataTransfer.getData('eventId');
                    const calendarId = e.dataTransfer.getData('calendarId');
                    
                    if (!eventId || !calendarId || isDemo) return;
                    
                    const event = events.find(ev => ev && ev.id === eventId && ev.calendarId === calendarId);
                    if (!event || event.type === 'shift' || !event.date) return;
                    
                    const oldDate = event.date instanceof Date ? event.date : event.date.toDate();
                    const newDate = new Date(targetDate);
                    if (isNaN(newDate.getTime()) || isNaN(oldDate.getTime())) return;
                    
                    newDate.setHours(oldDate.getHours(), oldDate.getMinutes());
                    
                    // Check conflicts
                    const conflicts = checkEventConflicts(events.filter(e => e && e.calendarId === calendarId), 
                        { time: `${oldDate.getHours().toString().padStart(2, '0')}:${oldDate.getMinutes().toString().padStart(2, '0')}`, 
                          durationMin: event.durationMin || 60 }, 
                        newDate, eventId);
                    
                    if (conflicts.length > 0) {
                        showToast(`âš ï¸ Konflikt! ${conflicts.length} Ã¼berlappende Events`);
                        return;
                    }
                    
                    if (!db) {
                        showToast('Datenbank nicht verfÃ¼gbar');
                        return;
                    }
                    
                    await db.collection('calendars').doc(calendarId).collection('events').doc(eventId).update({
                        date: firebase.firestore.Timestamp.fromDate(newDate)
                    });
                    showToast("âœ“ Verschoben");
                } catch (err) {
                    console.error('Drop error:', err);
                    showToast('Fehler beim Verschieben des Termins');
                }
            };
            
            // Multi-Select Handlers
            const toggleEventSelection = (eventId) => {
                setSelectedEventIds(prev => 
                    prev.includes(eventId) ? prev.filter(id => id !== eventId) : [...prev, eventId]
                );
            };
            
            const batchDeleteEvents = async () => {
                if (selectedEventIds.length === 0 || isDemo) return;
                if (!confirm(`${selectedEventIds.length} Events lÃ¶schen?`)) return;
                
                const batch = db.batch();
                selectedEventIds.forEach(eventId => {
                    const event = events.find(e => e.id === eventId);
                    if (event && event.type !== 'shift') {
                        batch.delete(db.collection('calendars').doc(event.calendarId).collection('events').doc(eventId));
                    }
                });
                
                await batch.commit();
                setSelectedEventIds([]);
                setMultiSelectMode(false);
                showToast(`âœ“ ${selectedEventIds.length} Events gelÃ¶scht`);
            };
            
            const batchMoveEvents = async (targetDate) => {
                if (selectedEventIds.length === 0 || isDemo) return;
                
                const batch = db.batch();
                selectedEventIds.forEach(eventId => {
                    const event = events.find(e => e.id === eventId);
                    if (event && event.type !== 'shift') {
                        const oldDate = event.date instanceof Date ? event.date : event.date.toDate();
                        const newDate = new Date(targetDate);
                        newDate.setHours(oldDate.getHours(), oldDate.getMinutes());
                        batch.update(
                            db.collection('calendars').doc(event.calendarId).collection('events').doc(eventId),
                            { date: firebase.firestore.Timestamp.fromDate(newDate) }
                        );
                    }
                });
                
                await batch.commit();
                setSelectedEventIds([]);
                setMultiSelectMode(false);
                showToast(`âœ“ ${selectedEventIds.length} Events verschoben`);
            };

            // RECURRENCE HELPER
            const getRecurringEvents = (event, targetDate) => {
                if (!event.recurrence) return [];
                
                const results = [];
                const eventDate = event.date;
                const endDate = event.recurrenceEndDate ? event.recurrenceEndDate.toDate() : new Date(MAX_RECURRENCE_YEAR, 11, 31);
                const exceptions = event.recurrenceExceptions || [];
                
                const targetMonth = targetDate.getMonth();
                const targetYear = targetDate.getFullYear();
                
                // For yearly recurrence, check if target date is valid
                if (event.recurrence === 'yearly') {
                    if (eventDate.getDate() === targetDate.getDate() && eventDate.getMonth() === targetDate.getMonth()) {
                        const yearlyDate = new Date(targetYear, targetDate.getMonth(), targetDate.getDate());
                        if (yearlyDate >= eventDate && yearlyDate <= endDate) {
                            const dateStr = yearlyDate.toDateString();
                            if (!exceptions.includes(dateStr)) {
                                results.push({ ...event, date: new Date(yearlyDate), isRecurrence: true });
                            }
                        }
                    }
                    return results;
                }
                
                // For other recurrences, optimize by starting from first day of target month
                const monthStart = new Date(targetYear, targetMonth, 1);
                const monthEnd = new Date(targetYear, targetMonth + 1, 0);
                
                // Calculate the first occurrence in or before the target month
                let currentDate = new Date(eventDate);
                const interval = {
                    'daily': 1,
                    'weekly': 7,
                    'biweekly': 14,
                    'monthly': 0 // handled separately
                }[event.recurrence] || 1;
                
                if (event.recurrence === 'monthly') {
                    // Jump to the month - handle dates that don't exist in target month
                    const targetDay = Math.min(eventDate.getDate(), new Date(monthStart.getFullYear(), monthStart.getMonth() + 1, 0).getDate());
                    currentDate = new Date(monthStart.getFullYear(), monthStart.getMonth(), targetDay);
                    if (currentDate < monthStart) currentDate.setMonth(currentDate.getMonth() + 1);
                    
                    while (currentDate <= Math.min(monthEnd, endDate)) {
                        if (currentDate >= eventDate) {
                            const dateStr = currentDate.toDateString();
                            if (!exceptions.includes(dateStr)) {
                                results.push({ ...event, date: new Date(currentDate), isRecurrence: true });
                            }
                        }
                        // Handle next month, ensuring valid day
                        const nextMonth = currentDate.getMonth() + 1;
                        const nextYear = currentDate.getFullYear() + Math.floor(nextMonth / 12);
                        const adjustedMonth = nextMonth % 12;
                        const maxDay = new Date(nextYear, adjustedMonth + 1, 0).getDate();
                        const nextDay = Math.min(eventDate.getDate(), maxDay);
                        currentDate = new Date(nextYear, adjustedMonth, nextDay);
                    }
                } else {
                    // For daily, weekly, biweekly
                    // Fast-forward to near the target month using milliseconds
                    if (currentDate < monthStart) {
                        const daysDiff = Math.floor((monthStart - currentDate) / MS_PER_DAY);
                        const steps = Math.floor(daysDiff / interval);
                        currentDate = new Date(currentDate.getTime() + steps * interval * MS_PER_DAY);
                    }
                    
                    // Now iterate through the target month
                    while (currentDate <= Math.min(monthEnd, endDate)) {
                        if (currentDate >= monthStart && currentDate >= eventDate) {
                            const dateStr = currentDate.toDateString();
                            if (!exceptions.includes(dateStr)) {
                                results.push({ ...event, date: new Date(currentDate), isRecurrence: true });
                            }
                        }
                        currentDate = new Date(currentDate.getTime() + interval * MS_PER_DAY);
                    }
                }
                
                return results;
            };

            // EXPORT FUNCTIONS
            const escapeICSText = (text) => {
                if (!text) return '';
                return text.replace(/\\/g, '\\\\')
                          .replace(/;/g, '\\;')
                          .replace(/,/g, '\\,')
                          .replace(/\n/g, '\\n');
            };

            const exportToICS = (events) => {
                try {
                    if (!events || !Array.isArray(events) || events.length === 0) {
                        showToast("Keine Events zum Exportieren");
                        return;
                    }
                    
                    let icsContent = 'BEGIN:VCALENDAR\nVERSION:2.0\nPRODID:-//Kalender V Beta//DE\nCALSCALE:GREGORIAN\n';
                    
                    events.forEach(event => {
                        if (!event || !event.date || !event.id) return;
                        
                        try {
                            const eventDate = event.date instanceof Date ? event.date : event.date.toDate();
                            const durationMs = (event.durationMin || 60) * 60000;
                            
                            const dtstart = eventDate.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z';
                            const dtend = new Date(eventDate.getTime() + durationMs).toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z';
                            const dtstamp = new Date().toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z';
                            
                            icsContent += 'BEGIN:VEVENT\n';
                            icsContent += `UID:${event.id}@kalender.de\n`;
                            icsContent += `DTSTAMP:${dtstamp}\n`;
                            icsContent += `DTSTART:${dtstart}\n`;
                            icsContent += `DTEND:${dtend}\n`;
                            icsContent += `SUMMARY:${escapeICSText(event.title || 'Kein Titel')}\n`;
                            if (event.description) icsContent += `DESCRIPTION:${escapeICSText(event.description)}\n`;
                            if (event.recurrence) {
                                const rrule = {
                                    'daily': 'FREQ=DAILY',
                                    'weekly': 'FREQ=WEEKLY',
                                    'biweekly': 'FREQ=WEEKLY;INTERVAL=2',
                                    'monthly': 'FREQ=MONTHLY',
                                    'yearly': 'FREQ=YEARLY'
                                }[event.recurrence];
                                if (rrule) {
                                    icsContent += `RRULE:${rrule}`;
                                    if (event.recurrenceEndDate) {
                                        const endDate = event.recurrenceEndDate.toDate ? event.recurrenceEndDate.toDate() : event.recurrenceEndDate;
                                        const until = endDate.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z';
                                        icsContent += `;UNTIL=${until}`;
                                    }
                                    icsContent += '\n';
                                }
                            }
                            icsContent += 'END:VEVENT\n';
                        } catch (eventErr) {
                            console.error('Error exporting event:', event.id, eventErr);
                        }
                    });
                    
                    icsContent += 'END:VCALENDAR';
                    
                    const blob = new Blob([icsContent], { type: 'text/calendar;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `kalender_${new Date().toISOString().split('T')[0]}.ics`;
                    link.click();
                    URL.revokeObjectURL(url);
                    showToast("ICS Export erfolgreich");
                } catch (err) {
                    console.error('ICS export error:', err);
                    showToast('Fehler beim ICS Export');
                }
            };

            const exportShiftsToPDF = async () => {
                if (activeCalendarId === ALL_CALENDARS) {
                    showToast("Bitte einen Kalender wÃ¤hlen");
                    return;
                }
                
                // Simple HTML-to-Print approach for PDF
                const cal = myCalendars.find(c => c.id === activeCalendarId);
                const shiftEvents = events.filter(e => e.type === 'shift' && e.calendarId === activeCalendarId);
                
                const printWindow = window.open('', '_blank');
                let html = `
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <title>Schichtplan - ${cal?.name}</title>
                        <style>
                            body { font-family: Arial, sans-serif; padding: 20px; }
                            h1 { text-align: center; }
                            table { width: 100%; border-collapse: collapse; margin-top: 20px; }
                            th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
                            th { background-color: #f2f2f2; }
                            @media print { button { display: none; } }
                        </style>
                    </head>
                    <body>
                        <h1>Schichtplan: ${cal?.name}</h1>
                        <p>Monat: ${currentDate.toLocaleString('de-DE', { month: 'long', year: 'numeric' })}</p>
                        <table>
                            <thead>
                                <tr><th>Datum</th><th>Schicht</th><th>Zeit</th></tr>
                            </thead>
                            <tbody>
                `;
                
                shiftEvents
                    .filter(e => e.date.getMonth() === currentDate.getMonth() && e.date.getFullYear() === currentDate.getFullYear())
                    .sort((a, b) => a.date - b.date)
                    .forEach(e => {
                        const shift = cal?.shiftDefinitions?.find(s => s.id === e.shiftId);
                        html += `<tr><td>${e.date.toLocaleDateString('de-DE')}</td><td>${e.title}</td><td>${shift?.time || ''}</td></tr>`;
                    });
                
                html += `
                            </tbody>
                        </table>
                        <button onclick="window.print()">Drucken / Als PDF speichern</button>
                    </body>
                    </html>
                `;
                
                printWindow.document.write(html);
                printWindow.document.close();
                showToast("PDF-Export geÃ¶ffnet");
            };

            // BACKUP/RESTORE FUNCTIONS
            const exportBackup = async () => {
                if(isDemo) {
                    showToast("Nicht im Demo-Modus verfÃ¼gbar");
                    return;
                }
                
                try {
                    const backup = {
                        version: '1.0',
                        exportDate: new Date().toISOString(),
                        user: {
                            uid: user.uid,
                            displayName: user.displayName,
                            email: user.email
                        },
                        categories: categories,
                        calendars: myCalendars.map(cal => ({
                            ...cal,
                            // Remove Firestore-specific fields
                            id: cal.id,
                            name: cal.name,
                            color: cal.color,
                            memberIds: cal.memberIds,
                            shiftEnabled: cal.shiftEnabled,
                            shiftDefinitions: cal.shiftDefinitions
                        })),
                        events: events.map(e => ({
                            ...e,
                            date: e.date.toISOString(),
                            createdAt: e.createdAt?.toDate?.()?.toISOString?.() || null,
                            recurrenceEndDate: e.recurrenceEndDate?.toDate?.()?.toISOString?.() || null
                        })),
                        todos: todos.map(t => ({
                            ...t,
                            dueDate: t.dueDate ? new Date(t.dueDate).toISOString() : null,
                            createdAt: t.createdAt?.toDate?.()?.toISOString?.() || null
                        })),
                        proposals: proposals.map(p => ({
                            ...p,
                            dates: p.dates.map(d => new Date(d).toISOString()),
                            createdAt: p.createdAt?.toDate?.()?.toISOString?.() || null
                        }))
                    };
                    
                    const dataStr = JSON.stringify(backup, null, 2);
                    const blob = new Blob([dataStr], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `kalender_backup_${new Date().toISOString().split('T')[0]}.json`;
                    link.click();
                    URL.revokeObjectURL(url);
                    showToast("Backup erfolgreich exportiert");
                } catch (e) {
                    console.error('Backup error:', e);
                    showToast("Backup fehlgeschlagen");
                }
            };

            const importBackup = async (file) => {
                if(isDemo) {
                    showToast("Nicht im Demo-Modus verfÃ¼gbar");
                    return;
                }
                
                try {
                    const text = await file.text();
                    const backup = JSON.parse(text);
                    
                    if (!backup.version || !backup.categories) {
                        showToast("UngÃ¼ltiges Backup-Format");
                        return;
                    }
                    
                    if (!confirm("Backup importieren? Dies Ã¼berschreibt Ihre aktuellen Kategorien!")) {
                        return;
                    }
                    
                    // Update categories
                    setCategories(backup.categories);
                    await db.collection('users').doc(user.uid).update({ categories: backup.categories });
                    
                    showToast("Backup erfolgreich importiert");
                    setShowBackupModal(false);
                } catch (e) {
                    console.error('Import error:', e);
                    showToast("Import fehlgeschlagen: " + e.message);
                }
            };

            // SEARCH FUNCTION
            const searchResults = useMemo(() => {
                if (!searchQuery.trim()) return { events: [], todos: [] };
                
                const query = searchQuery.toLowerCase();
                const matchedEvents = events.filter(e => 
                    e.title?.toLowerCase().includes(query) ||
                    e.description?.toLowerCase().includes(query) ||
                    e.category?.toLowerCase().includes(query) ||
                    e.createdByName?.toLowerCase().includes(query)
                );
                
                const matchedTodos = todos.filter(t =>
                    t.title?.toLowerCase().includes(query) ||
                    t.description?.toLowerCase().includes(query)
                );
                
                return { events: matchedEvents, todos: matchedTodos };
            }, [searchQuery, events, todos]);

            // RENDER
            const filteredEvents = useMemo(() => {
                let result = [];
                
                // Include regular events
                events.forEach(e => {
                    if(!e.date) return;
                    if (activeCalendarId !== ALL_CALENDARS && e.calendarId && e.calendarId !== activeCalendarId) return;
                    
                    const isSameDate = e.date.toDateString() === selectedDate.toDateString();
                    
                    if (isSameDate) {
                        result.push(e);
                    } else if (e.recurrence) {
                        // getRecurringEvents already filters by target date
                        const recurring = getRecurringEvents(e, selectedDate);
                        result.push(...recurring);
                    }
                });
                
                // Include requests for the selected date
                requests.forEach(req => {
                    if(!req.date) return;
                    if (activeCalendarId !== ALL_CALENDARS && req.calendarId && req.calendarId !== activeCalendarId) return;
                    
                    const isSameDate = req.date.toDateString() === selectedDate.toDateString();
                    if (isSameDate) {
                        result.push(req);
                    }
                });
                
                return result.sort((a,b) => (a.time || "00:00").localeCompare(b.time || "00:00"));
            }, [events, requests, activeCalendarId, selectedDate]);

            const filteredTodos = useMemo(() => {
                return todos.filter(t => {
                    if (activeCalendarId !== ALL_CALENDARS && t.calendarId !== activeCalendarId) return false;
                    return true;
                }).sort((a, b) => {
                    if (a.completed !== b.completed) return a.completed ? 1 : -1;
                    if (a.dueDate && b.dueDate) return a.dueDate - b.dueDate;
                    if (a.dueDate) return -1;
                    if (b.dueDate) return 1;
                    return 0;
                });
            }, [todos, activeCalendarId]);
            
            // Focus Stats
            const focusStats = useMemo(() => {
                const today = new Date();
                const todayStr = today.toDateString();
                const weekStart = new Date(today);
                weekStart.setDate(today.getDate() - today.getDay());
                
                let todayMinutes = 0;
                let weekMinutes = 0;
                
                events.forEach(ev => {
                    if (!ev.isFocus) return;
                    const evDate = ev.date instanceof Date ? ev.date : (ev.date?.toDate ? ev.date.toDate() : new Date(ev.date));
                    
                    if (evDate.toDateString() === todayStr) {
                        todayMinutes += (ev.durationMin || 60);
                    }
                    if (evDate >= weekStart) {
                        weekMinutes += (ev.durationMin || 60);
                    }
                });
                
                return { todayMinutes, weekMinutes };
            }, [events]);
            
            // Habit Streaks
            const habitStreaks = useMemo(() => {
                const streaks = {};
                habits.forEach(habit => {
                    const logs = habitLogs.filter(l => l.habitId === habit.id)
                        .sort((a, b) => {
                            const aDate = a.date instanceof Date ? a.date : a.date.toDate();
                            const bDate = b.date instanceof Date ? b.date : b.date.toDate();
                            return bDate - aDate;
                        });
                    
                    let streak = 0;
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    
                    for (let i = 0; i < logs.length; i++) {
                        const logDate = logs[i].date instanceof Date ? new Date(logs[i].date) : new Date(logs[i].date.toDate());
                        logDate.setHours(0, 0, 0, 0);
                        const expectedDate = new Date(today);
                        expectedDate.setDate(today.getDate() - streak);
                        
                        if (logDate.getTime() === expectedDate.getTime()) {
                            streak++;
                        } else {
                            break;
                        }
                    }
                    
                    streaks[habit.id] = streak;
                });
                return streaks;
            }, [habits, habitLogs]);

            const activeCalName = activeCalendarId === ALL_CALENDARS ? "Alle Kalender" : myCalendars.find(c => c.id === activeCalendarId)?.name;
            const filteredSettingsCalendars = myCalendars.filter(c => c.name.toLowerCase().includes(calendarSearchTerm.toLowerCase()));

            if (!user && !isDemo) return <AuthScreen onLoginSuccess={()=>{}} onDemoStart={()=>{setIsDemo(true); setActiveCalendarId('demo');}} />;

            return (
                <div className="min-h-screen flex flex-col items-center p-4 pb-32 md:p-8 font-sans max-w-lg mx-auto select-none">

                    {permGateOpen && (
                        <div className="fixed inset-0 z-[300] bg-black/40 flex items-end md:items-center justify-center p-4 fade-in">
                            <div className="w-full max-w-md bg-[#ffffff] dark:bg-[#0f0f0f] rounded-[32px] p-6 shadow-2xl slide-up">
                                <div className="text-lg font-bold dark:text-white">Berechtigungen</div>
                                <div className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                                    FÃ¼r Kamera, Mikrofon und lokalen Speicher.
                                </div>

                                <div className="mt-4 space-y-2 text-sm">
                                    <div className="flex items-center justify-between">
                                        <div className="font-bold dark:text-white">Kamera</div>
                                        <div className="text-gray-500 dark:text-gray-300">{permInfo.cam}</div>
                                    </div>
                                    <div className="flex items-center justify-between">
                                        <div className="font-bold dark:text-white">Mikrofon</div>
                                        <div className="text-gray-500 dark:text-gray-300">{permInfo.mic}</div>
                                    </div>
                                    <div className="flex items-center justify-between">
                                        <div className="font-bold dark:text-white">Speicher</div>
                                        <div className="text-gray-500 dark:text-gray-300">{permInfo.store}</div>
                                    </div>
                                </div>

                                <div className="mt-5 flex gap-2">
                                    <button
                                        disabled={permGateBusy}
                                        onClick={requestStartupPerms}
                                        className="flex-1 p-3 rounded-2xl bg-black text-white dark:bg-white dark:text-black shadow-sm font-bold disabled:opacity-50"
                                    >
                                        {permGateBusy ? 'PrÃ¼feâ€¦' : 'Aktivieren'}
                                    </button>
                                    <button
                                        onClick={() => setPermGateOpen(false)}
                                        className="p-3 rounded-2xl bg-gray-100 dark:bg-[#1a1a1a] dark:text-[#e8ecf5] shadow-sm font-bold"
                                    >
                                        SpÃ¤ter
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}


                    
                    {/* Header */}
                    <div className="w-full flex justify-between items-center mb-6 z-10 relative">
                        <div className="relative">
                            <div onClick={() => setShowCalendarSwitcher(!showCalendarSwitcher)} className="cursor-pointer flex items-center gap-2">
                                <h1 className="text-2xl font-bold tracking-tight dark:text-[#e8ecf5] truncate max-w-[200px]">{activeCalName || 'Lade...'}</h1>
                                <Icon name="chevronDown" size={18} className="text-gray-400"/>
                            </div>
                            {showCalendarSwitcher && (
                                <div className="absolute top-10 left-0 bg-[#ffffff] dark:bg-[#0f0f0f] rounded-2xl shadow-xl border border-[#e2e8f0] dark:border-[#1f1f1f] p-2 w-56 z-20 slide-up">
                                    <button onClick={()=>{setActiveCalendarId(ALL_CALENDARS); setShowCalendarSwitcher(false);}} className={`w-full text-left px-4 py-3 rounded-xl flex items-center gap-3 ${activeCalendarId===ALL_CALENDARS ? 'bg-[#2563eb] text-white dark:bg-[#4da3ff] dark:text-black' : 'hover:bg-gray-50 dark:hover:bg-[#1a1a1a] dark:text-[#e8ecf5]'}`}>
                                        <Icon name="layers" size={16}/> <span className="font-bold text-sm">Alle Kalender</span>
                                    </button>
                                    <div className="h-px bg-gray-100 dark:bg-gray-800 my-1"></div>
                                    {myCalendars.map(cal => (
                                        <button key={cal.id} onClick={()=>{setActiveCalendarId(cal.id); setShowCalendarSwitcher(false);}} className={`w-full text-left px-4 py-2.5 rounded-xl flex items-center gap-3 ${activeCalendarId===cal.id ? 'bg-gray-100 dark:bg-[#1a1a1a] font-bold' : 'hover:bg-gray-50 dark:hover:bg-[#2D2D2D]'} dark:text-gray-200`}>
                                            <div className={`w-2 h-2 rounded-full ${CALENDAR_COLORS.find(c=>c.hex===cal.color)?.bg}`}/>
                                            <span className="text-sm truncate">{cal.name}</span>
                                        </button>
                                    ))}
                                </div>
                            )}
                        </div>
                        <div className="flex gap-2">
                            <button onClick={() => setCurrentDate(new Date())} className={`px-3 bg-white dark:bg-[#0f0f0f] rounded-2xl shadow-sm font-bold text-xs uppercase dark:text-[#e8ecf5] ${todayBlinkToken ? "blink-attn" : ""}`}>Heute</button>
                            <button onClick={() => setShowSearchPanel(true)} className="p-3 bg-[#ffffff] dark:bg-[#0f0f0f] dark:text-[#e8ecf5] rounded-2xl shadow-sm" title="Suchen"><Icon name="search"/></button>
                            <button onClick={() => setCalendarView(calendarView === 'month' ? 'week' : 'month')} className="p-3 bg-[#ffffff] dark:bg-[#0f0f0f] dark:text-[#e8ecf5] rounded-2xl shadow-sm" title={calendarView === 'month' ? 'Wochenansicht' : 'Monatsansicht'}><Icon name={calendarView === 'month' ? 'calendar' : 'grid'}/></button>
                            <button onClick={() => setShowSettingsModal(true)} className="p-3 bg-[#ffffff] dark:bg-[#0f0f0f] dark:text-[#e8ecf5] rounded-2xl shadow-sm"><Icon name="settings"/></button>
                        </div>
                    </div>

                    {/* Calendar Grid */}
                    <div 
                        className="w-full bg-[#ffffff] dark:bg-[#0f0f0f] rounded-[32px] p-6 shadow-xl shadow-gray-100 dark:shadow-none mb-6 slide-up transition-colors relative overflow-hidden" 
                        style={{touchAction: 'none'}} 
                        onTouchMove={handleTouchMove}
                    >
                        <div className="flex justify-between items-center mb-6 dark:text-white">
                            <button
                                onClick={() => setCurrentDate(prev => { 
                                    const d = new Date(prev); 
                                    if (calendarView === 'week') {
                                        d.setDate(d.getDate() - 7);
                                    } else {
                                        d.setMonth(d.getMonth() - 1, 1);
                                    }
                                    return d; 
                                })}
                                className="p-2 hover:bg-gray-50 dark:hover:bg-[#2D2D2D] rounded-full"
                            >
                                <Icon name="chevronLeft" />
                            </button>
                            <span className="font-bold text-lg">
                                {calendarView === 'week' 
                                    ? `Woche ${Math.ceil((currentDate.getDate() + (new Date(currentDate.getFullYear(), currentDate.getMonth(), 1).getDay() || 7) - 1) / 7)} â€¢ ${currentDate.toLocaleString('de-DE', { month: 'long', year: 'numeric' })}`
                                    : currentDate.toLocaleString('de-DE', { month: 'long', year: 'numeric' })
                                }
                            </span>
                            <button
                                onClick={() => setCurrentDate(prev => { 
                                    const d = new Date(prev); 
                                    if (calendarView === 'week') {
                                        d.setDate(d.getDate() + 7);
                                    } else {
                                        d.setMonth(d.getMonth() + 1, 1);
                                    }
                                    return d; 
                                })}
                                className="p-2 hover:bg-gray-50 dark:hover:bg-[#2D2D2D] rounded-full"
                            >
                                <Icon name="chevronRight" />
                            </button>
                        </div>
                        <div className="grid grid-cols-7 mb-2 text-center text-[10px] font-bold text-gray-400 uppercase">
                            {['Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa', 'So'].map(d => <div key={d}>{d}</div>)}
                        </div>
                        
                        {calendarView === 'month' ? (
                            /* Month View */
                            <div className="grid grid-cols-7 gap-y-2">
                                {(() => {
                                    const y = currentDate.getFullYear(), m = currentDate.getMonth();
                                    const todayStr = (new Date()).toDateString();
                                    const days = new Date(y, m + 1, 0).getDate();
                                    const off = (new Date(y, m, 1).getDay() || 7) - 1;
                                    const cells = Array(off).fill(null).map((_, i) => <div key={`e-${i}`} />);
                                    for (let i = 1; i <= days; i++) {
                                        const d = new Date(y, m, i);
                                        const isSel = d.toDateString() === selectedDate.toDateString();
                                        const isToday = d.toDateString() === todayStr;
                                        const dow = d.getDay();
                                        
                                        // Secret chat notification indicator on today
                                        const hasNewSecretMessage = isToday && todayBlinkToken;
                                        
                                        // Shift Check
                                        const shiftEvent = events.find(e => e.type === 'shift' && e.date && e.date.toDateString() === d.toDateString() && (activeCalendarId === ALL_CALENDARS || e.calendarId === activeCalendarId));
                                        
                                        // Selection Range Check
                                        const inDrag = isInSelection(d);

                                        // Dot Check
                                        const hasEvent = events.some(e => {
                                            if (e.type === 'shift') return false;
                                            if (e.recurrence === 'yearly') return e.date.getDate()===i && e.date.getMonth()===m;
                                            return e.date && e.date.toDateString() === d.toDateString();
                                        });
                                        let dotColor = 'bg-gray-400';
                                        if (hasEvent && activeCalendarId !== ALL_CALENDARS) {
                                            const cal = myCalendars.find(c => c.id === activeCalendarId);
                                            dotColor = CALENDAR_COLORS.find(c => c.hex === cal?.color)?.bg || 'bg-black';
                                        } else if (hasEvent) { dotColor = 'bg-black dark:bg-white'; }

                                        const cellStyle = shiftEvent ? { backgroundColor: shiftEvent.color + '60', color: 'inherit' } : {};
                                        const dragStyle = inDrag ? { backgroundColor: '#E5E7EB', color: 'black' } : {}; 
                                        const weekendStyle = (!shiftEvent && (dow === 0 || dow === 6)) ? { backgroundColor: 'rgba(232, 240, 255, 0.7)' } : {};
                                        const todayStyle = (!shiftEvent && isToday) ? { boxShadow: '0 0 0 2px rgba(255, 214, 102, 0.55)', backgroundColor: 'rgba(255, 249, 230, 0.9)' } : {};

                                        cells.push(
                                            <div key={i} className="aspect-square flex justify-center items-center">
                                                <button 
                                                    data-date={d.toISOString()}
                                                    onMouseDown={() => handlePointerDown(d)}
                                                    onMouseEnter={() => handlePointerEnter(d)}
                                                    onTouchStart={() => handlePointerDown(d)}
                                                    style={{...cellStyle, ...dragStyle, ...weekendStyle, ...todayStyle, ...(shiftEvent ? {backgroundColor: shiftEvent.color} : {}) }}
                                                    className={`w-10 h-10 rounded-2xl flex flex-col items-center justify-center transition-all relative ${(isToday && todayBlinkToken) ? 'blink-attn' : ''} ${isSel && !shiftEvent && !inDrag ? 'bg-black text-white dark:bg-white dark:text-black shadow-lg' : 'hover:bg-gray-50 dark:hover:bg-[#2D2D2D] dark:text-white'}`}
                                                >
                                                    <span className={`text-sm font-medium relative z-10 ${shiftEvent ? 'text-white' : ''}`}>{i}</span>
                                                    {hasNewSecretMessage && !shiftEvent && (
                                                        <div className="absolute top-1 right-1 w-2 h-2 bg-green-500 rounded-full animate-pulse shadow-lg" />
                                                    )}
                                                    {!shiftEvent && <div className={`w-1 h-1 rounded-full mt-0.5 ${isSel ? 'bg-white dark:bg-black' : (hasEvent ? dotColor : 'bg-transparent')}`} />}
                                                </button>
                                            </div>
                                        );
                                    }
                                    return cells;
                                })()}
                            </div>
                        ) : (
                            /* Week View */
                            <div className="space-y-2">
                                {(() => {
                                    const today = new Date();
                                    const currentDayOfWeek = currentDate.getDay() || 7; // Sunday = 7
                                    const startOfWeek = new Date(currentDate);
                                    startOfWeek.setDate(currentDate.getDate() - (currentDayOfWeek - 1));
                                    
                                    const weekDays = [];
                                    for (let i = 0; i < 7; i++) {
                                        const d = new Date(startOfWeek);
                                        d.setDate(startOfWeek.getDate() + i);
                                        
                                        const isToday = d.toDateString() === today.toDateString();
                                        const isSel = d.toDateString() === selectedDate.toDateString();
                                        
                                        const dayEvents = events.filter(e => {
                                            if (e.type === 'shift') return false;
                                            return e.date && e.date.toDateString() === d.toDateString();
                                        });
                                        
                                        weekDays.push(
                                            <div 
                                                key={i} 
                                                className={`bg-white dark:bg-[#1a1a1a] rounded-2xl p-4 cursor-pointer transition-all drop-zone ${isSel ? 'ring-2 ring-black dark:ring-white' : ''} ${isToday ? 'border-2 border-yellow-400' : ''}`} 
                                                onClick={() => setSelectedDate(d)}
                                                onDragOver={(e) => {
                                                    e.preventDefault();
                                                    e.currentTarget.classList.add('drag-over');
                                                }}
                                                onDragLeave={(e) => {
                                                    e.currentTarget.classList.remove('drag-over');
                                                }}
                                                onDrop={(e) => {
                                                    e.currentTarget.classList.remove('drag-over');
                                                    handleDayDrop(e, d);
                                                }}
                                            >
                                                <div className="flex items-center justify-between mb-3">
                                                    <div>
                                                        <div className="text-xs text-gray-400 uppercase font-bold">{d.toLocaleDateString('de-DE', { weekday: 'short' })}</div>
                                                        <div className={`text-2xl font-bold ${isToday ? 'text-yellow-600 dark:text-yellow-400' : 'dark:text-white'}`}>{d.getDate()}</div>
                                                    </div>
                                                    <div className="text-xs text-gray-400">
                                                        {dayEvents.length > 0 && <span className="px-2 py-1 bg-gray-100 dark:bg-[#0f0f0f] rounded-full">{dayEvents.length}</span>}
                                                    </div>
                                                </div>
                                                {dayEvents.slice(0, 3).map(ev => {
                                                    const categoryColor = CATEGORY_COLORS[ev.category];
                                                    const cal = myCalendars.find(c => c.id === ev.calendarId);
                                                    const calendarColor = CALENDAR_COLORS.find(c => c.hex === cal?.color) || CALENDAR_COLORS[0];
                                                    const color = categoryColor || calendarColor;
                                                    return (
                                                        <div key={ev.id} className={`text-xs p-2 rounded-lg mb-1 ${color.light}`}>
                                                            <div className={`font-bold ${color.text}`}>{ev.time}</div>
                                                            <div className="text-gray-700 dark:text-gray-300 truncate">{ev.title}</div>
                                                        </div>
                                                    );
                                                })}
                                                {dayEvents.length > 3 && (
                                                    <div className="text-xs text-gray-400 mt-1">+{dayEvents.length - 3} mehr</div>
                                                )}
                                            </div>
                                        );
                                    }
                                    return weekDays;
                                })()}
                            </div>
                        )}
                    </div>

                    {/* SHIFT LEGEND */}
                    {hasShiftPlan && activeCalendarId !== ALL_CALENDARS && (activeCalendar?.shiftDefinitions||[]).length > 0 && (
                        <div className="w-full mb-6 px-4">
                            <div className="flex flex-wrap gap-3 justify-center">
                                {(activeCalendar.shiftDefinitions).map(def => (
                                    <div key={def.id} className="flex items-center gap-1.5 bg-[#ffffff] dark:bg-[#0f0f0f] px-3 py-1.5 rounded-full shadow-sm text-xs font-medium dark:text-gray-300">
                                        <div className="w-3 h-3 rounded-full" style={{backgroundColor: def.color}}></div>
                                        <span>{def.name}</span>
                                        <span className="opacity-50">{def.time}</span>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}

                    {/* Events List */}
                    <div className="w-full flex-1 slide-up">
                        <h2 className="text-xs font-bold uppercase text-gray-400 mb-4 ml-2">
                            {selectedDate.toLocaleDateString('de-DE', { weekday: 'long', day: 'numeric', month: 'long' })}
                        </h2>
                        
                        {/* Multi-Select Controls */}
                        {multiSelectMode && filteredEvents.filter(e => e.type !== 'shift').length > 0 && (
                            <div className="mb-4 p-4 bg-blue-50 dark:bg-blue-900/20 rounded-2xl flex gap-2">
                                <button 
                                    onClick={() => {
                                        const eventIds = filteredEvents.filter(e => e.type !== 'shift').map(e => e.id);
                                        setSelectedEventIds(selectedEventIds.length === eventIds.length ? [] : eventIds);
                                    }}
                                    className="flex-1 py-2 bg-[#ffffff] dark:bg-[#0f0f0f] rounded-xl text-xs font-bold"
                                >
                                    {selectedEventIds.length === filteredEvents.filter(e => e.type !== 'shift').length ? 'Alle abwÃ¤hlen' : 'Alle wÃ¤hlen'}
                                </button>
                                {selectedEventIds.length > 0 && (
                                    <>
                                        <button 
                                            onClick={batchDeleteEvents}
                                            className="flex-1 py-2 bg-red-500 text-white rounded-xl text-xs font-bold"
                                        >
                                            LÃ¶schen ({selectedEventIds.length})
                                        </button>
                                        <button 
                                            onClick={() => {
                                                const targetDateStr = prompt("Verschieben zu (YYYY-MM-DD):", selectedDate.toISOString().split('T')[0]);
                                                if (targetDateStr) {
                                                    batchMoveEvents(new Date(targetDateStr));
                                                }
                                            }}
                                            className="flex-1 py-2 bg-green-500 text-white rounded-xl text-xs font-bold"
                                        >
                                            Verschieben ({selectedEventIds.length})
                                        </button>
                                    </>
                                )}
                            </div>
                        )}
                        
                        <div className="space-y-3">
                            {filteredEvents.filter(e => e.type !== 'shift').length === 0 ? <div className="text-center py-8 opacity-50 border-2 border-dashed dark:border-[#1f1f1f] rounded-3xl text-sm dark:text-gray-400">Keine Termine</div> : filteredEvents.filter(e => e.type !== 'shift').map(ev => {
                                const isExpanded = expandedEventId === ev.id;
                                const cal = myCalendars.find(c => c.id === ev.calendarId);
                                // Use category color if available, otherwise calendar color
                                const categoryColor = CATEGORY_COLORS[ev.category];
                                const calendarColor = CALENDAR_COLORS.find(c => c.hex === cal?.color) || CALENDAR_COLORS[0];
                                const color = categoryColor || calendarColor;
                                const isRequest = requests.some(r => r.id === ev.id);
                                const isMyRequest = isRequest && ev.createdBy === user.uid;
                                const isSelected = selectedEventIds.includes(ev.id);
                                // Check if user can delete: own request/event, OR admin/editor of calendar
                                const myRole = cal?.members?.find(m => m.uid === user?.uid)?.role;
                                const canDelete = isMyRequest || !isRequest || myRole === ROLES.ADMIN || myRole === ROLES.EDITOR;
                                return (
                                    <div 
                                        key={ev.id} 
                                        draggable={!isRequest && !multiSelectMode}
                                        onDragStart={(e) => handleEventDragStart(e, ev)}
                                        className={`bg-white dark:bg-[#0f0f0f] rounded-3xl shadow-sm transition-all duration-300 overflow-hidden ${multiSelectMode ? 'cursor-pointer' : 'cursor-move'} ${isExpanded ? 'ring-1 ring-black/5 dark:ring-white/10' : ''} ${isSelected ? 'ring-2 ring-blue-500' : ''} draggable-event`} 
                                        onClick={() => multiSelectMode ? toggleEventSelection(ev.id) : setExpandedEventId(isExpanded ? null : ev.id)}
                                    >
                                        <div className="p-4 flex items-center justify-between">
                                            {multiSelectMode && (
                                                <input 
                                                    type="checkbox" 
                                                    className="custom-checkbox mr-3" 
                                                    checked={isSelected}
                                                    onChange={() => toggleEventSelection(ev.id)}
                                                    onClick={(e) => e.stopPropagation()}
                                                />
                                            )}
                                            <div className="flex items-center gap-4 flex-1">
                                                <div className={`w-12 h-12 rounded-2xl flex items-center justify-center ${color.light} ${color.text} text-2xl`}>
                                                    {ev.emoji || <Icon name={ev.recurrence ? "repeat" : "calendar"} size={20} />}
                                                </div>
                                                <div className="flex-1">
                                                    <div className="flex items-center gap-2">
                                                        <p className="font-bold text-sm text-gray-800 dark:text-white">{ev.title}</p>
                                                        {isRequest && <span className="text-[10px] px-2 py-0.5 rounded-full bg-orange-100 text-orange-600 dark:bg-orange-900/30 dark:text-orange-400 font-bold">ANFRAGE</span>}
                                                        {ev.isFocus && <span className="text-[10px] px-2 py-0.5 rounded-full bg-purple-100 text-purple-600 dark:bg-purple-900/30 dark:text-purple-400 font-bold">ðŸŽ¯ FOKUS</span>}
                                                    </div>
                                                    <div className="flex items-center gap-2 text-xs text-gray-500 dark:text-gray-400 mt-1">
                                                        <span>{ev.time}</span>
                                                        <span>â€¢</span>
                                                        <span>{ev.durationMin || 60}min</span>
                                                        {activeCalendarId === ALL_CALENDARS && <span className={`${color.text} font-bold px-1.5 py-0.5 rounded bg-white/50`}>{cal?.name}</span>}
                                                    </div>
                                                </div>
                                            </div>
                                            {!multiSelectMode && <Icon name="chevronDown" size={16} className={`text-gray-400 transition-transform ${isExpanded ? 'rotate-180' : ''}`}/>}
                                        </div>
                                        {!multiSelectMode && (
                                            <div className={`details-wrapper ${isExpanded ? 'open' : ''} bg-gray-50 dark:bg-[#252525]`}>
                                                <div className="details-inner px-4 pb-4 pt-2 border-t border-gray-200 dark:border-gray-700">
                                                    <p className="text-xs text-gray-600 dark:text-gray-300 mb-3">{ev.description || 'Keine Notiz'}</p>
                                                    <div className="flex justify-between items-center text-[10px] text-gray-400 uppercase font-bold">
                                                        <span>{ev.createdByName}</span>
                                                        <div className="flex gap-2">
                                                            {isRequest && !isMyRequest && !isDemo && (
                                                                <>
                                                                    <button onClick={(e) => { e.stopPropagation(); handleAcceptRequest(ev); }} className="flex gap-1 items-center text-green-600 bg-green-50 dark:bg-green-900/20 px-2 py-1 rounded"><Icon name="check" size={12}/> Annehmen</button>
                                                                    <button onClick={(e) => { e.stopPropagation(); handleDeclineRequest(ev.id); }} className="flex gap-1 items-center text-red-500 bg-red-50 dark:bg-red-900/20 px-2 py-1 rounded"><Icon name="x" size={12}/> Ablehnen</button>
                                                                </>
                                                            )}
                                                            {!isDemo && canDelete && <button onClick={(e) => { e.stopPropagation(); handleDeleteEvent(ev, isRequest); }} className="flex gap-1 items-center text-red-500 bg-red-50 dark:bg-red-900/20 px-2 py-1 rounded"><Icon name="trash" size={12}/> LÃ¶schen</button>}
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                );
                            })}
                        </div>
                    </div>

                    {/* BOTTOM ACTION BAR */}
                    <div className={`fixed left-0 right-0 bg-white/95 dark:bg-[#0f0f0f]/95 backdrop-blur-lg border-t dark:border-[#1f1f1f] p-3 z-40 shadow-[0_-5px_20px_rgba(0,0,0,0.05)] transition-all ${hasShiftPlan && activeCalendarId !== ALL_CALENDARS ? 'bottom-16' : 'bottom-0'}`}>
                        <div className="max-w-lg mx-auto flex justify-around items-center gap-2">
                            <button onClick={() => setShowAddEventModal(true)} className="flex flex-col items-center gap-1 p-2 rounded-xl transition-all hover:bg-gray-100 dark:hover:bg-[#2D2D2D]" title="Neuer Termin">
                                <div className="p-2 rounded-full bg-black text-white dark:bg-white dark:text-black">
                                    <Icon name="plus" size={18}/>
                                </div>
                                <span className="text-[10px] font-bold dark:text-white">Termin</span>
                            </button>
                            <button onClick={() => setShowTodoModal(true)} className="flex flex-col items-center gap-1 p-2 rounded-xl transition-all hover:bg-gray-100 dark:hover:bg-[#2D2D2D]" title="TODOs">
                                <div className="p-2 rounded-full bg-gray-100 dark:bg-[#1a1a1a] text-gray-700 dark:text-gray-300">
                                    <Icon name="check" size={18}/>
                                </div>
                                <span className="text-[10px] font-bold dark:text-white">TODOs</span>
                            </button>
                            <button onClick={() => setShowAvailabilityModal(true)} className="flex flex-col items-center gap-1 p-2 rounded-xl transition-all hover:bg-gray-100 dark:hover:bg-[#2D2D2D]" title="Terminfindung">
                                <div className="p-2 rounded-full bg-gray-100 dark:bg-[#1a1a1a] text-gray-700 dark:text-gray-300">
                                    <Icon name="calendar" size={18}/>
                                </div>
                                <span className="text-[10px] font-bold dark:text-white">Poll</span>
                            </button>
                            <button onClick={() => setShowTimeTrackingPanel(true)} className="flex flex-col items-center gap-1 p-2 rounded-xl transition-all hover:bg-gray-100 dark:hover:bg-[#2D2D2D]" title="Zeiterfassung">
                                <div className="p-2 rounded-full bg-gray-100 dark:bg-[#1a1a1a] text-gray-700 dark:text-gray-300">
                                    <Icon name="clock" size={18}/>
                                </div>
                                <span className="text-[10px] font-bold dark:text-white">Zeit</span>
                            </button>
                            <div className="relative">
                                <button onClick={() => setShowExportMenu(!showExportMenu)} className="flex flex-col items-center gap-1 p-2 rounded-xl transition-all hover:bg-gray-100 dark:hover:bg-[#2D2D2D]" title="Mehr">
                                    <div className="p-2 rounded-full bg-gray-100 dark:bg-[#1a1a1a] text-gray-700 dark:text-gray-300">
                                        <Icon name="layers" size={18}/>
                                    </div>
                                    <span className="text-[10px] font-bold dark:text-white">Mehr</span>
                                </button>
                                {showExportMenu && (
                                    <div className="absolute bottom-full mb-2 right-0 bg-[#ffffff] dark:bg-[#0f0f0f] rounded-2xl shadow-xl border border-[#e2e8f0] dark:border-[#1f1f1f] p-2 w-52 z-20 slide-up max-h-96 overflow-y-auto">
                                        <button onClick={() => { setShowHabitsModal(true); setShowExportMenu(false); }} className="w-full text-left px-4 py-2.5 rounded-xl hover:bg-gray-50 dark:hover:bg-[#2D2D2D] dark:text-[#e8ecf5] text-sm font-medium">ðŸŽ¯ Habit Tracker</button>
                                        <button onClick={() => { setShowTemplatesModal(true); setShowExportMenu(false); }} className="w-full text-left px-4 py-2.5 rounded-xl hover:bg-gray-50 dark:hover:bg-[#2D2D2D] dark:text-[#e8ecf5] text-sm font-medium">ðŸ“‹ Templates</button>
                                        <button onClick={() => { setMultiSelectMode(!multiSelectMode); setShowExportMenu(false); }} className="w-full text-left px-4 py-2.5 rounded-xl hover:bg-gray-50 dark:hover:bg-[#2D2D2D] dark:text-[#e8ecf5] text-sm font-medium">
                                            {multiSelectMode ? 'âœ“ Multi-Select AN' : 'â˜ Multi-Select'}
                                        </button>
                                        <div className="border-t border-[#e2e8f0] dark:border-[#1f1f1f] my-1"></div>
                                        <button onClick={() => { exportToICS(events); setShowExportMenu(false); }} className="w-full text-left px-4 py-2.5 rounded-xl hover:bg-gray-50 dark:hover:bg-[#2D2D2D] dark:text-[#e8ecf5] text-sm">iCal/ICS Export</button>
                                        {hasShiftPlan && <button onClick={() => { exportShiftsToPDF(); setShowExportMenu(false); }} className="w-full text-left px-4 py-2.5 rounded-xl hover:bg-gray-50 dark:hover:bg-[#2D2D2D] dark:text-[#e8ecf5] text-sm">PDF Schichtplan</button>}
                                        <button onClick={() => { setShowBackupModal(true); setShowExportMenu(false); }} className="w-full text-left px-4 py-2.5 rounded-xl hover:bg-gray-50 dark:hover:bg-[#2D2D2D] dark:text-[#e8ecf5] text-sm">Backup/Restore</button>
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>

                    {/* SHIFT BOTTOM BAR */}
                    {hasShiftPlan && activeCalendarId !== ALL_CALENDARS && (
                        <div className="fixed bottom-0 left-0 right-0 bg-[#ffffff] dark:bg-[#0f0f0f] border-t dark:border-[#1f1f1f] p-2 z-40 flex justify-center shadow-[0_-5px_20px_rgba(0,0,0,0.05)]">
                            <button onClick={() => setShiftMode(!shiftMode)} className={`flex items-center gap-1.5 px-4 py-2 rounded-xl text-sm font-bold transition-all ${shiftMode ? 'bg-blue-500 text-white shadow-lg shadow-blue-500/30' : 'bg-gray-100 dark:bg-[#1a1a1a] dark:text-white'}`}>
                                <Icon name="briefcase" size={16} /> {shiftMode ? 'Pinsel AN' : 'Pinsel AUS'}
                            </button>
                        </div>
                    )}

                    {/* SETTINGS MODAL */}
                    {showSettingsModal && (
                        <div className="fixed inset-0 bg-[#f8f9fb] dark:bg-[#000000] z-50 flex flex-col slide-up">
                            <div className="px-6 py-6 border-b border-[#e2e8f0] dark:border-[#1f1f1f] flex justify-between items-center bg-[#f8f9fb] dark:bg-[#000000] sticky top-0">
                                <h2 className="text-2xl font-bold dark:text-white">Einstellungen</h2>
                                <button onClick={() => setShowSettingsModal(false)} className="p-2 bg-gray-100 dark:bg-[#0f0f0f] dark:text-[#e8ecf5] rounded-full"><Icon name="x" size={24}/></button>
                            </div>
                            <div className="p-6 overflow-y-auto flex-1 bg-[#F8F9FA] dark:bg-[#000000]">
                                
                                <div onClick={()=>setShowCategoryEditor(true)} className="bg-[#ffffff] dark:bg-[#0f0f0f] p-6 rounded-[32px] mb-6 shadow-sm flex justify-between items-center cursor-pointer">
                                    <div className="flex items-center gap-3">
                                        <div className="w-10 h-10 rounded-full bg-blue-50 text-blue-500 flex items-center justify-center"><Icon name="tag" size={20}/></div>
                                        <div><p className="font-bold dark:text-white">Kategorien</p><p className="text-xs text-gray-400">Verwalten</p></div>
                                    </div>
                                    <Icon name="chevronRight" className="text-gray-300"/>
                                </div>

                                <div className="bg-[#ffffff] dark:bg-[#0f0f0f] p-6 rounded-[32px] mb-6 shadow-sm">
                                    <h3 className="text-xs font-bold text-gray-400 uppercase mb-4">Profil</h3>
                                    <div className="flex items-center gap-4">
                                        <div className="w-12 h-12 rounded-full flex items-center justify-center text-white font-bold text-xl shadow-lg" style={{backgroundColor: userData.avatarColor || '#1D1D1F'}}>{editName?.charAt(0).toUpperCase()}</div>
                                        <div className="flex-1"><input className="w-full bg-transparent border-b border-gray-200 dark:border-gray-700 py-1 font-bold text-lg outline-none dark:text-white" value={editName} onChange={(e)=>setEditName(e.target.value)} onBlur={()=>user.updateProfile({displayName: editName})} /></div>
                                    </div>
                                    
                                    <div className="mt-4 space-y-3">
                                        <div>
                                            <label className="text-xs font-bold text-gray-400 uppercase ml-1 mb-2 block">Theme Modus</label>
                                            <select 
                                                className="w-full bg-gray-50 dark:bg-[#1a1a1a] dark:text-[#e8ecf5] rounded-xl p-3 font-bold outline-none" 
                                                value={themeMode}
                                                onChange={e => {
                                                    setThemeMode(e.target.value);
                                                    if (e.target.value === 'light') setDarkMode(false);
                                                    else if (e.target.value === 'dark') setDarkMode(true);
                                                }}
                                            >
                                                <option value="light">Light</option>
                                                <option value="dark">Dark</option>
                                                <option value="auto">Auto (Zeit & System)</option>
                                            </select>
                                        </div>
                                        
                                        <div>
                                            <label className="text-xs font-bold text-gray-400 uppercase ml-1 mb-2 block">Farbpalette</label>
                                            <select 
                                                className="w-full bg-gray-50 dark:bg-[#1a1a1a] dark:text-[#e8ecf5] rounded-xl p-3 font-bold outline-none" 
                                                value={themePalette}
                                                onChange={e => setThemePalette(e.target.value)}
                                            >
                                                <option value="default">Standard (Elegant)</option>
                                                <option value="pastel">Pastel</option>
                                                <option value="high-contrast">High Contrast</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>

                                <div className="mt-4 bg-[#ffffff] dark:bg-[#0f0f0f] p-5 rounded-[28px] shadow-sm">
                                    <div className="flex items-center justify-between">
                                        <div>
                                            <div className="font-bold dark:text-white">Benachrichtigungen</div>
                                            <div className="text-[11px] text-gray-400 leading-snug">
                                                Freigabe im Browser erforderlich. Ohne Service Worker/FCM nur im aktiven Browser/PWA.
                                            </div>
                                        </div>
                                        <div className={`w-10 h-6 rounded-full p-1 cursor-pointer transition-colors ${notificationsEnabled ? 'bg-blue-500' : 'bg-gray-300'}`} onClick={() => { notificationsEnabled ? setNotificationsEnabled(false) : requestNotifications(); }}>
                                            <div className={`w-4 h-4 bg-white rounded-full shadow-md transform transition-transform ${notificationsEnabled ? 'translate-x-4' : ''}`}/>
                                        </div>
                                    </div>
                                </div>

                                <div className="flex justify-between items-center mb-2"><h3 className="text-sm font-bold uppercase text-gray-400">Meine Kalender</h3><button onClick={() => createNewCalendar("Neuer Kalender")} className="text-xs bg-[#2563eb] hover:bg-[#1d4ed8] dark:bg-[#4da3ff] dark:hover:bg-[#3b8fe7] text-white dark:text-[#000000] transition-colors px-3 py-1.5 rounded-full font-bold">+</button></div>
                                
                                {/* CALENDAR SEARCH */}
                                <div className="mb-4">
                                    <input placeholder="Kalender suchen..." className="w-full bg-gray-100 dark:bg-[#0f0f0f] dark:text-[#e8ecf5] px-4 py-2 rounded-xl text-sm outline-none" value={calendarSearchTerm} onChange={e=>setCalendarSearchTerm(e.target.value)} />
                                </div>
                                
                                <div className="space-y-4">{filteredSettingsCalendars.map(cal => {
                                    const isExpanded = expandedSettingsId === cal.id;
                                    const iAmAdmin = cal.members.find(m => m.uid === user.uid)?.role === ROLES.ADMIN;
                                    return (
                                        <div key={cal.id} className={`bg-white dark:bg-[#0f0f0f] rounded-[32px] overflow-hidden shadow-sm transition-colors ${isExpanded ? 'ring-2 ring-black dark:ring-white' : ''}`}>
                                            <div className="p-5 flex items-center justify-between cursor-pointer" onClick={()=>{setExpandedSettingsId(isExpanded?null:cal.id); setEditCalendarName(cal.name);}}>
                                                <div className="flex gap-4 items-center">
                                                    <div className={`w-4 h-4 rounded-full ${CALENDAR_COLORS.find(c=>c.hex===cal.color)?.bg||'bg-gray-400'}`}/>
                                                    <div><p className="font-bold dark:text-white">{cal.name}</p><p className="text-xs text-gray-400">{cal.members.length} User</p></div>
                                                </div>
                                                <span className="text-xs text-gray-400">Edit</span>
                                            </div>
                                            {isExpanded && (
                                                <div className="px-5 pb-6 border-t border-gray-50 dark:border-[#1f1f1f] pt-4">
                                                    <div className="mb-4 flex gap-2">
                                                        <input className="flex-1 bg-gray-50 dark:bg-[#1a1a1a] dark:text-[#e8ecf5] rounded-xl px-3 py-2 text-sm font-bold outline-none" value={editCalendarName} onChange={(e) => setEditCalendarName(e.target.value)} />
                                                        <button onClick={()=>updateCalendar(cal.id, {name: editCalendarName})} className="bg-[#2563eb] hover:bg-[#1d4ed8] dark:bg-[#4da3ff] dark:hover:bg-[#3b8fe7] text-white dark:text-[#000000] transition-colors px-3 rounded-xl"><Icon name="check" size={16}/></button>
                                                    </div>
                                                    
                                                    {/* MEMBER MANAGEMENT */}
                                                    <div className="mb-4 bg-gray-50 dark:bg-[#1a1a1a] p-4 rounded-2xl">
                                                        <span className="text-sm font-bold dark:text-[#e8ecf5] mb-2 block">Mitglieder</span>
                                                        <div className="space-y-2 mb-3">
                                                            {cal.members.map(m => (
                                                                <div key={m.uid} className="flex justify-between items-center text-xs dark:text-gray-300">
                                                                    <span>{m.name} {m.role === ROLES.ADMIN && '(Admin)'}</span>
                                                                    {iAmAdmin && m.uid !== user.uid && (
                                                                        <button onClick={() => removeMemberFromCalendar(cal.id, m.uid)} className="text-red-500"><Icon name="trash" size={14}/></button>
                                                                    )}
                                                                </div>
                                                            ))}
                                                        </div>
                                                        {iAmAdmin && (
                                                            <div className="flex gap-2">
                                                                <input className="flex-1 bg-[#ffffff] dark:bg-[#0f0f0f] dark:text-[#e8ecf5] rounded-lg px-2 py-1.5 text-xs outline-none" placeholder="Username suchen..." value={memberAddName} onChange={e=>setMemberAddName(e.target.value)}/>
                                                                <button onClick={()=>addMemberToCalendar(cal.id)} className="bg-[#2563eb] hover:bg-[#1d4ed8] dark:bg-[#4da3ff] dark:hover:bg-[#3b8fe7] text-white dark:text-[#000000] transition-colors px-3 rounded-lg text-xs font-bold">Add</button>
                                                            </div>
                                                        )}
                                                    </div>

                                                    {/* SHIFT CONFIG */}
                                                    <div className="mb-4 bg-gray-50 dark:bg-[#1a1a1a] p-4 rounded-2xl">
                                                        <div className="flex items-center justify-between mb-2">
                                                            <span className="text-sm font-bold dark:text-white">Schichtplan</span>
                                                            <div className={`w-10 h-6 rounded-full p-1 cursor-pointer transition-colors ${cal.shiftEnabled ? 'bg-green-500' : 'bg-gray-300'}`} onClick={()=>toggleShiftEnabled(cal.id, !cal.shiftEnabled)}>
                                                                <div className={`w-4 h-4 bg-white rounded-full shadow-md transform transition-transform ${cal.shiftEnabled ? 'translate-x-4' : ''}`}/>
                                                            </div>
                                                        </div>
                                                        {cal.shiftEnabled && (
                                                            <div>
                                                                <div className="space-y-2 mb-2">
                                                                    {(cal.shiftDefinitions||[]).map(shift => (
                                                                        <div key={shift.id} className="flex justify-between items-center text-xs">
                                                                            <div className="flex items-center gap-2"><div className="w-3 h-3 rounded-full" style={{backgroundColor:shift.color}}/> <span>{shift.name} ({shift.time})</span></div>
                                                                            <button onClick={()=>deleteShiftDefinition(cal.id, shift.id)} className="text-red-500"><Icon name="x" size={12}/></button>
                                                                        </div>
                                                                    ))}
                                                                </div>
                                                                <div className="flex gap-1">
                                                                    <input className="w-1/3 bg-[#ffffff] dark:bg-[#0f0f0f] rounded-lg px-2 py-1 text-xs" placeholder="Name" value={newShift.name} onChange={e=>setNewShift({...newShift, name:e.target.value})}/>
                                                                    <input className="w-1/3 bg-[#ffffff] dark:bg-[#0f0f0f] rounded-lg px-2 py-1 text-xs" placeholder="Zeit" value={newShift.time} onChange={e=>setNewShift({...newShift, time:e.target.value})}/>
                                                                    <input type="color" className="w-8 h-6 rounded border-none" value={newShift.color} onChange={e=>setNewShift({...newShift, color:e.target.value})}/>
                                                                    <button onClick={()=>addShiftDefinition(cal.id)} className="bg-black text-white px-2 rounded-lg"><Icon name="plus" size={12}/></button>
                                                                </div>
                                                            </div>
                                                        )}
                                                    </div>

                                                    {/* WORK CALENDAR (Secret Trigger) */}
                                                    <div className="mb-4 bg-gray-50 dark:bg-[#1a1a1a] p-4 rounded-2xl">
                                                        <div className="flex items-center justify-between mb-1">
                                                            <span className="text-sm font-bold dark:text-white">Arbeitskalender</span>
                                                            <div className={`w-10 h-6 rounded-full p-1 cursor-pointer transition-colors ${cal.isWorkCalendar ? 'bg-blue-500' : 'bg-gray-300'}`} onClick={()=>updateCalendar(cal.id, { isWorkCalendar: !cal.isWorkCalendar })}>
                                                                <div className={`w-4 h-4 bg-white rounded-full shadow-md transform transition-transform ${cal.isWorkCalendar ? 'translate-x-4' : ''}`}/>
                                                            </div>
                                                        </div>
</div>

                                                    <button onClick={()=>{navigator.clipboard.writeText(cal.id); showToast("Code kopiert")}} className="w-full py-3 mb-2 bg-gray-50 dark:bg-[#1a1a1a] dark:text-[#e8ecf5] rounded-xl font-bold text-xs flex items-center justify-center gap-2">ID Kopieren</button>
                                                    {iAmAdmin && <button onClick={() => handleDeleteCalendar(cal.id)} className="w-full py-3 bg-red-50 dark:bg-red-900/20 text-red-500 rounded-xl font-bold text-xs">LÃ¶schen</button>}
                                                </div>
                                            )}
                                        </div>
                                    );
                                })}</div>
                                <div className="mt-8 pt-8 border-t border-[#e2e8f0] dark:border-[#1f1f1f]"><button onClick={()=>auth.signOut()} className="w-full py-4 text-red-500 font-bold bg-[#ffffff] dark:bg-[#0f0f0f] rounded-2xl shadow-sm">Abmelden</button></div>
                            </div>
                        </div>
                    )}

                    {/* SHIFT SELECTOR MODAL */}
                    {showShiftSelector && (
                        <div className="fixed inset-0 bg-black/40 backdrop-blur-sm z-[80] flex items-center justify-center p-4" onClick={() => { setShowShiftSelector(false); setDragSelection({start:null, end:null, isDragging:false}); }}>
                            <div className="bg-[#ffffff] dark:bg-[#0f0f0f] w-full max-w-xs rounded-[32px] p-6 shadow-2xl scale-in" onClick={e=>e.stopPropagation()}>
                                <h3 className="text-lg font-bold mb-4 dark:text-[#e8ecf5] text-center">Schicht wÃ¤hlen</h3>
                                <p className="text-center text-xs text-gray-400 mb-4">{getDatesInRange(dragSelection.start, dragSelection.end).length} Tag(e) gewÃ¤hlt</p>
                                <div className="space-y-2">
                                    {(activeCalendar?.shiftDefinitions||[]).map(shift => (
                                        <button key={shift.id} onClick={()=>assignShift(shift)} className="w-full p-4 rounded-xl font-bold text-white shadow-md flex justify-between" style={{backgroundColor: shift.color}}>
                                            <span>{shift.name}</span>
                                            <span className="opacity-70 text-xs mt-1">{shift.time}</span>
                                        </button>
                                    ))}
                                    <button onClick={()=>assignShift(null)} className="w-full p-4 rounded-xl font-bold bg-gray-100 dark:bg-[#1a1a1a] text-gray-500">Schicht lÃ¶schen</button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* CATEGORY MODAL */}
                    {showCategoryEditor && (
                        <div className="fixed inset-0 bg-[#f8f9fb] dark:bg-[#000000] z-[60] flex flex-col slide-up">
                            <div className="px-6 py-6 border-b border-[#e2e8f0] dark:border-[#1f1f1f] flex justify-between items-center bg-[#f8f9fb] dark:bg-[#000000] sticky top-0">
                                <div className="flex items-center gap-2">
                                    <button onClick={() => setShowCategoryEditor(false)} className="p-2 -ml-2 rounded-full"><Icon name="chevronLeft"/></button>
                                    <h2 className="text-xl font-bold dark:text-white">Kategorien</h2>
                                </div>
                            </div>
                            <div className="p-6 overflow-y-auto flex-1 bg-[#F8F9FA] dark:bg-[#000000]">
                                <div className="mb-6 flex gap-2">
                                    <input className="flex-1 bg-[#ffffff] dark:bg-[#0f0f0f] dark:text-[#e8ecf5] p-4 rounded-2xl outline-none shadow-sm" placeholder="Neue Hauptkategorie..." value={newCatName} onChange={e=>setNewCatName(e.target.value)}/>
                                    <button onClick={addMainCategory} className="bg-[#2563eb] hover:bg-[#1d4ed8] dark:bg-[#4da3ff] dark:hover:bg-[#3b8fe7] text-white dark:text-[#000000] transition-colors px-5 rounded-2xl font-bold shadow-lg">Neu</button>
                                </div>
                                <div className="space-y-3">
                                    {Object.keys(categories).map(cat => {
                                        const isExpanded = expandedCatEdit === cat;
                                        return (
                                            <div key={cat} className="bg-[#ffffff] dark:bg-[#0f0f0f] rounded-[24px] overflow-hidden shadow-sm">
                                                <div className="p-4 flex items-center justify-between cursor-pointer" onClick={()=>setExpandedCatEdit(isExpanded?null:cat)}>
                                                    <span className="font-bold dark:text-white">{cat}</span>
                                                    <div className="flex items-center gap-2">
                                                        <span className="text-xs text-gray-400 bg-gray-100 dark:bg-[#1a1a1a] px-2 py-1 rounded-lg">{categories[cat].length} Sub</span>
                                                        <Icon name="chevronDown" size={16} className={`text-gray-400 transition-transform ${isExpanded?'rotate-180':''}`}/>
                                                    </div>
                                                </div>
                                                {isExpanded && (
                                                    <div className="px-4 pb-4 border-t border-[#e2e8f0] dark:border-[#1f1f1f] bg-gray-50 dark:bg-[#252525]">
                                                        <div className="flex flex-wrap gap-2 pt-4 mb-4">
                                                            {categories[cat].map(sub => (
                                                                <div key={sub} className="flex items-center gap-1 bg-[#ffffff] dark:bg-[#0f0f0f] px-3 py-1.5 rounded-xl border border-gray-200 dark:border-gray-700 shadow-sm">
                                                                    <span className="text-sm dark:text-gray-200">{sub}</span>
                                                                    <button onClick={()=>deleteSubCategory(cat, sub)} className="text-gray-400 hover:text-red-500"><Icon name="x" size={12}/></button>
                                                                </div>
                                                            ))}
                                                        </div>
                                                        <div className="flex gap-2">
                                                            <input className="flex-1 bg-[#ffffff] dark:bg-[#0f0f0f] dark:text-[#e8ecf5] px-3 py-2 rounded-xl text-sm outline-none border border-gray-200 dark:border-gray-700" placeholder="Neue Unterkategorie..." value={newSubCatName} onChange={e=>setNewSubCatName(e.target.value)}/>
                                                            <button onClick={()=>addSubCategory(cat)} className="bg-[#2563eb] dark:bg-[#4da3ff] dark:text-black text-white px-3 rounded-xl"><Icon name="plus" size={16}/></button>
                                                        </div>
                                                        <button onClick={()=>deleteMainCategory(cat)} className="w-full mt-4 py-2 text-red-500 text-xs font-bold uppercase bg-red-50 dark:bg-red-900/20 rounded-xl">Kategorie LÃ¶schen</button>
                                                    </div>
                                                )}
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Add Event Modal */}
                    {showAddEventModal && (
                        <div className="fixed inset-0 bg-black/30 backdrop-blur-sm z-50 flex items-end md:items-center justify-center p-4">
                            <div className="bg-[#ffffff] dark:bg-[#0f0f0f] w-full max-w-sm rounded-[32px] p-6 shadow-2xl slide-up">
                                <div className="flex justify-between items-center mb-6">
                                    <h3 className="text-xl font-bold dark:text-white">Neuer Termin</h3>
                                    <button onClick={() => setShowAddEventModal(false)} className="p-2 bg-gray-50 dark:bg-[#1a1a1a] rounded-full text-gray-400"><Icon name="x" size={20}/></button>
                                </div>
                                <div className="space-y-4">
                                    {activeCalendarId === ALL_CALENDARS && (
                                        <div>
                                            <label className="text-[10px] font-bold text-gray-400 uppercase ml-1">Kalender wÃ¤hlen</label>
                                            <select className="w-full bg-gray-50 dark:bg-[#1a1a1a] dark:text-[#e8ecf5] rounded-2xl p-4 mt-1 font-bold outline-none" value={newEvent.targetCalId} onChange={e => setNewEvent({...newEvent, targetCalId: e.target.value})}>
                                                <option value="">Bitte wÃ¤hlen...</option>
                                                {myCalendars.map(c => <option key={c.id} value={c.id}>{c.name}</option>)}
                                            </select>
                                        </div>
                                    )}
                                    <input autoFocus className="w-full bg-gray-50 dark:bg-[#1a1a1a] dark:text-[#e8ecf5] rounded-2xl p-4 mt-1 font-bold outline-none" placeholder="Titel" value={newEvent.title} onChange={e => setNewEvent({...newEvent, title: e.target.value})}/>
                                    
                                    {/* Quick Add Input */}
                                    <div>
                                        <label className="text-[10px] font-bold text-gray-400 uppercase ml-1">Schnelleingabe (optional)</label>
                                        <div className="flex gap-2 mt-1">
                                            <input 
                                                className="flex-1 bg-gray-50 dark:bg-[#1a1a1a] dark:text-[#e8ecf5] rounded-2xl p-4 font-medium outline-none text-sm" 
                                                placeholder="z.B. morgen 15:30 90min Meeting"
                                                value={quickAddInput}
                                                onChange={e => setQuickAddInput(e.target.value)}
                                                onKeyPress={e => e.key === 'Enter' && handleQuickAdd()}
                                            />
                                            <button onClick={handleQuickAdd} className="px-4 bg-blue-500 text-white rounded-2xl font-bold text-sm">Parse</button>
                                        </div>
                                    </div>
                                    
                                    <textarea className="w-full bg-gray-50 dark:bg-[#1a1a1a] dark:text-[#e8ecf5] rounded-2xl p-4 mt-1 font-medium outline-none h-24 resize-none" placeholder="Notiz..." value={newEvent.description} onChange={e => setNewEvent({...newEvent, description: e.target.value})}/>
                                    
                                    {/* Emoji Picker */}
                                    <div>
                                        <label className="text-[10px] font-bold text-gray-400 uppercase ml-1">Emoji (optional)</label>
                                        <div className="flex flex-wrap gap-2 mt-1 p-3 bg-gray-50 dark:bg-[#1a1a1a] rounded-2xl max-h-32 overflow-y-auto">
                                            {Object.entries(EMOJI_CATEGORIES).map(([category, emojis]) => (
                                                <div key={category} className="flex flex-wrap gap-1">
                                                    {emojis.map(emoji => (
                                                        <button
                                                            key={emoji}
                                                            type="button"
                                                            onClick={() => setNewEvent({...newEvent, emoji: newEvent.emoji === emoji ? '' : emoji})}
                                                            className={`text-2xl p-2 rounded-lg transition-all ${newEvent.emoji === emoji ? 'bg-blue-100 dark:bg-blue-900/30 scale-110' : 'hover:bg-gray-100 dark:hover:bg-[#3D3D3D]'}`}
                                                        >
                                                            {emoji}
                                                        </button>
                                                    ))}
                                                </div>
                                            ))}
                                        </div>
                                        {newEvent.emoji && (
                                            <div className="mt-2 text-center">
                                                <span className="text-xs text-gray-400">GewÃ¤hlt: </span>
                                                <span className="text-2xl">{newEvent.emoji}</span>
                                            </div>
                                        )}
                                    </div>
                                    
                                    {/* Recurrence Selection */}
                                    <div>
                                        <label className="text-[10px] font-bold text-gray-400 uppercase ml-1">Wiederholung</label>
                                        <select className="w-full bg-gray-50 dark:bg-[#1a1a1a] dark:text-[#e8ecf5] rounded-2xl p-4 mt-1 font-bold outline-none" value={newEvent.recurrence || ''} onChange={e => setNewEvent({...newEvent, recurrence: e.target.value || null})}>
                                            <option value="">Keine</option>
                                            <option value="daily">TÃ¤glich</option>
                                            <option value="weekly">WÃ¶chentlich</option>
                                            <option value="biweekly">14-tÃ¤gig</option>
                                            <option value="monthly">Monatlich</option>
                                            <option value="yearly">JÃ¤hrlich</option>
                                        </select>
                                    </div>

                                    {newEvent.recurrence && (
                                        <div>
                                            <label className="text-[10px] font-bold text-gray-400 uppercase ml-1">Enddatum (optional)</label>
                                            <input type="date" className="w-full bg-gray-50 dark:bg-[#1a1a1a] dark:text-[#e8ecf5] rounded-2xl p-4 mt-1 font-bold outline-none" value={newEvent.recurrenceEndDate || ''} onChange={e => setNewEvent({...newEvent, recurrenceEndDate: e.target.value})} />
                                        </div>
                                    )}

                                    {/* Reminders */}
                                    <div>
                                        <label className="text-[10px] font-bold text-gray-400 uppercase ml-1">Erinnerungen</label>
                                        <div className="space-y-2 mt-2">
                                            {[
                                                { value: 60, label: '1 Stunde vorher' },
                                                { value: 1440, label: '1 Tag vorher' },
                                                { value: 10080, label: '1 Woche vorher' }
                                            ].map(reminder => (
                                                <div key={reminder.value} className="flex items-center gap-3 bg-gray-50 dark:bg-[#1a1a1a] p-3 rounded-xl">
                                                    <input 
                                                        type="checkbox" 
                                                        id={`reminder-${reminder.value}`}
                                                        className="custom-checkbox" 
                                                        checked={(newEvent.reminders || []).includes(reminder.value)}
                                                        onChange={e => {
                                                            const reminders = newEvent.reminders || [];
                                                            if (e.target.checked) {
                                                                setNewEvent({...newEvent, reminders: [...reminders, reminder.value]});
                                                            } else {
                                                                setNewEvent({...newEvent, reminders: reminders.filter(r => r !== reminder.value)});
                                                            }
                                                        }}
                                                    />
                                                    <label htmlFor={`reminder-${reminder.value}`} className="text-sm dark:text-[#e8ecf5] cursor-pointer select-none">{reminder.label}</label>
                                                </div>
                                            ))}
                                        </div>
                                    </div>

                                    <input type="time" className="w-full bg-gray-50 dark:bg-[#1a1a1a] dark:text-[#e8ecf5] rounded-2xl p-4 mt-1 font-bold outline-none" value={newEvent.time} onChange={e => setNewEvent({...newEvent, time: e.target.value})}/>
                                    
                                    {/* Duration */}
                                    <div>
                                        <label className="text-[10px] font-bold text-gray-400 uppercase ml-1">Dauer (Minuten)</label>
                                        <input 
                                            type="number" 
                                            min="15" 
                                            step="15"
                                            className="w-full bg-gray-50 dark:bg-[#1a1a1a] dark:text-[#e8ecf5] rounded-2xl p-4 mt-1 font-bold outline-none" 
                                            value={newEvent.durationMin} 
                                            onChange={e => setNewEvent({...newEvent, durationMin: parseInt(e.target.value) || 60})}
                                        />
                                    </div>
                                    
                                    {/* Focus Mode & Smart Suggestions */}
                                    <div className="flex gap-2">
                                        <button 
                                            type="button"
                                            onClick={() => setNewEvent({...newEvent, isFocus: !newEvent.isFocus})}
                                            className={`flex-1 py-3 rounded-xl font-bold text-sm transition-all ${newEvent.isFocus ? 'bg-purple-500 text-white' : 'bg-gray-100 dark:bg-[#1a1a1a] text-gray-600 dark:text-gray-400'}`}
                                        >
                                            ðŸŽ¯ Fokusblock
                                        </button>
                                        <button
                                            type="button"
                                            onClick={() => {
                                                const suggestions = suggestFreeSlots(
                                                    events.filter(e => e.calendarId === (activeCalendarId === ALL_CALENDARS ? newEvent.targetCalId : activeCalendarId)),
                                                    selectedDate,
                                                    events
                                                );
                                                if (suggestions.length > 0) {
                                                    setNewEvent({...newEvent, time: suggestions[0].time});
                                                    showToast(`âœ“ Vorschlag: ${suggestions[0].time}`);
                                                } else {
                                                    showToast("Keine freien Slots gefunden");
                                                }
                                            }}
                                            className="flex-1 py-3 bg-blue-100 dark:bg-blue-900/30 text-blue-600 dark:text-blue-400 rounded-xl font-bold text-sm"
                                        >
                                            ðŸ’¡ Vorschlag
                                        </button>
                                    </div>
                                    
                                    <div className="grid grid-cols-2 gap-3">
                                        <select className="w-full bg-gray-50 dark:bg-[#1a1a1a] dark:text-[#e8ecf5] rounded-2xl p-4 font-bold outline-none text-sm appearance-none" value={newEvent.category} onChange={e => setNewEvent({...newEvent, category: e.target.value, subCategory: categories[e.target.value]?.[0] || ''})}>
                                            {Object.keys(categories).map(c => <option key={c} value={c}>{c}</option>)}
                                        </select>
                                        <select className="w-full bg-gray-50 dark:bg-[#1a1a1a] dark:text-[#e8ecf5] rounded-2xl p-4 font-bold outline-none text-sm appearance-none" value={newEvent.subCategory} onChange={e => setNewEvent({...newEvent, subCategory: e.target.value})}>
                                            {categories[newEvent.category]?.map(sc => <option key={sc} value={sc}>{sc}</option>)}
                                        </select>
                                    </div>
                                    <div className="pt-4 flex flex-col gap-2">
                                        <button onClick={()=>handleCreateEvent()} className="w-full py-4 bg-[#2563eb] hover:bg-[#1d4ed8] dark:bg-[#4da3ff] dark:hover:bg-[#3b8fe7] text-white dark:text-black rounded-2xl font-bold shadow-lg transition-colors">Speichern</button>
                                        <button onClick={()=>handleCreateEvent(true)} className="w-full py-4 bg-gray-100 dark:bg-[#1a1a1a] text-gray-600 dark:text-[#e8ecf5] rounded-2xl font-bold">Als Anfrage senden</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* TODO Modal */}
                    {showTodoModal && (
                        <div className="fixed inset-0 bg-[#f8f9fb] dark:bg-[#000000] z-50 flex flex-col slide-up overflow-y-auto">
                            <div className="px-6 py-6 border-b border-[#e2e8f0] dark:border-[#1f1f1f] flex justify-between items-center bg-[#f8f9fb] dark:bg-[#000000] sticky top-0">
                                <h2 className="text-2xl font-bold dark:text-white">TODOs</h2>
                                <button onClick={() => setShowTodoModal(false)} className="p-2 bg-gray-100 dark:bg-[#0f0f0f] dark:text-[#e8ecf5] rounded-full"><Icon name="x" size={24}/></button>
                            </div>
                            <div className="p-6 flex-1 bg-[#F8F9FA] dark:bg-[#000000]">
                                {/* New TODO Form */}
                                <div className="bg-[#ffffff] dark:bg-[#0f0f0f] rounded-[32px] p-6 mb-6 shadow-sm">
                                    <h3 className="text-lg font-bold dark:text-[#e8ecf5] mb-4">Neues TODO</h3>
                                    <div className="space-y-3">
                                        {activeCalendarId === ALL_CALENDARS && (
                                            <select className="w-full bg-gray-50 dark:bg-[#1a1a1a] dark:text-[#e8ecf5] rounded-2xl p-4 font-bold outline-none" value={newTodo.targetCalId || ''} onChange={e => setNewTodo({...newTodo, targetCalId: e.target.value})}>
                                                <option value="">Kalender wÃ¤hlen...</option>
                                                {myCalendars.map(c => <option key={c.id} value={c.id}>{c.name}</option>)}
                                            </select>
                                        )}
                                        <input className="w-full bg-gray-50 dark:bg-[#1a1a1a] dark:text-[#e8ecf5] rounded-2xl p-4 font-bold outline-none" placeholder="Titel" value={newTodo.title} onChange={e => setNewTodo({...newTodo, title: e.target.value})} />
                                        <textarea className="w-full bg-gray-50 dark:bg-[#1a1a1a] dark:text-[#e8ecf5] rounded-2xl p-4 outline-none resize-none h-24" placeholder="Beschreibung..." value={newTodo.description} onChange={e => setNewTodo({...newTodo, description: e.target.value})} />
                                        <input type="date" className="w-full bg-gray-50 dark:bg-[#1a1a1a] dark:text-[#e8ecf5] rounded-2xl p-4 font-bold outline-none" placeholder="FÃ¤lligkeitsdatum" value={newTodo.dueDate} onChange={e => setNewTodo({...newTodo, dueDate: e.target.value})} />
                                        
                                        {/* Checklist Items */}
                                        <div>
                                            <label className="text-xs font-bold text-gray-400 uppercase ml-1 mb-2 block">Checkliste</label>
                                            {(newTodo.checklist || []).map((item, idx) => (
                                                <div key={idx} className="flex gap-2 mb-2">
                                                    <input className="flex-1 bg-gray-50 dark:bg-[#1a1a1a] dark:text-[#e8ecf5] rounded-xl p-2 text-sm outline-none" value={item} onChange={e => {
                                                        const updated = [...newTodo.checklist];
                                                        updated[idx] = e.target.value;
                                                        setNewTodo({...newTodo, checklist: updated});
                                                    }} />
                                                    <button onClick={() => setNewTodo({...newTodo, checklist: newTodo.checklist.filter((_, i) => i !== idx)})} className="p-2 text-red-500"><Icon name="trash" size={16}/></button>
                                                </div>
                                            ))}
                                            <button onClick={() => setNewTodo({...newTodo, checklist: [...(newTodo.checklist || []), '']})} className="text-sm text-blue-500 font-bold">+ Checklistenpunkt</button>
                                        </div>

                                        <button onClick={handleCreateTodo} className="w-full py-4 bg-[#2563eb] hover:bg-[#1d4ed8] dark:bg-[#4da3ff] dark:hover:bg-[#3b8fe7] text-white dark:text-[#000000] transition-colors rounded-2xl font-bold shadow-lg">TODO Erstellen</button>
                                    </div>
                                </div>

                                {/* TODO List */}
                                <div className="space-y-3">
                                    <h3 className="text-sm font-bold uppercase text-gray-400 mb-4">Alle TODOs</h3>
                                    {filteredTodos.length === 0 ? (
                                        <div className="text-center py-8 opacity-50 border-2 border-dashed dark:border-[#1f1f1f] rounded-3xl text-sm dark:text-gray-400">Keine TODOs</div>
                                    ) : filteredTodos.map(todo => {
                                        const cal = myCalendars.find(c => c.id === todo.calendarId);
                                        const color = CALENDAR_COLORS.find(c => c.hex === cal?.color) || CALENDAR_COLORS[0];
                                        const isOverdue = todo.dueDate && !todo.completed && new Date(todo.dueDate) < new Date();
                                        
                                        return (
                                            <div key={todo.id} className={`bg-white dark:bg-[#0f0f0f] rounded-3xl p-5 shadow-sm ${todo.completed ? 'opacity-60' : ''}`}>
                                                <div className="flex items-start gap-4">
                                                    <input 
                                                        type="checkbox" 
                                                        className="custom-checkbox mt-1" 
                                                        checked={todo.completed} 
                                                        onChange={() => toggleTodoComplete(todo.id, todo.calendarId, todo.completed)} 
                                                    />
                                                    <div className="flex-1">
                                                        <div className="flex items-center gap-2 mb-1">
                                                            <h4 className={`font-bold dark:text-[#e8ecf5] ${todo.completed ? 'line-through' : ''}`}>{todo.title}</h4>
                                                            {activeCalendarId === ALL_CALENDARS && <span className={`${color.text} text-xs px-2 py-0.5 rounded-full ${color.light}`}>{cal?.name}</span>}
                                                        </div>
                                                        {todo.description && <p className="text-sm text-gray-600 dark:text-gray-400 mb-2">{todo.description}</p>}
                                                        {todo.dueDate && (
                                                            <p className={`text-xs font-bold ${isOverdue ? 'text-red-500' : 'text-gray-400'}`}>
                                                                FÃ¤llig: {new Date(todo.dueDate).toLocaleDateString('de-DE')}
                                                            </p>
                                                        )}
                                                        {todo.checklist && todo.checklist.length > 0 && (
                                                            <div className="mt-3 space-y-1">
                                                                {todo.checklist.map((item, idx) => (
                                                                    <div key={idx} className="text-sm text-gray-600 dark:text-gray-400 flex items-center gap-2">
                                                                        <div className="w-1.5 h-1.5 rounded-full bg-gray-400" />
                                                                        {item}
                                                                    </div>
                                                                ))}
                                                            </div>
                                                        )}
                                                    </div>
                                                    <button onClick={() => deleteTodo(todo.id, todo.calendarId)} className="p-2 text-gray-400 hover:text-red-500">
                                                        <Icon name="trash" size={16}/>
                                                    </button>
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Availability/Poll Modal */}
                    {showAvailabilityModal && (
                        <div className="fixed inset-0 bg-[#f8f9fb] dark:bg-[#000000] z-50 flex flex-col slide-up overflow-y-auto">
                            <div className="px-6 py-6 border-b border-[#e2e8f0] dark:border-[#1f1f1f] flex justify-between items-center bg-[#f8f9fb] dark:bg-[#000000] sticky top-0">
                                <h2 className="text-2xl font-bold dark:text-white">Terminfindung</h2>
                                <button onClick={() => setShowAvailabilityModal(false)} className="p-2 bg-gray-100 dark:bg-[#0f0f0f] dark:text-[#e8ecf5] rounded-full"><Icon name="x" size={24}/></button>
                            </div>
                            <div className="p-6 flex-1 bg-[#F8F9FA] dark:bg-[#000000]">
                                {/* New Proposal Form */}
                                <div className="bg-[#ffffff] dark:bg-[#0f0f0f] rounded-[32px] p-6 mb-6 shadow-sm">
                                    <h3 className="text-lg font-bold dark:text-[#e8ecf5] mb-4">Neue Umfrage</h3>
                                    <div className="space-y-3">
                                        {activeCalendarId === ALL_CALENDARS && (
                                            <select className="w-full bg-gray-50 dark:bg-[#1a1a1a] dark:text-[#e8ecf5] rounded-2xl p-4 font-bold outline-none" value={availabilityProposal.targetCalId || ''} onChange={e => setAvailabilityProposal({...availabilityProposal, targetCalId: e.target.value})}>
                                                <option value="">Kalender wÃ¤hlen...</option>
                                                {myCalendars.map(c => <option key={c.id} value={c.id}>{c.name}</option>)}
                                            </select>
                                        )}
                                        <input className="w-full bg-gray-50 dark:bg-[#1a1a1a] dark:text-[#e8ecf5] rounded-2xl p-4 font-bold outline-none" placeholder="Titel (z.B. Team-Meeting)" value={availabilityProposal.title} onChange={e => setAvailabilityProposal({...availabilityProposal, title: e.target.value})} />
                                        
                                        <div>
                                            <label className="text-xs font-bold text-gray-400 uppercase ml-1 mb-2 block">TerminvorschlÃ¤ge</label>
                                            {availabilityProposal.dates.map((date, idx) => (
                                                <div key={idx} className="flex gap-2 mb-2">
                                                    <input type="datetime-local" className="flex-1 bg-gray-50 dark:bg-[#1a1a1a] dark:text-[#e8ecf5] rounded-xl p-3 font-bold outline-none" value={date} onChange={e => {
                                                        const updated = [...availabilityProposal.dates];
                                                        updated[idx] = e.target.value;
                                                        setAvailabilityProposal({...availabilityProposal, dates: updated});
                                                    }} />
                                                    <button onClick={() => setAvailabilityProposal({...availabilityProposal, dates: availabilityProposal.dates.filter((_, i) => i !== idx)})} className="p-2 text-red-500"><Icon name="trash" size={16}/></button>
                                                </div>
                                            ))}
                                            <button onClick={() => setAvailabilityProposal({...availabilityProposal, dates: [...availabilityProposal.dates, '']})} className="text-sm text-blue-500 font-bold">+ Termin hinzufÃ¼gen</button>
                                        </div>

                                        <button onClick={createAvailabilityProposal} className="w-full py-4 bg-[#2563eb] hover:bg-[#1d4ed8] dark:bg-[#4da3ff] dark:hover:bg-[#3b8fe7] text-white dark:text-[#000000] transition-colors rounded-2xl font-bold shadow-lg">Umfrage Erstellen</button>
                                    </div>
                                </div>

                                {/* Existing Proposals */}
                                <div className="space-y-4">
                                    <h3 className="text-sm font-bold uppercase text-gray-400 mb-4">Aktive Umfragen</h3>
                                    {proposals.length === 0 ? (
                                        <div className="text-center py-8 opacity-50 border-2 border-dashed dark:border-[#1f1f1f] rounded-3xl text-sm dark:text-gray-400">Keine Umfragen</div>
                                    ) : proposals.map(proposal => {
                                        const cal = myCalendars.find(c => c.id === proposal.calendarId);
                                        const color = CALENDAR_COLORS.find(c => c.hex === cal?.color) || CALENDAR_COLORS[0];
                                        
                                        return (
                                            <div key={proposal.id} className="bg-[#ffffff] dark:bg-[#0f0f0f] rounded-3xl p-5 shadow-sm">
                                                <div className="mb-4">
                                                    <div className="flex items-center gap-2 mb-2">
                                                        <h4 className="font-bold text-lg dark:text-white">{proposal.title}</h4>
                                                        {activeCalendarId === ALL_CALENDARS && <span className={`${color.text} text-xs px-2 py-0.5 rounded-full ${color.light}`}>{cal?.name}</span>}
                                                    </div>
                                                    <p className="text-xs text-gray-400">Erstellt von {proposal.createdByName}</p>
                                                </div>

                                                <div className="space-y-2">
                                                    {proposal.dates.map((date, idx) => {
                                                        const dateObj = new Date(date);
                                                        const votes = proposal.votes || {};
                                                        const yesCount = Object.values(votes).filter(v => v[idx] === 'yes').length;
                                                        const maybeCount = Object.values(votes).filter(v => v[idx] === 'maybe').length;
                                                        const myVote = votes[user.uid]?.[idx];
                                                        
                                                        return (
                                                            <div key={idx} className="bg-gray-50 dark:bg-[#1a1a1a] rounded-2xl p-4">
                                                                <div className="flex justify-between items-center mb-2">
                                                                    <div>
                                                                        <div className="font-bold dark:text-white">{dateObj.toLocaleDateString('de-DE', { weekday: 'short', day: 'numeric', month: 'short' })}</div>
                                                                        <div className="text-xs text-gray-400">{dateObj.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' })}</div>
                                                                    </div>
                                                                    <div className="text-xs text-gray-400">
                                                                        âœ“ {yesCount} Â· ? {maybeCount}
                                                                    </div>
                                                                </div>
                                                                <div className="flex gap-2">
                                                                    <button onClick={() => voteOnProposal(proposal.id, proposal.calendarId, idx, 'yes')} className={`flex-1 py-2 rounded-xl text-sm font-bold ${myVote === 'yes' ? 'bg-green-500 text-white' : 'bg-white dark:bg-[#0f0f0f] text-gray-600 dark:text-gray-300'}`}>âœ“ Ja</button>
                                                                    <button onClick={() => voteOnProposal(proposal.id, proposal.calendarId, idx, 'maybe')} className={`flex-1 py-2 rounded-xl text-sm font-bold ${myVote === 'maybe' ? 'bg-yellow-500 text-white' : 'bg-white dark:bg-[#0f0f0f] text-gray-600 dark:text-gray-300'}`}>? Vielleicht</button>
                                                                    <button onClick={() => voteOnProposal(proposal.id, proposal.calendarId, idx, 'no')} className={`flex-1 py-2 rounded-xl text-sm font-bold ${myVote === 'no' ? 'bg-red-500 text-white' : 'bg-white dark:bg-[#0f0f0f] text-gray-600 dark:text-gray-300'}`}>âœ— Nein</button>
                                                                </div>
                                                            </div>
                                                        );
                                                    })}
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Search Panel */}
                    {showSearchPanel && (
                        <div className="fixed inset-0 bg-[#f8f9fb] dark:bg-[#000000] z-50 flex flex-col slide-up">
                            <div className="px-6 py-6 border-b border-[#e2e8f0] dark:border-[#1f1f1f] flex justify-between items-center bg-[#f8f9fb] dark:bg-[#000000] sticky top-0">
                                <h2 className="text-2xl font-bold dark:text-white">Suche</h2>
                                <button onClick={() => { setShowSearchPanel(false); setSearchQuery(''); }} className="p-2 bg-gray-100 dark:bg-[#0f0f0f] dark:text-[#e8ecf5] rounded-full"><Icon name="x" size={24}/></button>
                            </div>
                            <div className="p-6 flex-1 overflow-y-auto bg-[#F8F9FA] dark:bg-[#000000]">
                                <div className="mb-6">
                                    <input 
                                        type="text" 
                                        className="w-full bg-[#ffffff] dark:bg-[#0f0f0f] dark:text-[#e8ecf5] px-6 py-4 rounded-2xl text-lg outline-none border-2 border-gray-200 dark:border-gray-700 focus:border-black dark:focus:border-white transition-all" 
                                        placeholder="Termine und TODOs durchsuchen..." 
                                        value={searchQuery}
                                        onChange={e => setSearchQuery(e.target.value)}
                                        autoFocus
                                    />
                                </div>

                                {searchQuery.trim() && (
                                    <div className="space-y-6">
                                        {/* Search Results - Events */}
                                        {searchResults.events.length > 0 && (
                                            <div>
                                                <h3 className="text-sm font-bold uppercase text-gray-400 mb-3">Termine ({searchResults.events.length})</h3>
                                                <div className="space-y-3">
                                                    {searchResults.events.map(ev => {
                                                        const cal = myCalendars.find(c => c.id === ev.calendarId);
                                                        const categoryColor = CATEGORY_COLORS[ev.category];
                                                        const calendarColor = CALENDAR_COLORS.find(c => c.hex === cal?.color) || CALENDAR_COLORS[0];
                                                        const color = categoryColor || calendarColor;
                                                        return (
                                                            <div key={ev.id} className="bg-[#ffffff] dark:bg-[#0f0f0f] rounded-2xl p-4 shadow-sm" onClick={() => { setSelectedDate(ev.date); setShowSearchPanel(false); setSearchQuery(''); }}>
                                                                <div className="flex items-center gap-3">
                                                                    <div className={`w-10 h-10 rounded-xl flex items-center justify-center ${color.light} ${color.text}`}>
                                                                        <Icon name="calendar" size={16} />
                                                                    </div>
                                                                    <div className="flex-1">
                                                                        <p className="font-bold text-sm dark:text-white">{ev.title}</p>
                                                                        <p className="text-xs text-gray-500 dark:text-gray-400">{ev.date.toLocaleDateString('de-DE')} â€¢ {ev.time} â€¢ {ev.category}</p>
                                                                    </div>
                                                                </div>
                                                            </div>
                                                        );
                                                    })}
                                                </div>
                                            </div>
                                        )}

                                        {/* Search Results - TODOs */}
                                        {searchResults.todos.length > 0 && (
                                            <div>
                                                <h3 className="text-sm font-bold uppercase text-gray-400 mb-3">TODOs ({searchResults.todos.length})</h3>
                                                <div className="space-y-3">
                                                    {searchResults.todos.map(todo => {
                                                        const cal = myCalendars.find(c => c.id === todo.calendarId);
                                                        const color = CALENDAR_COLORS.find(c => c.hex === cal?.color) || CALENDAR_COLORS[0];
                                                        return (
                                                            <div key={todo.id} className="bg-[#ffffff] dark:bg-[#0f0f0f] rounded-2xl p-4 shadow-sm" onClick={() => { setShowTodoModal(true); setShowSearchPanel(false); setSearchQuery(''); }}>
                                                                <div className="flex items-center gap-3">
                                                                    <div className={`w-10 h-10 rounded-xl flex items-center justify-center ${color.light} ${color.text}`}>
                                                                        <Icon name="check" size={16} />
                                                                    </div>
                                                                    <div className="flex-1">
                                                                        <p className="font-bold text-sm dark:text-white">{todo.title}</p>
                                                                        <p className="text-xs text-gray-500 dark:text-gray-400">{todo.dueDate ? new Date(todo.dueDate).toLocaleDateString('de-DE') : 'Kein Datum'}</p>
                                                                    </div>
                                                                </div>
                                                            </div>
                                                        );
                                                    })}
                                                </div>
                                            </div>
                                        )}

                                        {searchResults.events.length === 0 && searchResults.todos.length === 0 && (
                                            <div className="text-center py-12 text-gray-400">
                                                <Icon name="search" size={48} className="mx-auto mb-4 opacity-50"/>
                                                <p className="text-sm">Keine Ergebnisse gefunden</p>
                                            </div>
                                        )}
                                    </div>
                                )}
                            </div>
                        </div>
                    )}

                    {/* Backup/Restore Modal */}
                    {showBackupModal && (
                        <div className="fixed inset-0 bg-black/40 backdrop-blur-sm z-[60] flex items-center justify-center p-4">
                            <div className="bg-[#ffffff] dark:bg-[#0f0f0f] w-full max-w-md rounded-[32px] p-6 shadow-2xl slide-up">
                                <div className="flex justify-between items-center mb-6">
                                    <h3 className="text-xl font-bold dark:text-white">Backup & Restore</h3>
                                    <button onClick={() => setShowBackupModal(false)} className="p-2 bg-gray-50 dark:bg-[#1a1a1a] rounded-full text-gray-400"><Icon name="x" size={20}/></button>
                                </div>
                                
                                <div className="space-y-4">
                                    <div className="bg-blue-50 dark:bg-blue-900/20 rounded-2xl p-4">
                                        <p className="text-sm text-blue-900 dark:text-blue-200 mb-3">
                                            <strong>Backup:</strong> Exportiert alle Ihre Kalender, Termine, TODOs und Kategorien als JSON-Datei.
                                        </p>
                                        <button onClick={exportBackup} className="w-full py-3 bg-blue-500 text-white rounded-xl font-bold hover:bg-blue-600 transition-all">
                                            ðŸ“¥ Backup Exportieren
                                        </button>
                                    </div>

                                    <div className="bg-orange-50 dark:bg-orange-900/20 rounded-2xl p-4">
                                        <p className="text-sm text-orange-900 dark:text-orange-200 mb-3">
                                            <strong>Restore:</strong> Importiert Kategorien aus einer Backup-Datei. (Nur Kategorien werden wiederhergestellt)
                                        </p>
                                        <label className="block w-full py-3 bg-orange-500 text-white rounded-xl font-bold text-center cursor-pointer hover:bg-orange-600 transition-all">
                                            ðŸ“¤ Backup Importieren
                                            <input type="file" accept=".json" className="hidden" onChange={(e) => { if(e.target.files[0]) importBackup(e.target.files[0]); }} />
                                        </label>
                                    </div>

                                    <button onClick={() => setShowBackupModal(false)} className="w-full py-3 text-gray-500 dark:text-gray-400 font-bold">
                                        Abbrechen
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Add Friend - REMAINS FOR GLOBAL SEARCH IF NEEDED, BUT MEMBER ADD IS NOW IN CALENDAR SETTINGS */}
                    {showSearchModal && <div className="fixed inset-0 bg-black/40 backdrop-blur-sm z-[60] flex items-center justify-center p-4"><div className="bg-[#ffffff] dark:bg-[#0f0f0f] w-full max-w-sm rounded-[32px] p-6 shadow-2xl slide-up"><h3 className="text-lg font-bold mb-4 dark:text-white">Freund +</h3><input className="w-full bg-gray-50 dark:bg-[#1a1a1a] dark:text-[#e8ecf5] p-4 rounded-xl mb-4 font-bold outline-none" placeholder="Username" value={searchName} onChange={e => setSearchName(e.target.value)} /><button onClick={()=>{}} className="w-full py-3 bg-black dark:bgwhite dark:text-black text-white rounded-xl font-bold mb-2">HinzufÃ¼gen</button><button onClick={()=>setShowSearchModal(false)} className="w-full py-3 text-gray-400 text-sm font-bold">Abbrechen</button></div></div>}

                    {/* Conflict Detection Modal */}
                    {showConflictModal && conflictData && (
                        <div className="fixed inset-0 bg-black/40 backdrop-blur-sm z-[60] flex items-center justify-center p-4">
                            <div className="bg-[#ffffff] dark:bg-[#0f0f0f] w-full max-w-md rounded-[32px] p-6 shadow-2xl slide-up">
                                <h3 className="text-xl font-bold mb-4 dark:text-[#e8ecf5] text-red-500">âš ï¸ Zeitkonflikt erkannt!</h3>
                                <p className="text-sm text-gray-600 dark:text-gray-400 mb-4">
                                    {conflictData.conflicts.length} Ã¼berlappende(s) Event(s) gefunden:
                                </p>
                                <div className="space-y-2 mb-6 max-h-48 overflow-y-auto">
                                    {conflictData.conflicts.map(ev => (
                                        <div key={ev.id} className="p-3 bg-red-50 dark:bg-red-900/20 rounded-xl">
                                            <div className="font-bold text-sm dark:text-white">{ev.title}</div>
                                            <div className="text-xs text-gray-500 dark:text-gray-400">
                                                {ev.date instanceof Date ? ev.date.toLocaleTimeString('de-DE', {hour: '2-digit', minute: '2-digit'}) : new Date(ev.date.toDate()).toLocaleTimeString('de-DE', {hour: '2-digit', minute: '2-digit'})}
                                                {' - '}
                                                {(() => {
                                                    const start = ev.date instanceof Date ? new Date(ev.date) : new Date(ev.date.toDate());
                                                    const end = new Date(start.getTime() + (ev.durationMin || 60) * 60000);
                                                    return end.toLocaleTimeString('de-DE', {hour: '2-digit', minute: '2-digit'});
                                                })()}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                                {conflictData.suggestedTime && (
                                    <div className="mb-4 p-4 bg-blue-50 dark:bg-blue-900/20 rounded-xl">
                                        <div className="text-sm font-bold text-blue-600 dark:text-blue-400 mb-2">ðŸ’¡ NÃ¤chster freier Slot:</div>
                                        <div className="text-lg font-bold dark:text-white">{conflictData.suggestedTime} Uhr</div>
                                    </div>
                                )}
                                <div className="flex flex-col gap-2">
                                    {conflictData.suggestedTime && (
                                        <button 
                                            onClick={() => handleConflictResolution(true)} 
                                            className="w-full py-3 bg-blue-500 text-white rounded-xl font-bold"
                                        >
                                            Vorgeschlagene Zeit verwenden
                                        </button>
                                    )}
                                    <button 
                                        onClick={() => handleConflictResolution(false)} 
                                        className="w-full py-3 bg-orange-500 text-white rounded-xl font-bold"
                                    >
                                        Trotzdem speichern
                                    </button>
                                    <button 
                                        onClick={() => {setShowConflictModal(false); setConflictData(null);}} 
                                        className="w-full py-3 text-gray-400 text-sm font-bold"
                                    >
                                        Abbrechen
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Habits Modal */}
                    {showHabitsModal && (
                        <div className="fixed inset-0 bg-[#f8f9fb] dark:bg-[#000000] z-50 flex flex-col slide-up">
                            <div className="px-6 py-6 border-b border-[#e2e8f0] dark:border-[#1f1f1f] flex justify-between items-center bg-[#f8f9fb] dark:bg-[#000000] sticky top-0">
                                <h2 className="text-2xl font-bold dark:text-white">ðŸŽ¯ Habit Tracker</h2>
                                <button onClick={() => setShowHabitsModal(false)} className="p-2 bg-gray-100 dark:bg-[#0f0f0f] dark:text-[#e8ecf5] rounded-full"><Icon name="x" size={24}/></button>
                            </div>
                            <div className="p-6 flex-1 overflow-y-auto bg-[#F8F9FA] dark:bg-[#000000]">
                                {/* New Habit Form */}
                                <div className="bg-[#ffffff] dark:bg-[#0f0f0f] rounded-[32px] p-6 mb-6 shadow-sm">
                                    <h3 className="text-lg font-bold dark:text-[#e8ecf5] mb-4">Neues Habit</h3>
                                    <div className="flex gap-2">
                                        <input 
                                            className="flex-1 bg-gray-50 dark:bg-[#1a1a1a] dark:text-[#e8ecf5] rounded-2xl p-4 font-bold outline-none" 
                                            placeholder="Habit Name"
                                            onKeyPress={e => {
                                                if (e.key === 'Enter') {
                                                    createHabit(e.target.value);
                                                    e.target.value = '';
                                                }
                                            }}
                                        />
                                        <button 
                                            onClick={e => {
                                                const input = e.target.parentElement.querySelector('input');
                                                if (input.value.trim()) {
                                                    createHabit(input.value);
                                                    input.value = '';
                                                }
                                            }}
                                            className="px-6 bg-[#2563eb] hover:bg-[#1d4ed8] dark:bg-[#4da3ff] dark:hover:bg-[#3b8fe7] text-white dark:text-[#000000] transition-colors rounded-2xl font-bold"
                                        >
                                            <Icon name="plus" size={20}/>
                                        </button>
                                    </div>
                                </div>

                                {/* Habits List */}
                                <div className="space-y-3">
                                    <div className="flex justify-between items-center mb-4">
                                        <h3 className="text-sm font-bold uppercase text-gray-400">Meine Habits</h3>
                                        <div className="text-xs text-gray-400">Fokus heute: {focusStats.todayMinutes}min | Woche: {focusStats.weekMinutes}min</div>
                                    </div>
                                    {habits.length === 0 ? (
                                        <div className="text-center py-8 opacity-50 border-2 border-dashed dark:border-[#1f1f1f] rounded-3xl text-sm dark:text-gray-400">Keine Habits</div>
                                    ) : habits.map(habit => {
                                        const today = new Date();
                                        today.setHours(0, 0, 0, 0);
                                        const isLoggedToday = habitLogs.some(log => {
                                            const logDate = log.date instanceof Date ? new Date(log.date) : new Date(log.date.toDate());
                                            logDate.setHours(0, 0, 0, 0);
                                            return log.habitId === habit.id && logDate.getTime() === today.getTime();
                                        });
                                        const streak = habitStreaks[habit.id] || 0;
                                        
                                        // Get last 7 days logs
                                        const last7Days = [];
                                        for (let i = 6; i >= 0; i--) {
                                            const d = new Date(today);
                                            d.setDate(today.getDate() - i);
                                            const hasLog = habitLogs.some(log => {
                                                const logDate = log.date instanceof Date ? new Date(log.date) : new Date(log.date.toDate());
                                                logDate.setHours(0, 0, 0, 0);
                                                return log.habitId === habit.id && logDate.getTime() === d.getTime();
                                            });
                                            last7Days.push({ date: d, hasLog });
                                        }
                                        
                                        return (
                                            <div key={habit.id} className="bg-[#ffffff] dark:bg-[#0f0f0f] rounded-3xl p-5 shadow-sm">
                                                <div className="flex items-start justify-between mb-3">
                                                    <div className="flex-1">
                                                        <h4 className="font-bold text-lg dark:text-[#e8ecf5] flex items-center gap-2">
                                                            {habit.emoji && <span>{habit.emoji}</span>}
                                                            {habit.name}
                                                        </h4>
                                                        <div className="text-sm text-gray-500 dark:text-gray-400 mt-1">
                                                            ðŸ”¥ Streak: {streak} Tag{streak !== 1 ? 'e' : ''}
                                                        </div>
                                                    </div>
                                                    <div className="flex gap-2">
                                                        <button 
                                                            onClick={() => logHabit(habit.id)} 
                                                            className={`p-3 rounded-xl font-bold text-sm ${isLoggedToday ? 'bg-green-500 text-white' : 'bg-gray-100 dark:bg-[#1a1a1a] text-gray-600 dark:text-gray-400'}`}
                                                        >
                                                            {isLoggedToday ? 'âœ“' : 'â—‹'}
                                                        </button>
                                                        <button onClick={() => deleteHabit(habit.id)} className="p-2 text-gray-400 hover:text-red-500">
                                                            <Icon name="trash" size={16}/>
                                                        </button>
                                                    </div>
                                                </div>
                                                
                                                {/* Last 7 days visualization */}
                                                <div className="flex gap-1 mt-3">
                                                    {last7Days.map((day, idx) => (
                                                        <div 
                                                            key={idx} 
                                                            className={`flex-1 h-8 rounded ${day.hasLog ? 'bg-green-500' : 'bg-gray-200 dark:bg-gray-700'}`}
                                                            title={day.date.toLocaleDateString('de-DE')}
                                                        />
                                                    ))}
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Templates Modal */}
                    {showTemplatesModal && (
                        <div className="fixed inset-0 bg-[#f8f9fb] dark:bg-[#000000] z-50 flex flex-col slide-up">
                            <div className="px-6 py-6 border-b border-[#e2e8f0] dark:border-[#1f1f1f] flex justify-between items-center bg-[#f8f9fb] dark:bg-[#000000] sticky top-0">
                                <h2 className="text-2xl font-bold dark:text-white">ðŸ“‹ Kalender Templates</h2>
                                <button onClick={() => setShowTemplatesModal(false)} className="p-2 bg-gray-100 dark:bg-[#0f0f0f] dark:text-[#e8ecf5] rounded-full"><Icon name="x" size={24}/></button>
                            </div>
                            <div className="p-6 flex-1 overflow-y-auto bg-[#F8F9FA] dark:bg-[#000000]">
                                <div className="space-y-3">
                                    {templates.map(template => (
                                        <div key={template.id} className="bg-[#ffffff] dark:bg-[#0f0f0f] rounded-3xl p-5 shadow-sm">
                                            <h4 className="font-bold text-lg dark:text-[#e8ecf5] mb-2">{template.name}</h4>
                                            <p className="text-sm text-gray-600 dark:text-gray-400 mb-4">
                                                {template.events.length} Events Ã¼ber {Math.max(...template.events.map(e => e.dayOffset)) + 1} Tage
                                            </p>
                                            <button 
                                                onClick={() => {
                                                    applyTemplate(template, selectedDate);
                                                    setShowTemplatesModal(false);
                                                }}
                                                className="w-full py-3 bg-blue-500 text-white rounded-xl font-bold"
                                            >
                                                Anwenden ab {selectedDate.toLocaleDateString('de-DE')}
                                            </button>
                                        </div>
                                    ))}
                                </div>
                                
                                {/* Copy Day Schedule */}
                                <div className="bg-[#ffffff] dark:bg-[#0f0f0f] rounded-3xl p-5 shadow-sm mt-6">
                                    <h4 className="font-bold text-lg dark:text-[#e8ecf5] mb-4">ðŸ“… Tagesablauf kopieren</h4>
                                    <div className="space-y-3">
                                        <div>
                                            <label className="text-xs font-bold text-gray-400 uppercase ml-1">Von Datum</label>
                                            <input 
                                                type="date" 
                                                id="copySourceDate"
                                                className="w-full bg-gray-50 dark:bg-[#1a1a1a] dark:text-[#e8ecf5] rounded-xl p-3 font-bold outline-none mt-1"
                                            />
                                        </div>
                                        <div>
                                            <label className="text-xs font-bold text-gray-400 uppercase ml-1">Zu Datum</label>
                                            <input 
                                                type="date" 
                                                id="copyTargetDate"
                                                className="w-full bg-gray-50 dark:bg-[#1a1a1a] dark:text-[#e8ecf5] rounded-xl p-3 font-bold outline-none mt-1"
                                            />
                                        </div>
                                        <button 
                                            onClick={() => {
                                                const source = document.getElementById('copySourceDate').value;
                                                const target = document.getElementById('copyTargetDate').value;
                                                if (source && target) {
                                                    copyDaySchedule(new Date(source), new Date(target));
                                                } else {
                                                    showToast("Bitte beide Daten auswÃ¤hlen");
                                                }
                                            }}
                                            className="w-full py-3 bg-green-500 text-white rounded-xl font-bold"
                                        >
                                            Tagesablauf kopieren
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}

                    {showVaultPanel && (
                        <VaultPanel
                            user={user}
                            db={db}
                            userData={userData}
                            notificationsEnabled={notificationsEnabled}
                            setNotificationsEnabled={setNotificationsEnabled}
                            showToast={showToast}
                            onClose={() => setShowVaultPanel(false)}
                        />
                    )}

                    {showTimeTrackingPanel && (
                        <TimeTrackingPanel
                            user={user}
                            db={db}
                            showToast={showToast}
                            onClose={() => setShowTimeTrackingPanel(false)}
                        />
                    )}

                    {toast && <div className="fixed bottom-10 left-1/2 -translate-x-1/2 bg-[#2563eb] hover:bg-[#1d4ed8] dark:bg-[#4da3ff] dark:hover:bg-[#3b8fe7] text-white dark:text-[#000000] transition-colors px-6 py-3 rounded-full text-sm font-bold shadow-xl z-[100] flex items-center gap-2 slide-up"><Icon name="check" size={16} className="text-green-400"/> {toast}</div>}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
