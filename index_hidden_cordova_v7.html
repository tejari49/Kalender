<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PlanWise Ultimate + Schichtplan</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        darkbg: '#121212',
                        darkcard: '#1E1E1E'
                    }
                }
            }
        }
    </script>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-storage-compat.js"></script>

    <style>
        /* Theme Palettes - CSS Variables */
        :root {
            /* Default Palette */
            --pw-bg: #F8F9FA;
            --pw-card: #FFFFFF;
            --pw-text: #1D1D1F;
            --pw-accent: #000000;
            --pw-accent-text: #FFFFFF;
            --pw-gray-50: #F9FAFB;
            --pw-gray-100: #F3F4F6;
            --pw-gray-400: #9CA3AF;
        }
        
        :root.dark {
            --pw-bg: #121212;
            --pw-card: #1E1E1E;
            --pw-text: #FFFFFF;
            --pw-accent: #FFFFFF;
            --pw-accent-text: #000000;
            --pw-gray-50: #2D2D2D;
            --pw-gray-100: #252525;
            --pw-gray-400: #6B7280;
        }
        
        /* Nord Palette */
        :root.palette-nord {
            --pw-bg: #ECEFF4;
            --pw-card: #E5E9F0;
            --pw-text: #2E3440;
            --pw-accent: #5E81AC;
            --pw-accent-text: #ECEFF4;
            --pw-gray-50: #D8DEE9;
            --pw-gray-100: #E5E9F0;
            --pw-gray-400: #4C566A;
        }
        
        :root.dark.palette-nord {
            --pw-bg: #2E3440;
            --pw-card: #3B4252;
            --pw-text: #ECEFF4;
            --pw-accent: #88C0D0;
            --pw-accent-text: #2E3440;
            --pw-gray-50: #434C5E;
            --pw-gray-100: #3B4252;
            --pw-gray-400: #D8DEE9;
        }
        
        /* Dracula Palette */
        :root.palette-dracula {
            --pw-bg: #F8F8F2;
            --pw-card: #FFFFFF;
            --pw-text: #282A36;
            --pw-accent: #BD93F9;
            --pw-accent-text: #F8F8F2;
            --pw-gray-50: #F8F8F2;
            --pw-gray-100: #E5E5E5;
            --pw-gray-400: #6272A4;
        }
        
        :root.dark.palette-dracula {
            --pw-bg: #282A36;
            --pw-card: #44475A;
            --pw-text: #F8F8F2;
            --pw-accent: #BD93F9;
            --pw-accent-text: #282A36;
            --pw-gray-50: #44475A;
            --pw-gray-100: #44475A;
            --pw-gray-400: #6272A4;
        }
    
        body { -webkit-tap-highlight-color: transparent; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; overscroll-behavior-y: none; }
        ::-webkit-scrollbar { width: 0; background: transparent; }
        .slide-up { animation: slideUp 0.3s cubic-bezier(0.2, 0.8, 0.2, 1); }
        .fade-in { animation: fadeIn 0.3s ease-out; }
        .scale-in { animation: scaleIn 0.2s ease-out; }
        @keyframes slideUp { from { transform: translateY(100%); } to { transform: translateY(0); } }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes scaleIn { from { transform: scale(0.9); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        
        .details-wrapper { display: grid; grid-template-rows: 0fr; transition: grid-template-rows 0.3s ease-out; }
        .details-wrapper.open { grid-template-rows: 1fr; }
        .details-inner { overflow: hidden; }
        
        /* Checkbox */
        .custom-checkbox {
            appearance: none; background-color: #f3f4f6; margin: 0; color: currentColor; width: 1.25em; height: 1.25em;
            border: 2px solid #ddd; border-radius: 0.35em; display: grid; place-content: center; transition: all 0.2s;
        }
        .dark .custom-checkbox { background-color: #2D2D2D; border-color: #444; }
        .custom-checkbox::before {
            content: ""; width: 0.65em; height: 0.65em; transform: scale(0); transition: 120ms transform;
            box-shadow: inset 1em 1em white; transform-origin: center;
            clip-path: polygon(14% 44%, 0 65%, 50% 100%, 100% 16%, 80% 0%, 43% 62%);
        }
        .custom-checkbox:checked { background-color: black; border-color: black; }
        .dark .custom-checkbox:checked { background-color: white; border-color: white; }
        .custom-checkbox:checked::before { transform: scale(1); }
        .dark .custom-checkbox:checked::before { box-shadow: inset 1em 1em black; }
        
        .no-select { user-select: none; }
    
        /* Attention blink (today) */
        .blink-attn { position: relative; }
        .blink-attn::after{
            content:"";
            position:absolute;
            inset:-5px;
            border-radius: 18px;
            border: 2px solid currentColor;
            opacity:0;
            pointer-events:none;
            animation: pwBlinkRing 1s ease-in-out infinite;
        }
        @keyframes pwBlinkRing{
            0%,100%{ opacity:0; transform: scale(0.98); }
            50%{ opacity:0.45; transform: scale(1.04); }
        }
        
        /* Drag and Drop */
        .event-draggable {
            cursor: move;
        }
        .event-dragging {
            opacity: 0.5;
        }
        .drop-target {
            background-color: rgba(59, 130, 246, 0.1);
            border: 2px dashed #3B82F6;
        }
            
    </style>
</head>
<body class="bg-[#F8F9FA] text-[#1D1D1F] dark:bg-[#121212] dark:text-white transition-colors duration-300">

    <div id="loading" class="fixed inset-0 flex items-center justify-center bg-white dark:bg-[#121212] z-50">
        <div className="text-center">
            <div class="w-12 h-12 border-4 border-gray-200 border-t-black dark:border-gray-800 dark:border-t-white rounded-full animate-spin mb-4 mx-auto"></div>
            <p class="text-sm font-bold text-gray-400 uppercase tracking-widest">Lade...</p>
        </div>
    </div>

    <div id="root"></div>

    <script>
        window.onerror = function(msg, url, line) {
            document.getElementById('loading').style.display = 'none';
            console.error(msg);
        };
    </script>

    <script type="text/babel">
        // --- ICONS ---
        const Icon = ({ name, size = 20, className = "" }) => {
            const icons = {
                chevronLeft: <path d="M15 18l-6-6 6-6" />,
                chevronRight: <path d="M9 18l6-6-6-6" />,
                chevronDown: <path d="M6 9l6 6 6-6" />,
                plus: <path d="M12 5v14M5 12h14" />,
                x: <path d="M18 6L6 18M6 6l12 12" />,
                trash: <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2" />,
                check: <path d="M20 6L9 17l-5-5" />,
                bell: <path d="M18 8A6 6 0 006 8c0 7-3 9-3 9h18s-3-2-3-9" />,
                settings: <path d="M12.22 2h-.44a2 2 0 00-2 2v.18a2 2 0 01-1 1.73l-.43.25a2 2 0 01-2 0l-.18-.08a2 2 0 00-2 2v.44a2 2 0 002 2h.18a2 2 0 011.73 1l.25.43a2 2 0 010 2l-.08.18a2 2 0 00-2-2z" />,
                calendar: <path d="M19 4H5a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2V6a2 2 0 00-2-2zm-1-2v4M6 2v4m-4 6h20" />,
                sun: <path d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M12 7a5 5 0 110 10 5 5 0 010-10z" />,
                moon: <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z" />,
                send: <path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z" />,
                image: <><rect x="3" y="3" width="18" height="18" rx="2" ry="2" /><circle cx="8.5" cy="8.5" r="1.5" /><path d="M21 15l-5-5L5 21" /></>,
                camera: <><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h3l2-3h8l2 3h3a2 2 0 0 1 2 2z" /><circle cx="12" cy="13" r="4" /></>,
                mic: <><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z" /><path d="M19 10v2a7 7 0 0 1-14 0v-2" /><line x1="12" y1="19" x2="12" y2="23" /><line x1="8" y1="23" x2="16" y2="23" /></>,
                play: <polygon points="5 3 19 12 5 21 5 3" />,
                pause: <><rect x="6" y="4" width="4" height="16" /><rect x="14" y="4" width="4" height="16" /></>,
                stop: <rect x="7" y="7" width="10" height="10" rx="2" />, 
                search: <path d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />,
                lock: <path d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a7 7 0 00-14 0v2" />,
                user: <path d="M20 21v-2a4 4 0 00-4-4H8a4 4 0 00-4 4v2M12 11a4 4 0 100-8 4 4 0 000 8z" />,
                alignLeft: <path d="M17 10H3M21 6H3M21 14H3M17 18H3" />,
                clock: <><circle cx="12" cy="12" r="10" /><polyline points="12 6 12 12 16 14" /></>,
                repeat: <><path d="M17 1l4 4-4 4" /><path d="M3 11V9a4 4 0 014-4h14" /><path d="M7 23l-4-4 4-4" /><path d="M21 13v2a4 4 0 01-4 4H3" /></>,
                layers: <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5" />,
                tag: <><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z" /><line x1="7" y1="7" x2="7.01" y2="7" /></>,
                briefcase: <><rect x="2" y="7" width="20" height="14" rx="2" ry="2" /><path d="M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16" /></>,
                target: <><circle cx="12" cy="12" r="10" /><circle cx="12" cy="12" r="6" /><circle cx="12" cy="12" r="2" /></>
            };
            return (
                <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                    {icons[name] || <circle cx="12" cy="12" r="10" />}
                </svg>
            );
        };

        // --- FIREBASE CONFIG ---
        const firebaseConfig = {
            apiKey: "AIzaSyAI4AlNcXHBVnlJtqBRl_4vmNvDEghpk88",
            authDomain: "planwise-cr.firebaseapp.com",
            projectId: "planwise-cr",
            storageBucket: "planwise-cr.appspot.com",
            messagingSenderId: "567060346362",
            appId: "1:567060346362:web:aa034bea9c41274b512043",
            measurementId: "G-30SGGBT9BY"
        };

        if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
        const storage = firebase.storage();

        // --- CONSTANTS ---
        const { useState, useEffect, useRef } = React;
        const ALL_CALENDARS = 'ALL';
        const ROLES = { ADMIN: 'admin', EDITOR: 'editor', VIEWER: 'viewer' };
        
        const CALENDAR_COLORS = [
            { name: 'Orange', hex: '#F97316', bg: 'bg-orange-500', light: 'bg-orange-50 dark:bg-orange-900/30', text: 'text-orange-500' },
            { name: 'Blue', hex: '#3B82F6', bg: 'bg-blue-500', light: 'bg-blue-50 dark:bg-blue-900/30', text: 'text-blue-500' },
            { name: 'Green', hex: '#22C55E', bg: 'bg-green-500', light: 'bg-green-50 dark:bg-green-900/30', text: 'text-green-500' },
            { name: 'Purple', hex: '#A855F7', bg: 'bg-purple-500', light: 'bg-purple-50 dark:bg-purple-900/30', text: 'text-purple-500' },
            { name: 'Red', hex: '#EF4444', bg: 'bg-red-500', light: 'bg-red-50 dark:bg-red-900/30', text: 'text-red-500' },
        ];
        
        const DEFAULT_CATEGORIES = {
            'Arbeit': ['Meeting', 'Deadline', 'Home Office', 'Call'],
            'Privat': ['Hobby', 'Date', 'Urlaub', 'Freunde'],
            'Haushalt': ['Einkaufen', 'Putzen', 'Kochen'],
            'Gesundheit': ['Arzt', 'Sport', 'Zahnarzt'],
            'Wichtig': ['Erinnerung', 'BehÃ¶rde', 'Frist']
        };

        // --- EMOJI PRESETS ---
        const EMOJI_PRESETS = ['ðŸ“…', 'ðŸ’¼', 'ðŸŽ‰', 'ðŸ‹ï¸', 'ðŸ”', 'ðŸš—', 'âœˆï¸', 'ðŸ ', 'ðŸ“š', 'ðŸ’»', 'ðŸŽµ', 'ðŸŽ¨', 'âš½', 'ðŸŽ¬', 'â˜•', 'ðŸ•', 'ðŸŽ®', 'ðŸ“±', 'ðŸ’Š', 'ðŸ›’'];

        // --- QUICK-ADD PARSER (German Natural Language) ---
        const parseQuickAdd = (text) => {
            const result = { date: null, time: null, durationMin: 60, title: '', category: null };
            
            const lowerText = text.toLowerCase();
            const today = new Date();
            
            // Parse date keywords
            if (lowerText.includes('heute')) {
                result.date = new Date(today);
            } else if (lowerText.includes('morgen')) {
                result.date = new Date(today);
                result.date.setDate(result.date.getDate() + 1);
            } else if (lowerText.includes('Ã¼bermorgen') || lowerText.includes('uebermorgen')) {
                result.date = new Date(today);
                result.date.setDate(result.date.getDate() + 2);
            } else {
                // Check for weekdays
                const weekdays = {
                    'montag': 1, 'mo': 1,
                    'dienstag': 2, 'di': 2,
                    'mittwoch': 3, 'mi': 3,
                    'donnerstag': 4, 'do': 4,
                    'freitag': 5, 'fr': 5,
                    'samstag': 6, 'sa': 6,
                    'sonntag': 0, 'so': 0
                };
                
                for (const [day, targetDay] of Object.entries(weekdays)) {
                    if (lowerText.includes(day)) {
                        result.date = new Date(today);
                        const currentDay = result.date.getDay();
                        let diff = targetDay - currentDay;
                        if (diff <= 0) diff += 7;
                        result.date.setDate(result.date.getDate() + diff);
                        break;
                    }
                }
            }
            
            // If no date found, use today
            if (!result.date) result.date = new Date(today);
            
            // Parse time: 15, 15:30, 15 uhr, 15.30
            const timePatterns = [
                /(\d{1,2}):(\d{2})/,  // 15:30
                /(\d{1,2})\.(\d{2})/,  // 15.30
                /(\d{1,2})\s*uhr/i,    // 15 uhr
                /\b(\d{1,2})\b(?!\d)/  // 15 (standalone number)
            ];
            
            let timeMatch = null;
            for (const pattern of timePatterns) {
                timeMatch = text.match(pattern);
                if (timeMatch) break;
            }
            
            if (timeMatch) {
                const hour = parseInt(timeMatch[1]);
                const minute = timeMatch[2] ? parseInt(timeMatch[2]) : 0;
                if (hour >= 0 && hour < 24 && minute >= 0 && minute < 60) {
                    result.time = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
                }
            }
            
            // Parse duration: 90min, 1h, 2h, 30min
            const durationMatch = text.match(/(\d+)\s*(min|h)/i);
            if (durationMatch) {
                const value = parseInt(durationMatch[1]);
                const unit = durationMatch[2].toLowerCase();
                if (unit === 'h') {
                    result.durationMin = value * 60;
                } else {
                    result.durationMin = value;
                }
            }
            
            // Extract title (remove parsed tokens)
            let title = text;
            title = title.replace(/heute|morgen|Ã¼bermorgen|uebermorgen/gi, '');
            title = title.replace(/montag|dienstag|mittwoch|donnerstag|freitag|samstag|sonntag/gi, '');
            title = title.replace(/mo|di|mi|do|fr|sa|so\b/gi, '');
            title = title.replace(/\d{1,2}:\d{2}/g, '');
            title = title.replace(/\d{1,2}\.\d{2}/g, '');
            title = title.replace(/\d{1,2}\s*uhr/gi, '');
            title = title.replace(/\d+\s*(min|h)/gi, '');
            result.title = title.replace(/\s+/g, ' ').trim();
            
            // Heuristic category assignment
            const categoryKeywords = {
                'Gesundheit': ['arzt', 'zahnarzt', 'sport', 'fitness', 'training', 'gym'],
                'Arbeit': ['meeting', 'call', 'besprechung', 'termin', 'deadline', 'projekt'],
                'Haushalt': ['einkaufen', 'putzen', 'kochen', 'waschen'],
                'Privat': ['freunde', 'date', 'hobby', 'urlaub']
            };
            
            for (const [cat, keywords] of Object.entries(categoryKeywords)) {
                for (const keyword of keywords) {
                    if (lowerText.includes(keyword)) {
                        result.category = cat;
                        break;
                    }
                }
                if (result.category) break;
            }
            
            return result;
        };

        // --- CONFLICT DETECTION ---
        const checkEventConflicts = (events, newEvent, excludeId = null) => {
            const conflicts = [];
            const newStart = newEvent.date;
            const newEnd = new Date(newStart.getTime() + (newEvent.durationMin || 60) * 60000);
            
            for (const ev of events) {
                if (ev.id === excludeId || ev.type === 'shift') continue;
                if (!ev.date) continue;
                
                const evStart = ev.date instanceof Date ? ev.date : ev.date.toDate();
                const evEnd = new Date(evStart.getTime() + (ev.durationMin || 60) * 60000);
                
                // Check if same day
                if (evStart.toDateString() !== newStart.toDateString()) continue;
                
                // Check overlap
                if (newStart < evEnd && newEnd > evStart) {
                    conflicts.push(ev);
                }
            }
            
            return conflicts;
        };

        // --- SUGGEST NEXT FREE SLOT ---
        const suggestNextFreeSlot = (events, date, durationMin = 60, startHour = 8, endHour = 18) => {
            const workStart = startHour * 60; // in minutes
            const workEnd = endHour * 60;
            
            // Get all events on this day, sorted by time
            const dayEvents = events.filter(ev => {
                if (!ev.date || ev.type === 'shift') return false;
                const evDate = ev.date instanceof Date ? ev.date : ev.date.toDate();
                return evDate.toDateString() === date.toDateString();
            }).sort((a, b) => {
                const aDate = a.date instanceof Date ? a.date : a.date.toDate();
                const bDate = b.date instanceof Date ? b.date : b.date.toDate();
                return aDate - bDate;
            });
            
            // Convert to time slots in minutes
            const busySlots = dayEvents.map(ev => {
                const evDate = ev.date instanceof Date ? ev.date : ev.date.toDate();
                const startMin = evDate.getHours() * 60 + evDate.getMinutes();
                const endMin = startMin + (ev.durationMin || 60);
                return { start: startMin, end: endMin };
            });
            
            // Find first free slot
            let currentMin = workStart;
            for (const slot of busySlots) {
                if (currentMin + durationMin <= slot.start) {
                    // Found a free slot
                    const hour = Math.floor(currentMin / 60);
                    const min = currentMin % 60;
                    return `${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}`;
                }
                currentMin = Math.max(currentMin, slot.end);
            }
            
            // Check if there's space at the end
            if (currentMin + durationMin <= workEnd) {
                const hour = Math.floor(currentMin / 60);
                const min = currentMin % 60;
                return `${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}`;
            }
            
            return null; // No free slot found
        };

        // --- SMART SUGGESTIONS (3 free slots based on calendar + history) ---
        const generateSmartSuggestions = (events, date, durationMin = 60) => {
            // Calculate historical frequency (which hours are most commonly used)
            const hourFrequency = new Array(24).fill(0);
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - 30); // Last 30 days
            
            events.forEach(ev => {
                if (!ev.date || ev.type === 'shift') return;
                const evDate = ev.date instanceof Date ? ev.date : ev.date.toDate();
                if (evDate < cutoffDate) return;
                hourFrequency[evDate.getHours()]++;
            });
            
            // Get free slots
            const freeSlots = [];
            for (let hour = 8; hour < 18; hour++) {
                for (let min = 0; min < 60; min += 30) {
                    const testTime = `${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}`;
                    const testDate = new Date(date);
                    testDate.setHours(hour, min, 0, 0);
                    
                    const testEvent = { date: testDate, durationMin };
                    const conflicts = checkEventConflicts(events, testEvent);
                    
                    if (conflicts.length === 0) {
                        freeSlots.push({
                            time: testTime,
                            score: hourFrequency[hour] + (min === 0 ? 1 : 0) // Prefer full hours
                        });
                    }
                }
            }
            
            // Sort by score and return top 3
            freeSlots.sort((a, b) => b.score - a.score);
            return freeSlots.slice(0, 3).map(s => s.time);
        };

        // --- CALENDAR TEMPLATES ---
        const CALENDAR_TEMPLATES = {
            'workout': {
                name: 'Workout-Woche',
                events: [
                    { day: 0, time: '07:00', title: 'Morgenlauf', durationMin: 45, category: 'Gesundheit', emoji: 'ðŸ‹ï¸' },
                    { day: 1, time: '18:00', title: 'Gym', durationMin: 90, category: 'Gesundheit', emoji: 'ðŸ’ª' },
                    { day: 2, time: '07:00', title: 'Yoga', durationMin: 60, category: 'Gesundheit', emoji: 'ðŸ§˜' },
                    { day: 3, time: '18:00', title: 'Gym', durationMin: 90, category: 'Gesundheit', emoji: 'ðŸ’ª' },
                    { day: 4, time: '07:00', title: 'Morgenlauf', durationMin: 45, category: 'Gesundheit', emoji: 'ðŸ‹ï¸' },
                    { day: 5, time: '18:00', title: 'Gym', durationMin: 90, category: 'Gesundheit', emoji: 'ðŸ’ª' }
                ]
            },
            'sprint': {
                name: 'Projekt-Sprint',
                events: [
                    { day: 0, time: '09:00', title: 'Sprint Planning', durationMin: 120, category: 'Arbeit', emoji: 'ðŸ“‹' },
                    { day: 1, time: '09:00', title: 'Daily Standup', durationMin: 15, category: 'Arbeit', emoji: 'ðŸ’¬' },
                    { day: 1, time: '14:00', title: 'Development', durationMin: 240, category: 'Arbeit', emoji: 'ðŸ’»' },
                    { day: 2, time: '09:00', title: 'Daily Standup', durationMin: 15, category: 'Arbeit', emoji: 'ðŸ’¬' },
                    { day: 2, time: '14:00', title: 'Development', durationMin: 240, category: 'Arbeit', emoji: 'ðŸ’»' },
                    { day: 3, time: '09:00', title: 'Daily Standup', durationMin: 15, category: 'Arbeit', emoji: 'ðŸ’¬' },
                    { day: 3, time: '14:00', title: 'Development', durationMin: 240, category: 'Arbeit', emoji: 'ðŸ’»' },
                    { day: 4, time: '09:00', title: 'Sprint Review', durationMin: 90, category: 'Arbeit', emoji: 'ðŸŽ¯' },
                    { day: 4, time: '14:00', title: 'Sprint Retro', durationMin: 60, category: 'Arbeit', emoji: 'ðŸ”„' }
                ]
            }
        };

        // --- ARCHIV HELPERS ---
        const generateSecretId = () => {
            // 10 Zeichen, ohne leicht verwechselbare Zeichen (0/O, 1/I, etc.)
            const alphabet = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let out = '';
            for (let i = 0; i < 10; i++) out += alphabet[Math.floor(Math.random() * alphabet.length)];
            return out;
        };

        const bytesToBase64 = (bytes) => {
            let bin = '';
            bytes.forEach(b => bin += String.fromCharCode(b));
            return btoa(bin);
        };

        const base64ToBytes = (b64) => {
            const bin = atob(b64);
            const bytes = new Uint8Array(bin.length);
            for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
            return bytes;
        };

        const canUseSecretCrypto = () => {
            return !!(window.crypto && window.crypto.subtle);
        };

        // --- AUTH SCREEN ---
        const AuthScreen = ({ onLoginSuccess, onDemoStart }) => {
            const [isRegister, setIsRegister] = useState(false);
            const [email, setEmail] = useState('');
            const [password, setPassword] = useState('');
            const [username, setUsername] = useState('');
            const [error, setError] = useState('');
            const [loading, setLoading] = useState(false);

            const handleAuth = async (e) => {
                e.preventDefault(); setError(''); setLoading(true);
                try {
                    if (isRegister) {
                        if (!/^[a-zA-Z0-9]+$/.test(username) || username.length < 3) throw new Error("Benutzername ungÃ¼ltig.");
                        const snapshot = await db.collection('users').where('username', '==', username).get();
                        if (!snapshot.empty) throw new Error("Name vergeben.");
                        const cred = await auth.createUserWithEmailAndPassword(email, password);
                        await cred.user.updateProfile({ displayName: username });
                        await db.collection('users').doc(cred.user.uid).set({
                            username,
                            displayName: username,
                            email,
                            uid: cred.user.uid,
                            secretId: generateSecretId(),
                            avatarColor: '#1D1D1F',
                            categories: DEFAULT_CATEGORIES,
                            createdAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    } else { await auth.signInWithEmailAndPassword(email, password); }
                    onLoginSuccess();
                } catch (err) { setError(err.message.replace('Firebase:', '').trim()); } finally { setLoading(false); }
            };

            return (
                <div className="min-h-screen flex items-center justify-center p-6 bg-white dark:bg-[#121212]">
                    <div className="w-full max-w-sm fade-in">
                        <div className="mb-10 text-center">
                            <h1 className="text-4xl font-bold tracking-tighter mb-2 dark:text-white">PlanWise</h1>
                            <p className="text-gray-400 text-sm uppercase tracking-widest">Ultimate</p>
                        </div>
                        <form onSubmit={handleAuth} className="space-y-4">
                            {error && <div className="bg-red-50 text-red-500 text-xs p-3 rounded-xl text-center">{error}</div>}
                            {isRegister && <input className="w-full bg-gray-50 dark:bg-[#1E1E1E] dark:text-white p-4 rounded-2xl outline-none" placeholder="Benutzername" value={username} onChange={e => setUsername(e.target.value)} />}
                            <input type="email" className="w-full bg-gray-50 dark:bg-[#1E1E1E] dark:text-white p-4 rounded-2xl outline-none" placeholder="Email" value={email} onChange={e => setEmail(e.target.value)} />
                            <input type="password" className="w-full bg-gray-50 dark:bg-[#1E1E1E] dark:text-white p-4 rounded-2xl outline-none" placeholder="Passwort" value={password} onChange={e => setPassword(e.target.value)} />
                            <button disabled={loading} className="w-full bg-black dark:bg-white dark:text-black text-white py-4 rounded-2xl font-bold">{loading ? '...' : (isRegister ? 'Registrieren' : 'Einloggen')}</button>
                        </form>
                        <div className="mt-6 text-center space-y-4">
                            <button onClick={() => setIsRegister(!isRegister)} className="text-sm font-medium text-gray-500 dark:hover:text-white">{isRegister ? 'Login' : 'Registrieren'}</button>
                            <div className="border-t border-gray-100 dark:border-gray-800 pt-4"><button onClick={onDemoStart} className="text-xs font-bold text-gray-400 hover:text-black dark:hover:text-white">Demo</button></div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- ARCHIV (E2EE via WebCrypto + Firestore) ---
        const VaultPanel = ({ user, db, userData, onClose, notificationsEnabled, setNotificationsEnabled, showToast }) => {
            const [ready, setReady] = useState(false);
            const [mySecretId, setMySecretId] = useState(userData?.secretId || '');
            const [convs, setConvs] = useState([]);
            const [profiles, setProfiles] = useState({});
            const profilesRef = useRef({});
            useEffect(() => { profilesRef.current = profiles; }, [profiles]);
            const [view, setView] = useState('list'); // 'list' | 'detail'
            const [activeConvId, setActiveConvId] = useState(null);
            const [messages, setMessages] = useState([]);
            const [idInput, setIdInput] = useState('');
            const [draft, setDraft] = useState('');
            const [busy, setBusy] = useState(false);
            const libraryInputRef = useRef(null);
            const cameraInputRef = useRef(null);

            const [recOn, setRecOn] = useState(false);
            const recRef = useRef({ recorder: null, stream: null, chunks: [], startedAt: 0, mime: '', discard: false });
            const [playBusyId, setPlayBusyId] = useState(null);
            const [hiddenIds, setHiddenIds] = useState({});
            const hiddenIdsRef = useRef({});
            useEffect(() => { hiddenIdsRef.current = hiddenIds; }, [hiddenIds]);

            const [mediaOverlay, setMediaOverlay] = useState(null);
            const overlayObjectUrlRef = useRef(null);


            const listLoadedRef = useRef(false);
            const lastNotifiedRef = useRef({});
            const keyCacheRef = useRef({});
            const myPrivKeyRef = useRef(null);
            const scrollRef = useRef(null);

            const convCollection = db.collection('secretConversations');

            const shortUid = (uid) => (uid || '').slice(0, 6) + 'â€¦' + (uid || '').slice(-4);

            const makeConvId = (uids) => {
                const sorted = [...uids].sort();
                return 'sc_' + sorted.join('_');
            };

            const getOtherUid = (conv) => (conv.memberIds || []).find(x => x !== user.uid);

            const ensureSecretSetup = async () => {
                if (!canUseSecretCrypto()) {
                    showToast('Archiv: benÃ¶tigt HTTPS/localhost (WebCrypto).');
                    return false;
                }

                // Secret-ID sicherstellen (Backfill)
                try {
                    const meRef = db.collection('users').doc(user.uid);
                    const snap = await meRef.get();
                    if (snap.exists) {
                        const data = snap.data() || {};
                        if (data.secretId) setMySecretId(data.secretId);
                        else {
                            const sid = generateSecretId();
                            await meRef.update({ secretId: sid });
                            setMySecretId(sid);
                        }
                    }
                } catch (e) {}

                // ECDH Keypair lokal + PublicKey in Firestore
                try {
                    const privKeyStorage = `pw_sc_priv_${user.uid}`;
                    const pubKeyField = 'secretPubKey';
                    const stored = localStorage.getItem(privKeyStorage);

                    const importPriv = async (jwk) => {
                        return await crypto.subtle.importKey(
                            'jwk',
                            jwk,
                            { name: 'ECDH', namedCurve: 'P-256' },
                            false,
                            ['deriveKey']
                        );
                    };
                    const importPub = async (jwk) => {
                        return await crypto.subtle.importKey(
                            'jwk',
                            jwk,
                            { name: 'ECDH', namedCurve: 'P-256' },
                            true,
                            []
                        );
                    };

                    if (stored) {
                        const jwk = JSON.parse(stored);
                        myPrivKeyRef.current = await importPriv(jwk);
                    } else {
                        const kp = await crypto.subtle.generateKey(
                            { name: 'ECDH', namedCurve: 'P-256' },
                            true,
                            ['deriveKey']
                        );
                        const privJwk = await crypto.subtle.exportKey('jwk', kp.privateKey);
                        const pubJwk = await crypto.subtle.exportKey('jwk', kp.publicKey);
                        localStorage.setItem(privKeyStorage, JSON.stringify(privJwk));
                        myPrivKeyRef.current = kp.privateKey;

                        // Public Key publishen
                        await db.collection('users').doc(user.uid).update({ [pubKeyField]: pubJwk }).catch(()=>{});
                    }

                    // Falls User-Dokument PublicKey noch nicht hat: publizieren
                    const meSnap = await db.collection('users').doc(user.uid).get();
                    if (meSnap.exists) {
                        const data = meSnap.data() || {};
                        if (!data[pubKeyField]) {
                            // Re-export public key aus priv ist nicht mÃ¶glich -> regenerate pair ist Overkill.
                            // LÃ¶sung: wenn Public fehlt, generiere neues Paar.
                            const kp = await crypto.subtle.generateKey(
                                { name: 'ECDH', namedCurve: 'P-256' },
                                true,
                                ['deriveKey']
                            );
                            const privJwk = await crypto.subtle.exportKey('jwk', kp.privateKey);
                            const pubJwk = await crypto.subtle.exportKey('jwk', kp.publicKey);
                            localStorage.setItem(privKeyStorage, JSON.stringify(privJwk));
                            myPrivKeyRef.current = kp.privateKey;
                            await db.collection('users').doc(user.uid).update({ [pubKeyField]: pubJwk }).catch(()=>{});
                        }
                    }

                    setReady(true);
                    return true;
                } catch (e) {
                    showToast('Archiv: Crypto-Setup fehlgeschlagen.');
                    return false;
                }
            };

            const getSharedKey = async (otherUid) => {
                if (keyCacheRef.current[otherUid]) return keyCacheRef.current[otherUid];
                const otherSnap = await db.collection('users').doc(otherUid).get();
                if (!otherSnap.exists) throw new Error('User nicht gefunden');
                const other = otherSnap.data() || {};
                if (!other.secretPubKey) throw new Error('Gegenseite hat Archiv noch nie geÃ¶ffnet.');

                const otherPub = await crypto.subtle.importKey(
                    'jwk',
                    other.secretPubKey,
                    { name: 'ECDH', namedCurve: 'P-256' },
                    true,
                    []
                );

                if (!myPrivKeyRef.current) throw new Error('Private Key fehlt');
                const aesKey = await crypto.subtle.deriveKey(
                    { name: 'ECDH', public: otherPub },
                    myPrivKeyRef.current,
                    { name: 'AES-GCM', length: 256 },
                    false,
                    ['encrypt', 'decrypt']
                );

                keyCacheRef.current[otherUid] = aesKey;
                return aesKey;
            };

            const encryptFor = async (otherUid, plaintext) => {
                const key = await getSharedKey(otherUid);
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const enc = new TextEncoder().encode(plaintext);
                const ct = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, enc);
                return { ciphertext: bytesToBase64(new Uint8Array(ct)), iv: bytesToBase64(iv) };
            };

            const decryptFrom = async (otherUid, ciphertextB64, ivB64) => {
                const key = await getSharedKey(otherUid);
                const iv = base64ToBytes(ivB64);
                const ct = base64ToBytes(ciphertextB64);
                const pt = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, ct);
                return new TextDecoder().decode(pt);
            };


            const encryptBytesFor = async (otherUid, plainBytes) => {
                const key = await getSharedKey(otherUid);
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const ct = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, plainBytes);
                return { cipherBytes: new Uint8Array(ct), ivB64: bytesToBase64(iv) };
            };

            const decryptBytesFrom = async (otherUid, ciphertextB64, ivB64) => {
                const key = await getSharedKey(otherUid);
                const iv = base64ToBytes(ivB64);
                const ct = base64ToBytes(ciphertextB64);
                const pt = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, ct);
                return new Uint8Array(pt);
            };

            const makeThumbBlob = (file) => {
                return new Promise((resolve, reject) => {
                    try {
                        const url = URL.createObjectURL(file);
                        const img = new Image();
                        img.onload = () => {
                            try {
                                const max = 360;
                                const w = img.naturalWidth || img.width || 1;
                                const h = img.naturalHeight || img.height || 1;
                                const scale = Math.min(1, max / Math.max(w, h));
                                const tw = Math.max(1, Math.round(w * scale));
                                const th = Math.max(1, Math.round(h * scale));
                                const canvas = document.createElement('canvas');
                                canvas.width = tw;
                                canvas.height = th;
                                const ctx = canvas.getContext('2d');
                                ctx.drawImage(img, 0, 0, tw, th);
                                canvas.toBlob((blob) => {
                                    URL.revokeObjectURL(url);
                                    if (blob) resolve(blob);
                                    else reject(new Error('thumb'));
                                }, 'image/jpeg', 0.72);
                            } catch (e) {
                                URL.revokeObjectURL(url);
                                reject(e);
                            }
                        };
                        img.onerror = () => { URL.revokeObjectURL(url); reject(new Error('img')); };
                        img.src = url;
                    } catch (e) { reject(e); }
                });
            };


            const compressImageToJpeg = (fileOrBlob, maxDim = 2048, quality = 0.84) => {
                return new Promise((resolve, reject) => {
                    try {
                        const src = fileOrBlob;
                        const url = URL.createObjectURL(src);
                        const cleanup = () => { try { URL.revokeObjectURL(url); } catch(e){} };

                        const renderToCanvas = (imgLike, w0, h0) => {
                            const scale = Math.min(1, maxDim / Math.max(w0 || 1, h0 || 1));
                            const w = Math.max(1, Math.round((w0 || 1) * scale));
                            const h = Math.max(1, Math.round((h0 || 1) * scale));
                            const canvas = document.createElement('canvas');
                            canvas.width = w;
                            canvas.height = h;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(imgLike, 0, 0, w, h);
                            return { canvas, w, h };
                        };

                        const finish = (canvas, w, h) => {
                            canvas.toBlob((blob) => {
                                cleanup();
                                if (!blob) return reject(new Error('jpeg'));
                                resolve({ blob, width: w, height: h });
                            }, 'image/jpeg', quality);
                        };

                        // Prefer createImageBitmap where available (can respect EXIF orientation in some browsers)
                        if (window.createImageBitmap) {
                            const opts = {};
                            try { opts.imageOrientation = 'from-image'; } catch (e) {}
                            createImageBitmap(src, opts).then((bmp) => {
                                try {
                                    const w0 = bmp.width || 1;
                                    const h0 = bmp.height || 1;
                                    const { canvas, w, h } = renderToCanvas(bmp, w0, h0);
                                    try { bmp.close && bmp.close(); } catch(e){}
                                    finish(canvas, w, h);
                                } catch (e) {
                                    cleanup();
                                    reject(e);
                                }
                            }).catch(() => {
                                const img = new Image();
                                img.onload = () => {
                                    try {
                                        const w0 = img.naturalWidth || img.width || 1;
                                        const h0 = img.naturalHeight || img.height || 1;
                                        const { canvas, w, h } = renderToCanvas(img, w0, h0);
                                        finish(canvas, w, h);
                                    } catch (e) { cleanup(); reject(e); }
                                };
                                img.onerror = () => { cleanup(); reject(new Error('img')); };
                                img.src = url;
                            });
                            return;
                        }

                        const img = new Image();
                        img.onload = () => {
                            try {
                                const w0 = img.naturalWidth || img.width || 1;
                                const h0 = img.naturalHeight || img.height || 1;
                                const { canvas, w, h } = renderToCanvas(img, w0, h0);
                                finish(canvas, w, h);
                            } catch (e) { cleanup(); reject(e); }
                        };
                        img.onerror = () => { cleanup(); reject(new Error('img')); };
                        img.src = url;
                    } catch (e) { reject(e); }
                });
            };

            const closeMedia = () => {
                if (overlayObjectUrlRef.current) {
                    URL.revokeObjectURL(overlayObjectUrlRef.current);
                    overlayObjectUrlRef.current = null;
                }
                setMediaOverlay(null);
            };

            const openMedia = async (msg) => {
                if (!ready || !msg?.storagePath || !msg?.ivFull) return;
                const conv = convs.find(c => c.id === activeConvId);
                if (!conv) return;
                const otherUid = getOtherUid(conv);
                if (!otherUid) return;

                setMediaOverlay({ id: msg.id, mine: msg.senderId === user.uid, url: null, loading: true, msg, openedAt: Date.now() });

                try {
                    const url = await storage.ref(msg.storagePath).getDownloadURL();
                    const resp = await fetch(url);
                    const encBuf = await resp.arrayBuffer();

                    const key = await getSharedKey(otherUid);
                    const iv = base64ToBytes(msg.ivFull);
                    const pt = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, encBuf);

                    const blob = new Blob([pt], { type: msg.mime || 'image/jpeg' });
                    const objectUrl = URL.createObjectURL(blob);

                    if (overlayObjectUrlRef.current) URL.revokeObjectURL(overlayObjectUrlRef.current);
                    overlayObjectUrlRef.current = objectUrl;

                    setMediaOverlay({ id: msg.id, mine: msg.senderId === user.uid, url: objectUrl, loading: false, msg });
                } catch (e) {
                    showToast('Ã–ffnen fehlgeschlagen');
                    closeMedia();
                }
            };

            const deleteMedia = async (msg) => {
                if (!msg) return closeMedia();
                if (msg.senderId !== user.uid) return closeMedia();

                try {
                    if (msg.storagePath) {
                        await storage.ref(msg.storagePath).delete().catch(()=>{});
                    }
                    await convCollection.doc(activeConvId).collection('messages').doc(msg.id).delete();
                    showToast('GelÃ¶scht');
                } catch (e) {
                    showToast('LÃ¶schen fehlgeschlagen');
                } finally {
                    closeMedia();
                }
            };

            const requestNotifications = async () => {
                if (!('Notification' in window)) {
                    showToast('Browser unterstÃ¼tzt keine Benachrichtigungen.');
                    return;
                }
                const perm = await Notification.requestPermission();
                if (perm === 'granted') {
                    setNotificationsEnabled(true);
                    showToast('Benachrichtigungen aktiviert.');
                } else {
                    setNotificationsEnabled(false);
                    showToast('Benachrichtigungen nicht freigegeben.');
                }
            };

            const notify = (title, body) => {
                try {
                    if (!notificationsEnabled) return;
                    if (!('Notification' in window)) return;
                    if (Notification.permission !== 'granted') return;
                    new Notification(title, { body });
                } catch (e) {}
            };

            const ensureProfile = async (uid) => {
                if (!uid) return;
                if (profiles[uid]) return;
                try {
                    const snap = await db.collection('users').doc(uid).get();
                    if (snap.exists) {
                        const d = snap.data() || {};
                        setProfiles(prev => ({ ...prev, [uid]: { username: d.username || d.displayName || shortUid(uid), secretId: d.secretId || '' } }));
                    } else {
                        setProfiles(prev => ({ ...prev, [uid]: { username: shortUid(uid), secretId: '' } }));
                    }
                } catch (e) {
                    setProfiles(prev => ({ ...prev, [uid]: { username: shortUid(uid), secretId: '' } }));
                }
            };

            const connectById = async () => {
                const raw = (idInput || '').trim();
                if (!raw) return;
                if (!ready) return;

                setBusy(true);
                try {
                    const input = raw.toUpperCase();

                    // 1) via Secret-ID
                    let targetUid = null;
                    const q = await db.collection('users').where('secretId', '==', input).limit(1).get();
                    if (!q.empty) targetUid = q.docs[0].id;

                    // 2) fallback: UID direkt
                    if (!targetUid) {
                        const u = await db.collection('users').doc(raw).get();
                        if (u.exists) targetUid = u.id;
                    }

                    if (!targetUid) {
                        showToast('Kein User mit dieser ID gefunden.');
                        return;
                    }
                    if (targetUid === user.uid) {
                        showToast('Eigene ID ist nicht sinnvoll.');
                        return;
                    }

                    const convId = makeConvId([user.uid, targetUid]);
                    const ref = convCollection.doc(convId);
                    const exists = await ref.get();
                    if (!exists.exists) {
                        await ref.set({
                            memberIds: [user.uid, targetUid],
                            createdBy: user.uid,
                            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                            type: 'dm',
                            lastMessageAt: firebase.firestore.FieldValue.serverTimestamp(),
                            lastSenderId: user.uid
                        });
                    }

                    await ensureProfile(targetUid);
                    setIdInput('');
                    setActiveConvId(convId);
                    setView('detail');
                } catch (e) {
                    showToast(e.message || 'Fehler');
                } finally {
                    setBusy(false);
                }
            };

            const sendMessage = async () => {
                if (!draft.trim() || !activeConvId) return;
                const conv = convs.find(c => c.id === activeConvId);
                if (!conv) return;

                const otherUid = getOtherUid(conv);
                if (!otherUid) return;

                setBusy(true);
                try {
                    const { ciphertext, iv } = await encryptFor(otherUid, draft.trim());
                    const msgRef = convCollection.doc(activeConvId).collection('messages').doc();
                    await msgRef.set({
                        senderId: user.uid,
                        ciphertext,
                        iv,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    await convCollection.doc(activeConvId).update({
                        lastMessageAt: firebase.firestore.FieldValue.serverTimestamp(),
                        lastSenderId: user.uid
                    });

                    setDraft('');
                    setTimeout(() => {
                        if (scrollRef.current) scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
                    }, 50);
                } catch (e) {
                    showToast(e.message || 'Senden fehlgeschlagen');
                } finally {
                    setBusy(false);
                }
            };


            const sendMedia = async (file) => {
                if (!file || !activeConvId) return;
                if (!ready) return;

                const conv = convs.find(c => c.id === activeConvId);
                if (!conv) return;
                const otherUid = getOtherUid(conv);
                if (!otherUid) return;

                const t = (file.type || '').toLowerCase();
                if (!t.startsWith('image/')) {
                    showToast('Nur Bilder');
                    return;
                }

                setBusy(true);
                try {
                    // WhatsApp-Ã¤hnlich: JPEG + max. 2048px Kante (HD)
                    const { blob: jpegBlob } = await compressImageToJpeg(file, 2048, 0.84);
                    const thumbBlob = await makeThumbBlob(jpegBlob);

                    const msgRef = convCollection.doc(activeConvId).collection('messages').doc();
                    const msgId = msgRef.id;

                    const thumbBytes = new Uint8Array(await thumbBlob.arrayBuffer());
                    const fullBytes = new Uint8Array(await jpegBlob.arrayBuffer());

                    const thumbEnc = await encryptBytesFor(otherUid, thumbBytes);
                    const fullEnc = await encryptBytesFor(otherUid, fullBytes);

                    const storagePath = `secretMedia/${activeConvId}/${msgId}.bin`;
                    await storage.ref(storagePath).put(new Blob([fullEnc.cipherBytes], { type: 'application/octet-stream' }));

                    await msgRef.set({
                        senderId: user.uid,
                        kind: 'img',
                        storagePath,
                        ivFull: fullEnc.ivB64,
                        mime: 'image/jpeg',
                        thumbCiphertext: bytesToBase64(thumbEnc.cipherBytes),
                        thumbIv: thumbEnc.ivB64,
                        thumbMime: 'image/jpeg',
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });

                    await convCollection.doc(activeConvId).update({
                        lastMessageAt: firebase.firestore.FieldValue.serverTimestamp(),
                        lastSenderId: user.uid
                    });

                    setTimeout(() => {
                        if (scrollRef.current) scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
                    }, 60);
                } catch (e) {
                    showToast('Upload fehlgeschlagen');
                } finally {
                    setBusy(false);
                }
            };



            const pickAudioMime = () => {
                try {
                    const types = ['audio/webm;codecs=opus','audio/webm','audio/ogg;codecs=opus','audio/ogg','audio/mp4'];
                    if (!window.MediaRecorder) return '';
                    for (const t of types) {
                        if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(t)) return t;
                    }
                    return '';
                } catch (e) { return ''; }
            };

            // Cordova: Kamera/Galerie via cordova-plugin-camera (fallback auf <input>)
            const cordovaGetJpegFile = async (sourceType) => {
                if (!window.cordova || !navigator.camera || !window.Camera) return null;

                // Runtime-Permissions (Android) - best effort
                try {
                    const perms = window.cordova?.plugins?.permissions;
                    if (perms) {
                        const req = (p) => new Promise((resolve) => {
                            if (!p) return resolve(false);
                            try { perms.requestPermission(p, () => resolve(true), () => resolve(false)); } catch (e) { resolve(false); }
                        });

                        if (perms.CAMERA && sourceType === Camera.PictureSourceType.CAMERA) await req(perms.CAMERA);
                        if (perms.READ_MEDIA_IMAGES && sourceType === Camera.PictureSourceType.PHOTOLIBRARY) await req(perms.READ_MEDIA_IMAGES);
                        else if (perms.READ_EXTERNAL_STORAGE && sourceType === Camera.PictureSourceType.PHOTOLIBRARY) await req(perms.READ_EXTERNAL_STORAGE);
                    }
                } catch (e) {}

                return await new Promise((resolve) => {
                    try {
                        navigator.camera.getPicture(
                            (data) => {
                                try {
                                    const byteStr = atob(data);
                                    const bytes = new Uint8Array(byteStr.length);
                                    for (let i = 0; i < byteStr.length; i++) bytes[i] = byteStr.charCodeAt(i);
                                    const blob = new Blob([bytes], { type: 'image/jpeg' });
                                    resolve(new File([blob], `img_${Date.now()}.jpg`, { type: 'image/jpeg' }));
                                } catch (e) { resolve(null); }
                            },
                            () => resolve(null),
                            {
                                destinationType: Camera.DestinationType.DATA_URL,
                                sourceType,
                                encodingType: Camera.EncodingType.JPEG,
                                quality: 84,
                                targetWidth: 2048,
                                targetHeight: 2048,
                                correctOrientation: true,
                                saveToPhotoAlbum: false
                            }
                        );
                    } catch (e) { resolve(null); }
                });
            };

            const openGallery = async () => {
                if (window.cordova && navigator.camera && window.Camera) {
                    const f = await cordovaGetJpegFile(Camera.PictureSourceType.PHOTOLIBRARY);
                    if (f) return await sendMedia(f);
                }
                try { libraryInputRef.current?.click(); } catch (e) {}
            };

            const openCamera = async () => {
                if (window.cordova && navigator.camera && window.Camera) {
                    const f = await cordovaGetJpegFile(Camera.PictureSourceType.CAMERA);
                    if (f) return await sendMedia(f);
                }
                try { cameraInputRef.current?.click(); } catch (e) {}
            };



            const sendAudio = async (blob, durationMs) => {
                if (!blob || !activeConvId) return;
                if (!ready) return;

                const conv = convs.find(c => c.id === activeConvId);
                if (!conv) return;
                const otherUid = getOtherUid(conv);
                if (!otherUid) return;

                setBusy(true);
                try {
                    const msgRef = convCollection.doc(activeConvId).collection('messages').doc();
                    const msgId = msgRef.id;

                    const bytes = new Uint8Array(await blob.arrayBuffer());
                    const fullEnc = await encryptBytesFor(otherUid, bytes);

                    const storagePath = `secretMedia/${activeConvId}/${msgId}.bin`;
                    await storage.ref(storagePath).put(new Blob([fullEnc.cipherBytes], { type: 'application/octet-stream' }));

                    await msgRef.set({
                        senderId: user.uid,
                        kind: 'aud',
                        storagePath,
                        ivFull: fullEnc.ivB64,
                        mime: blob.type || 'audio/webm',
                        durationMs: Math.round(durationMs || 0),
                        playedBy: [],
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });

                    await convCollection.doc(activeConvId).update({
                        lastMessageAt: firebase.firestore.FieldValue.serverTimestamp(),
                        lastSenderId: user.uid
                    });

                    setTimeout(() => {
                        if (scrollRef.current) scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
                    }, 60);
                } catch (e) {
                    showToast('Upload fehlgeschlagen');
                } finally {
                    setBusy(false);
                }
            };

            const encodeWavFromFloats = (floatChunks, sampleRate) => {
                try {
                    const chunks = floatChunks || [];
                    const total = chunks.reduce((a, c) => a + (c?.length || 0), 0);
                    const pcm = new Int16Array(total);
                    let o = 0;
                    for (const c of chunks) {
                        if (!c) continue;
                        for (let i = 0; i < c.length; i++) {
                            let s = c[i];
                            s = Math.max(-1, Math.min(1, s));
                            pcm[o++] = s < 0 ? Math.round(s * 0x8000) : Math.round(s * 0x7FFF);
                        }
                    }
                    const buffer = new ArrayBuffer(44 + pcm.length * 2);
                    const view = new DataView(buffer);
                    const writeStr = (off, str) => {
                        for (let i = 0; i < str.length; i++) view.setUint8(off + i, str.charCodeAt(i));
                    };
                    writeStr(0, 'RIFF');
                    view.setUint32(4, 36 + pcm.length * 2, true);
                    writeStr(8, 'WAVE');
                    writeStr(12, 'fmt ');
                    view.setUint32(16, 16, true);
                    view.setUint16(20, 1, true);
                    view.setUint16(22, 1, true);
                    view.setUint32(24, sampleRate || 44100, true);
                    view.setUint32(28, (sampleRate || 44100) * 2, true);
                    view.setUint16(32, 2, true);
                    view.setUint16(34, 16, true);
                    writeStr(36, 'data');
                    view.setUint32(40, pcm.length * 2, true);
                    let pos = 44;
                    for (let i = 0; i < pcm.length; i++) {
                        view.setInt16(pos, pcm[i], true);
                        pos += 2;
                    }
                    return new Blob([buffer], { type: 'audio/wav' });
                } catch (e) {
                    return null;
                }
            };
            // Cordova: Native Audio Record (cordova-plugin-media + cordova-plugin-file)
            const cordovaReadFileToBlob = (filePath, mimeHint) => new Promise((resolve, reject) => {
                try {
                    if (!window.resolveLocalFileSystemURL) return reject(new Error('no-fs'));
                    window.resolveLocalFileSystemURL(filePath, (entry) => {
                        entry.file((file) => {
                            const r = new FileReader();
                            r.onloadend = () => {
                                try {
                                    const mime = mimeHint || file.type || 'audio/3gpp';
                                    resolve(new Blob([r.result], { type: mime }));
                                } catch (e) { reject(e); }
                            };
                            r.onerror = () => reject(new Error('read-failed'));
                            r.readAsArrayBuffer(file);
                        }, reject);
                    }, reject);
                } catch (e) { reject(e); }
            });

            const cordovaDeleteFile = (filePath) => new Promise((resolve) => {
                try {
                    if (!window.resolveLocalFileSystemURL) return resolve(false);
                    window.resolveLocalFileSystemURL(filePath, (entry) => {
                        entry.remove(() => resolve(true), () => resolve(false));
                    }, () => resolve(false));
                } catch (e) { resolve(false); }
            });

            const startRecCordova = async () => {
                try {
                    if (!window.cordova || !window.Media || !window.cordova.file) {
                        showToast('Aufnahme nicht verfÃ¼gbar.');
                        return;
                    }

                    const perms = window.cordova?.plugins?.permissions;
                    if (perms && perms.RECORD_AUDIO) {
                        await new Promise((resolve) => {
                            try {
                                perms.requestPermission(perms.RECORD_AUDIO, () => resolve(true), () => resolve(false));
                            } catch (e) { resolve(false); }
                        });
                    }

                    const dir = window.cordova.file.cacheDirectory || window.cordova.file.dataDirectory;
                    if (!dir) {
                        showToast('Speicherpfad fehlt.');
                        return;
                    }

                    const ext = (window.cordova.platformId === 'android') ? '3gp' : 'm4a';
                    const mime = (ext === 'm4a') ? 'audio/mp4' : 'audio/3gpp';
                    const filePath = `${dir}rec_${Date.now()}.${ext}`;

                    const mediaObj = new Media(filePath, () => {}, () => {});
                    mediaObj.startRecord();

                    recRef.current.mode = 'cordova';
                    recRef.current.mediaObj = mediaObj;
                    recRef.current.filePath = filePath;
                    recRef.current.mime = mime;
                    recRef.current.startedAt = Date.now();
                    setRecOn(true);
                } catch (e) {
                    showToast('Aufnahme fehlgeschlagen');
                }
            };



            const startRec = async () => {
                if (!ready || !activeConvId) return;

                if (window.cordova && window.Media && window.cordova?.file && window.resolveLocalFileSystemURL) {
                    await startRecCordova();
                    return;
                }

                if (!navigator.mediaDevices?.getUserMedia) {
                    showToast('Mikrofon nicht verfÃ¼gbar.');
                    return;
                }

                const proto = (location.protocol || '').toLowerCase();
                const host = (location.hostname || '').toLowerCase();
                const isProbablySecure = !!window.isSecureContext
                    || proto === 'https:'
                    || proto === 'capacitor:'
                    || proto === 'ionic:'
                    || host === 'localhost'
                    || host === '127.0.0.1';

                if (!isProbablySecure) {
                    showToast('Mikrofon benÃ¶tigt HTTPS/localhost (APK: AssetLoader/Capacitor).');
                    return;
                }

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
                    });

                    recRef.current.discard = false;
                    recRef.current.stream = stream;
                    recRef.current.startedAt = Date.now();

                    if (window.MediaRecorder) {
                        const mimeType = pickAudioMime();
                        const rec = new MediaRecorder(stream, mimeType ? { mimeType } : undefined);

                        recRef.current.mode = 'media';
                        recRef.current.recorder = rec;
                        recRef.current.chunks = [];
                        recRef.current.mime = mimeType || rec.mimeType || 'audio/webm';

                        rec.ondataavailable = (e) => {
                            if (e.data && e.data.size > 0) recRef.current.chunks.push(e.data);
                        };
                        rec.onstop = async () => {
                            const discard = !!recRef.current.discard;
                            try { recRef.current.stream?.getTracks?.().forEach(t => t.stop()); } catch (e) {}
                            recRef.current.stream = null;
                            recRef.current.recorder = null;

                            if (discard) return;

                            try {
                                const blob = new Blob(recRef.current.chunks || [], { type: recRef.current.mime || 'audio/webm' });
                                const durMs = Math.max(0, Date.now() - (recRef.current.startedAt || Date.now()));
                                if (blob.size < 1200) return;
                                await sendAudio(blob, durMs);
                            } catch (e) {
                                showToast('Aufnahme fehlgeschlagen');
                            }
                        };

                        rec.start(250);
                        setRecOn(true);
                        return;
                    }

                    // Fallback: WAV (fÃ¼r WebViews ohne MediaRecorder)
                    const AC = window.AudioContext || window.webkitAudioContext;
                    if (!AC) {
                        try { stream.getTracks().forEach(t => t.stop()); } catch (e) {}
                        showToast('Mikrofon nicht verfÃ¼gbar.');
                        return;
                    }

                    const ctx = new AC();
                    const source = ctx.createMediaStreamSource(stream);
                    const proc = ctx.createScriptProcessor(4096, 1, 1);
                    const floats = [];

                    proc.onaudioprocess = (e) => {
                        try {
                            if (recRef.current.discard) return;
                            const ch0 = e.inputBuffer.getChannelData(0);
                            floats.push(new Float32Array(ch0));
                        } catch (err) {}
                    };

                    source.connect(proc);
                    proc.connect(ctx.destination);

                    recRef.current.mode = 'wav';
                    recRef.current.audioCtx = ctx;
                    recRef.current.processor = proc;
                    recRef.current.sourceNode = source;
                    recRef.current.floatChunks = floats;
                    recRef.current.sampleRate = ctx.sampleRate || 44100;

                    setRecOn(true);
                } catch (e) {
                    showToast('Mikrofon blockiert.');
                }
            };

            const stopRec = (send = true) => {
                try { recRef.current.discard = !send; } catch (e) {}

                const mode = recRef.current.mode;

                if (mode === 'cordova') {
                    const discard = !!recRef.current.discard;
                    const mediaObj = recRef.current.mediaObj;
                    const filePath = recRef.current.filePath;
                    const mime = recRef.current.mime || 'audio/3gpp';
                    const startedAt = recRef.current.startedAt || Date.now();

                    try { mediaObj?.stopRecord(); } catch (e) {}

                    (async () => {
                        try {
                            if (discard) {
                                if (filePath) await cordovaDeleteFile(filePath);
                                return;
                            }
                            if (!filePath) return;

                            const blob = await cordovaReadFileToBlob(filePath, mime);
                            const durMs = Math.max(0, Date.now() - startedAt);
                            if (blob && blob.size >= 1200) {
                                await sendAudio(blob, durMs);
                            }
                        } catch (e) {
                            showToast('Aufnahme fehlgeschlagen');
                        } finally {
                            try { if (filePath) await cordovaDeleteFile(filePath); } catch (e) {}
                        }
                    })();

                    setRecOn(false);
                    return;
                }

                if (mode === 'media') {
                    try { recRef.current.recorder?.stop(); } catch (e) {}
                    setRecOn(false);
                    return;
                }

                if (mode === 'wav') {
                    (async () => {
                        const discard = !!recRef.current.discard;
                        const startedAt = recRef.current.startedAt || Date.now();

                        try { recRef.current.processor?.disconnect?.(); } catch (e) {}
                        try { recRef.current.sourceNode?.disconnect?.(); } catch (e) {}
                        try { await recRef.current.audioCtx?.close?.(); } catch (e) {}
                        try { recRef.current.stream?.getTracks?.().forEach(t => t.stop()); } catch (e) {}

                        const floats = recRef.current.floatChunks || [];
                        const sr = recRef.current.sampleRate || 44100;

                        recRef.current.stream = null;
                        recRef.current.audioCtx = null;
                        recRef.current.processor = null;
                        recRef.current.sourceNode = null;
                        recRef.current.floatChunks = null;

                        if (discard) return;

                        try {
                            const blob = encodeWavFromFloats(floats, sr);
                            const durMs = Math.max(0, Date.now() - startedAt);
                            if (!blob || blob.size < 1200) return;
                            await sendAudio(blob, durMs);
                        } catch (e) {
                            showToast('Aufnahme fehlgeschlagen');
                        }
                    })();
                    setRecOn(false);
                    return;
                }

                setRecOn(false);
            };


            const formatDur = (ms) => {
                const s = Math.max(0, Math.round((ms || 0) / 1000));
                const mm = String(Math.floor(s / 60)).padStart(2, '0');
                const ss = String(s % 60).padStart(2, '0');
                return `${mm}:${ss}`;
            };

            const markPlayedAndMaybeDelete = async (msg) => {
                try {
                    setHiddenIds(prev => ({ ...prev, [msg.id]: true }));

                    const msgDoc = convCollection.doc(activeConvId).collection('messages').doc(msg.id);
                    await msgDoc.update({ playedBy: firebase.firestore.FieldValue.arrayUnion(user.uid) }).catch(()=>{});

                    const convSnap = await convCollection.doc(activeConvId).get();
                    const members = (convSnap.data()?.memberIds) || [];

                    const snap2 = await msgDoc.get();
                    const d2 = snap2.data() || {};
                    const playedBy = d2.playedBy || [];

                    if (members.length && members.every(u => playedBy.includes(u))) {
                        if (d2.storagePath) await storage.ref(d2.storagePath).delete().catch(()=>{});
                        await msgDoc.delete().catch(()=>{});
                    }
                } catch (e) {}
            };

            const playAudio = async (msg) => {
                if (!ready || !msg?.storagePath || !msg?.ivFull) return;
                if (!activeConvId) return;
                if (playBusyId) return;

                const conv = convs.find(c => c.id === activeConvId);
                if (!conv) return;
                const otherUid = getOtherUid(conv);
                if (!otherUid) return;

                setPlayBusyId(msg.id);
                try {
                    const url = await storage.ref(msg.storagePath).getDownloadURL();
                    const resp = await fetch(url);
                    const encBuf = await resp.arrayBuffer();

                    const key = await getSharedKey(otherUid);
                    const iv = base64ToBytes(msg.ivFull);
                    const pt = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, encBuf);

                    const blob = new Blob([pt], { type: msg.mime || 'audio/webm' });
                    const objectUrl = URL.createObjectURL(blob);

                    const a = new Audio(objectUrl);
                    a.onended = () => {
                        try { URL.revokeObjectURL(objectUrl); } catch (e) {}
                        markPlayedAndMaybeDelete(msg);
                    };
                    a.onerror = () => {
                        try { URL.revokeObjectURL(objectUrl); } catch (e) {}
                        showToast('Wiedergabe fehlgeschlagen');
                    };

                    await a.play();
                } catch (e) {
                    showToast('Wiedergabe fehlgeschlagen');
                } finally {
                    setPlayBusyId(null);
                }
            };

            useEffect(() => {
                // Init on open
                ensureSecretSetup();
            }, []);
            useEffect(() => {
                return () => {
                    try {
                        if (recRef.current && recRef.current.recorder) {
                            recRef.current.discard = true;
                            recRef.current.recorder.stop();
                        }
                    } catch (e) {}
                    try {
                        recRef.current?.stream?.getTracks?.().forEach(t => t.stop());
                    } catch (e) {}
                    if (overlayObjectUrlRef.current) {
                        URL.revokeObjectURL(overlayObjectUrlRef.current);
                        overlayObjectUrlRef.current = null;
                    }
                };
            }, []);


            useEffect(() => {
                if (!ready) return;

                // Wichtig: bei (Re-)Subscribe initiale Ã„nderungen NICHT als "neu" bewerten
                listLoadedRef.current = false;

                const unsub = convCollection.where('memberIds', 'array-contains', user.uid).onSnapshot(async (snap) => {
                    const items = snap.docs.map(d => ({ id: d.id, ...d.data() }));
                    items.sort((a,b) => {
                        const ta = a.lastMessageAt?.toMillis?.() || 0;
                        const tb = b.lastMessageAt?.toMillis?.() || 0;
                        return tb - ta;
                    });
                    setConvs(items);

                    // Profiles nachziehen
                    items.forEach(c => ensureProfile(getOtherUid(c)));

                    // Notifications: nur nach initialem Load, nur wenn lastMessage neu und von anderer Person
                    if (listLoadedRef.current) {
                        snap.docChanges().forEach(ch => {
                            if (ch.type !== 'modified' && ch.type !== 'added') return;
                            const d = ch.doc.data() || {};
                            if (d.lastSenderId === user.uid) return;
                            const ts = d.lastMessageAt?.toMillis?.() || 0;
                            const prevTs = lastNotifiedRef.current[ch.doc.id] || 0;
                            if (ts && ts > prevTs) {
                                lastNotifiedRef.current[ch.doc.id] = ts;
                                const otherUid = (d.memberIds || []).find(x => x !== user.uid);
                                const name = profilesRef.current[otherUid]?.username || 'Neuer Eintrag';
                                notify('PlanWise', `Eintrag von ${name}`);
                            }
                        });
                    } else {
                        // Initiale Marker setzen
                        items.forEach(c => {
                            const ts = c.lastMessageAt?.toMillis?.() || 0;
                            lastNotifiedRef.current[c.id] = ts;
                        });
                        listLoadedRef.current = true;
                    }
                });

                return () => unsub();
            }, [ready, notificationsEnabled]);

            useEffect(() => {
                if (!ready || !activeConvId) return;

                const conv = convs.find(c => c.id === activeConvId);
                if (!conv) return;
                const otherUid = getOtherUid(conv);
                if (!otherUid) return;

                const unsub = convCollection.doc(activeConvId).collection('messages').orderBy('createdAt', 'asc').limitToLast(200).onSnapshot(async (snap) => {
                    const docs = snap.docs.map(d => ({ id: d.id, ...d.data() }));
                    const hydrated = await Promise.all(docs.map(async (m) => {
                        // Audio-Eintrag
                        if (m.kind === 'aud') {
                            return { ...m, kind: 'aud' };
                        }

                        // Bild-Eintrag
                        if (m.kind === 'img' || (m.storagePath && m.thumbCiphertext)) {
                            let thumbDataUrl = null;
                            if (m.thumbCiphertext && m.thumbIv) {
                                try {
                                    const bytes = await decryptBytesFrom(otherUid, m.thumbCiphertext, m.thumbIv);
                                    const mime = m.thumbMime || 'image/jpeg';
                                    thumbDataUrl = `data:${mime};base64,${bytesToBase64(bytes)}`;
                                } catch (e) {}
                            }
                            return { ...m, kind: 'img', thumbDataUrl };
                        }

                        // Text-Eintrag (Fallback)
                        try {
                            const text = await decryptFrom(otherUid, m.ciphertext, m.iv);
                            return { ...m, kind: 'text', text, _ok: true };
                        } catch (e) {
                            return { ...m, kind: 'text', text: '[Nicht lesbar]', _ok: false };
                        }
                    }));
                    setMessages(hydrated);
                    setTimeout(() => {
                        if (scrollRef.current) scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
                    }, 50);

                    // Notify for newly added messages (current view)
                    if (notificationsEnabled && Notification?.permission === 'granted') {
                        snap.docChanges().forEach(ch => {
                            if (ch.type !== 'added') return;
                            const d = ch.doc.data() || {};
                            if (d.senderId === user.uid) return;
                            // initial load -> createdAt kann null sein, daher "nichts"
                            if (d.createdAt && d.createdAt.toMillis) {
                                notify('PlanWise', `Neuer Eintrag von ${profiles[otherUid]?.username || shortUid(otherUid)}`);
                            }
                        });
                    }
                });

                return () => unsub();
            }, [ready, activeConvId, convs.length]);

            const activeConv = convs.find(c => c.id === activeConvId);
            const activeOtherUid = activeConv ? getOtherUid(activeConv) : null;
            const activeName = activeOtherUid ? (profiles[activeOtherUid]?.username || shortUid(activeOtherUid)) : 'â€”';

            return (
                <div className="fixed inset-0 z-[120] bg-white dark:bg-[#121212] flex flex-col">
                    {/* Topbar */}
                    <div className="px-6 py-5 border-b border-gray-100 dark:border-gray-800 flex items-center justify-between bg-white dark:bg-[#121212]">
                        <div className="flex items-center gap-3">
                            {view === 'detail' ? (
                                <button onClick={() => { if (recOn) stopRec(false); setView('list'); setActiveConvId(null); }} className="p-2 -ml-2 rounded-full hover:bg-gray-50 dark:hover:bg-[#1E1E1E]">
                                    <Icon name="chevronLeft" />
                                </button>
                            ) : (
                                <div className="w-10 h-10 rounded-2xl bg-gray-50 dark:bg-[#1E1E1E] flex items-center justify-center">
                                    <Icon name="lock" />
                                </div>
                            )}
                            <div>
                                <div className="font-bold text-lg dark:text-white">{view === 'detail' ? activeName : 'Archiv'}</div>
                                <div className="text-[10px] uppercase tracking-widest text-gray-400">{ready ? 'Aktiv' : 'Startâ€¦'}</div>
                            </div>
                        </div>
                        <div className="flex items-center gap-2">
                            <button
                                onClick={() => { notificationsEnabled ? setNotificationsEnabled(false) : requestNotifications(); }}
                                className={`p-3 rounded-2xl shadow-sm ${notificationsEnabled ? 'bg-black text-white dark:bg-white dark:text-black' : 'bg-gray-100 dark:bg-[#1E1E1E] dark:text-white'}`}
                                title="Benachrichtigungen"
                            >
                                <Icon name="bell" />
                            </button>
                            <button onClick={() => { if (recOn) stopRec(false); onClose(); }} className="p-3 bg-gray-100 dark:bg-[#1E1E1E] dark:text-white rounded-2xl shadow-sm">
                                <Icon name="x" />
                            </button>
                        </div>
                    </div>

                    {/* Content */}
                    {view === 'list' ? (
                        <div className="p-6 overflow-y-auto flex-1 bg-[#F8F9FA] dark:bg-[#000000]">
                            <div className="bg-white dark:bg-[#1E1E1E] p-5 rounded-[28px] shadow-sm mb-6">
                                <div className="text-xs font-bold uppercase text-gray-400 mb-2">Dein Code</div>
                                <div className="flex items-center justify-between gap-3">
                                    <div className="font-bold tracking-wider dark:text-white">{mySecretId || 'â€”'}</div>
                                    <button
                                        onClick={() => { if (mySecretId) { navigator.clipboard.writeText(mySecretId); showToast('Code kopiert'); } }}
                                        className="text-xs font-bold bg-gray-100 dark:bg-[#2D2D2D] dark:text-white px-3 py-2 rounded-xl"
                                    >
                                        Kopieren
                                    </button>
                                </div>
</div>

                            <div className="bg-white dark:bg-[#1E1E1E] p-5 rounded-[28px] shadow-sm mb-6">
                                <div className="text-xs font-bold uppercase text-gray-400 mb-3">Neue VerknÃ¼pfung (nur via Code)</div>
                                <div className="flex gap-2 items-center">
                                    
                                    <input
                                        className="flex-1 bg-gray-50 dark:bg-[#2D2D2D] dark:text-white rounded-2xl px-4 py-3 text-sm font-bold outline-none"
                                        placeholder="Code oder UID"
                                        value={idInput}
                                        onChange={e => setIdInput(e.target.value)}
                                    />
                                    <button
                                        disabled={busy || !ready}
                                        onClick={connectById}
                                        className="bg-black dark:bg-white dark:text-black text-white px-4 rounded-2xl font-bold"
                                    >
                                        {busy ? 'â€¦' : 'Verbinden'}
                                    </button>
                                </div>
                            </div>

                            <div className="text-xs font-bold uppercase text-gray-400 mb-3 ml-1">VerknÃ¼pfungen</div>
                            <div className="space-y-3">
                                {convs.length === 0 ? (
                                    <div className="text-center py-10 opacity-50 border-2 border-dashed dark:border-gray-800 rounded-3xl text-sm dark:text-gray-400">
                                        Keine Verbindungen
                                    </div>
                                ) : convs.map(c => {
                                    const other = getOtherUid(c);
                                    const name = profiles[other]?.username || shortUid(other);
                                    const last = c.lastMessageAt?.toDate?.() ? c.lastMessageAt.toDate().toLocaleString('de-DE', { day:'2-digit', month:'2-digit', hour:'2-digit', minute:'2-digit' }) : '';
                                    return (
                                        <button key={c.id} onClick={() => { setActiveConvId(c.id); setView('detail'); }} className="w-full text-left bg-white dark:bg-[#1E1E1E] p-5 rounded-[28px] shadow-sm flex items-center justify-between">
                                            <div className="flex items-center gap-3">
                                                <div className="w-10 h-10 rounded-2xl bg-gray-50 dark:bg-[#2D2D2D] flex items-center justify-center">
                                                    <Icon name="user" />
                                                </div>
                                                <div>
                                                    <div className="font-bold dark:text-white">{name}</div>
                                                    <div className="text-[11px] text-gray-400">{profiles[other]?.secretId ? `Code: ${profiles[other].secretId}` : shortUid(other)}</div>
                                                </div>
                                            </div>
                                            <div className="text-[11px] text-gray-400">{last}</div>
                                        </button>
                                    );
                                })}
                            </div>
                        </div>
                    ) : (
                        <div className="flex-1 flex flex-col bg-[#F8F9FA] dark:bg-[#000000]">
                            <div ref={scrollRef} className="flex-1 overflow-y-auto p-6 space-y-3">
                                {messages.length === 0 ? (
                                    <div className="text-center py-10 opacity-50 border-2 border-dashed dark:border-gray-800 rounded-3xl text-sm dark:text-gray-400">
                                        Keine EintrÃ¤ge
                                    </div>
                                ) : messages.filter(m => !hiddenIds[m.id]).map(m => {
                                    const mine = m.senderId === user.uid;
                                    return (
                                        <div key={m.id} className={`flex ${mine ? 'justify-end' : 'justify-start'}`}>
                                            <div className={`max-w-[80%] rounded-3xl ${m.kind === 'img' ? 'p-2' : (m.kind === 'aud' ? 'px-3 py-2' : 'px-4 py-3')} shadow-sm ${mine ? 'bg-black text-white dark:bg-white dark:text-black' : 'bg-white dark:bg-[#1E1E1E] dark:text-white'}`}>
                                                {m.kind === 'img' ? (
                                                    <button type="button" onClick={() => openMedia(m)} className="block">
                                                        {m.thumbDataUrl ? (
                                                            <img src={m.thumbDataUrl} className="w-44 h-44 object-cover rounded-2xl" />
                                                        ) : (
                                                            <div className="w-44 h-44 rounded-2xl bg-gray-200 dark:bg-[#2D2D2D] flex items-center justify-center">
                                                                <Icon name="image" />
                                                            </div>
                                                        )}
                                                    </button>
                                                ) : m.kind === 'aud' ? (
                                                    <button
                                                        type="button"
                                                        onClick={() => playAudio(m)}
                                                        className="flex items-center gap-3"
                                                        title=""
                                                    >
                                                        <div className={`w-10 h-10 rounded-2xl flex items-center justify-center ${mine ? 'bg-white/15 dark:bg-black/15' : 'bg-gray-100 dark:bg-[#2D2D2D]'}`}>
                                                            {playBusyId === m.id ? (
                                                                <div className="w-5 h-5 border-2 border-current border-t-transparent rounded-full animate-spin"></div>
                                                            ) : (
                                                                <Icon name="play" />
                                                            )}
                                                        </div>
                                                        <div className={`text-sm font-bold ${mine ? '' : ''}`}>{formatDur(m.durationMs || 0)}</div>
                                                    </button>
                                                ) : (
                                                    <div className={`text-sm leading-snug ${m._ok ? '' : 'opacity-70'}`}>{m.text}</div>
                                                )}
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                            <div className="p-4 border-t border-gray-100 dark:border-gray-800 bg-white dark:bg-[#121212]">
                                <div className="flex gap-2 items-center">
                                    <input
                                        ref={libraryInputRef}
                                        type="file"
                                        accept="image/*"
                                        className="hidden"
                                        onChange={async (e) => {
                                            const f = e.target.files && e.target.files[0];
                                            e.target.value = '';
                                            if (f) await sendMedia(f);
                                        }}
                                    />
                                    <input
                                        ref={cameraInputRef}
                                        type="file"
                                        accept="image/*"
                                        capture="environment"
                                        className="hidden"
                                        onChange={async (e) => {
                                            const f = e.target.files && e.target.files[0];
                                            e.target.value = '';
                                            if (f) await sendMedia(f);
                                        }}
                                    />
                                    <button
                                        type="button"
                                        disabled={busy || !ready || !activeConvId || recOn}
                                        onClick={openGallery}
                                        className="p-3 rounded-2xl bg-gray-100 dark:bg-[#1E1E1E] dark:text-white shadow-sm disabled:opacity-50"
                                    >
                                        <Icon name="image" />
                                    </button>
                                    <button
                                        type="button"
                                        disabled={busy || !ready || !activeConvId || recOn}
                                        onClick={openCamera}
                                        className="p-3 rounded-2xl bg-gray-100 dark:bg-[#1E1E1E] dark:text-white shadow-sm disabled:opacity-50"
                                    >
                                        <Icon name="camera" />
                                    </button>
                                    <button
                                        type="button"
                                        disabled={busy || !ready || !activeConvId}
                                        onPointerDown={(e) => { e.preventDefault(); e.stopPropagation(); recOn ? stopRec(true) : startRec(); }}
                                        className={`p-3 rounded-2xl shadow-sm ${recOn ? 'bg-black text-white dark:bg-white dark:text-black animate-pulse' : 'bg-gray-100 dark:bg-[#1E1E1E] dark:text-white'} disabled:opacity-50`}
                                    >
                                        <Icon name={recOn ? 'stop' : 'mic'} />
                                    </button>
                                    <input
                                        className="flex-1 bg-gray-100 dark:bg-[#1E1E1E] dark:text-white rounded-2xl px-4 py-3 text-sm font-bold outline-none"
                                        placeholder="Eintragâ€¦"
                                        value={draft}
                                        onChange={e => setDraft(e.target.value)}
                                        onKeyDown={(e) => { if (e.key === 'Enter') sendMessage(); }}
                                    />
                                    <button
                                        disabled={busy || !draft.trim()}
                                        onClick={sendMessage}
                                        className="p-3 rounded-2xl bg-black text-white dark:bg-white dark:text-black shadow-sm"
                                    >
                                        <Icon name="send" />
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {mediaOverlay && (
                        <div
                            className="fixed inset-0 z-[200] bg-black/80 flex items-center justify-center fade-in"
                            onClick={() => {
                                if (!mediaOverlay) return;
                                const openedAt = mediaOverlay.openedAt || 0;
                                if (openedAt && (Date.now() - openedAt) < 450) return;
                                if (mediaOverlay.loading) { closeMedia(); return; }
                                if (mediaOverlay.mine) deleteMedia(mediaOverlay.msg);
                                else closeMedia();
                            }}
                        >
                            {mediaOverlay.loading ? (
                                <div className="w-12 h-12 border-4 border-white/30 border-t-white rounded-full animate-spin"></div>
                            ) : (
                                <img src={mediaOverlay.url} className="max-w-[92vw] max-h-[92vh] rounded-3xl shadow-2xl" />
                            )}
                        </div>
                    )}

                </div>
            );
        };

        // --- HABITS PANEL ---
        const HabitsPanel = ({ user, db, onClose, showToast }) => {
            const [habits, setHabits] = useState([]);
            const [habitLogs, setHabitLogs] = useState([]);
            const [newHabitName, setNewHabitName] = useState('');
            const [newHabitEmoji, setNewHabitEmoji] = useState('âœ…');
            const [newHabitColor, setNewHabitColor] = useState('#22C55E');
            const [selectedDate, setSelectedDate] = useState(new Date());

            useEffect(() => {
                if (!user) return;
                
                const unsubHabits = db.collection('users').doc(user.uid).collection('habits')
                    .onSnapshot(snap => {
                        setHabits(snap.docs.map(doc => ({ id: doc.id, ...doc.data() })));
                    });

                const unsubLogs = db.collection('users').doc(user.uid).collection('habitLogs')
                    .onSnapshot(snap => {
                        setHabitLogs(snap.docs.map(doc => ({ id: doc.id, ...doc.data() })));
                    });

                return () => { unsubHabits(); unsubLogs(); };
            }, [user]);

            const addHabit = async () => {
                if (!newHabitName.trim() || !user) return;
                await db.collection('users').doc(user.uid).collection('habits').add({
                    name: newHabitName.trim(),
                    emoji: newHabitEmoji,
                    color: newHabitColor,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                setNewHabitName('');
                showToast('Habit hinzugefÃ¼gt');
            };

            const deleteHabit = async (habitId) => {
                if (!confirm('Habit wirklich lÃ¶schen?')) return;
                await db.collection('users').doc(user.uid).collection('habits').doc(habitId).delete();
                // Also delete all logs for this habit
                const logs = habitLogs.filter(log => log.habitId === habitId);
                const batch = db.batch();
                logs.forEach(log => {
                    batch.delete(db.collection('users').doc(user.uid).collection('habitLogs').doc(log.id));
                });
                await batch.commit();
                showToast('Habit gelÃ¶scht');
            };

            const toggleHabitLog = async (habitId, date) => {
                const dateStr = date.toISOString().split('T')[0];
                const existingLog = habitLogs.find(log => log.habitId === habitId && log.date === dateStr);
                
                if (existingLog) {
                    await db.collection('users').doc(user.uid).collection('habitLogs').doc(existingLog.id).delete();
                } else {
                    await db.collection('users').doc(user.uid).collection('habitLogs').add({
                        habitId,
                        date: dateStr,
                        completed: true,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                }
            };

            const calculateStreak = (habitId) => {
                const logs = habitLogs
                    .filter(log => log.habitId === habitId)
                    .map(log => log.date)
                    .sort()
                    .reverse();
                
                if (logs.length === 0) return 0;
                
                let streak = 0;
                const today = new Date().toISOString().split('T')[0];
                const yesterday = new Date(Date.now() - 86400000).toISOString().split('T')[0];
                
                // Check if today or yesterday is logged (to keep streak alive)
                if (logs[0] !== today && logs[0] !== yesterday) return 0;
                
                let currentDate = new Date(logs[0]);
                for (const logDate of logs) {
                    const logDateObj = new Date(logDate);
                    const diff = Math.floor((currentDate - logDateObj) / 86400000);
                    
                    if (diff === 0) {
                        streak++;
                        currentDate.setDate(currentDate.getDate() - 1);
                    } else if (diff === 1) {
                        streak++;
                        currentDate = new Date(logDate);
                        currentDate.setDate(currentDate.getDate() - 1);
                    } else {
                        break;
                    }
                }
                
                return streak;
            };

            const getWeekDates = () => {
                const dates = [];
                const today = new Date();
                for (let i = 6; i >= 0; i--) {
                    const date = new Date(today);
                    date.setDate(today.getDate() - i);
                    dates.push(date);
                }
                return dates;
            };

            const isHabitLoggedForDate = (habitId, date) => {
                const dateStr = date.toISOString().split('T')[0];
                return habitLogs.some(log => log.habitId === habitId && log.date === dateStr);
            };

            return (
                <div className="fixed inset-0 bg-white dark:bg-[#121212] z-50 flex flex-col">
                    <div className="px-6 py-6 border-b border-gray-100 dark:border-gray-800 flex justify-between items-center sticky top-0 bg-white dark:bg-[#121212]">
                        <h2 className="text-2xl font-bold dark:text-white">Habit Tracker</h2>
                        <button onClick={onClose} className="p-2 bg-gray-100 dark:bg-[#1E1E1E] dark:text-white rounded-full">
                            <Icon name="x" size={24}/>
                        </button>
                    </div>
                    
                    <div className="flex-1 overflow-y-auto p-6 bg-[#F8F9FA] dark:bg-[#000000]">
                        {/* Add New Habit */}
                        <div className="bg-white dark:bg-[#1E1E1E] rounded-[32px] p-6 mb-6 shadow-sm">
                            <h3 className="text-sm font-bold text-gray-400 uppercase mb-4">Neues Habit</h3>
                            <div className="flex gap-2 mb-3">
                                <input 
                                    type="text" 
                                    className="flex-1 bg-gray-50 dark:bg-[#2D2D2D] dark:text-white rounded-xl p-3 outline-none" 
                                    placeholder="Habit Name" 
                                    value={newHabitName}
                                    onChange={e => setNewHabitName(e.target.value)}
                                    onKeyPress={e => e.key === 'Enter' && addHabit()}
                                />
                                <select 
                                    className="bg-gray-50 dark:bg-[#2D2D2D] dark:text-white rounded-xl p-3 outline-none"
                                    value={newHabitEmoji}
                                    onChange={e => setNewHabitEmoji(e.target.value)}
                                >
                                    {['âœ…', 'ðŸ’ª', 'ðŸ“š', 'ðŸƒ', 'ðŸ§˜', 'ðŸŽ¯', 'ðŸ’§', 'ðŸŽ', 'ðŸ˜´', 'ðŸŽ¨'].map(emoji => (
                                        <option key={emoji} value={emoji}>{emoji}</option>
                                    ))}
                                </select>
                                <input 
                                    type="color" 
                                    className="w-12 h-12 rounded-xl border-none cursor-pointer" 
                                    value={newHabitColor}
                                    onChange={e => setNewHabitColor(e.target.value)}
                                />
                            </div>
                            <button 
                                onClick={addHabit} 
                                className="w-full py-3 bg-black dark:bg-white dark:text-black text-white rounded-xl font-bold"
                            >
                                HinzufÃ¼gen
                            </button>
                        </div>

                        {/* Habits List */}
                        {habits.length === 0 ? (
                            <div className="text-center py-12 text-gray-400">
                                <p className="text-sm">Noch keine Habits erstellt</p>
                            </div>
                        ) : (
                            <div className="space-y-4">
                                {habits.map(habit => {
                                    const streak = calculateStreak(habit.id);
                                    const weekDates = getWeekDates();
                                    const weekCount = weekDates.filter(date => isHabitLoggedForDate(habit.id, date)).length;
                                    
                                    return (
                                        <div key={habit.id} className="bg-white dark:bg-[#1E1E1E] rounded-[32px] p-6 shadow-sm">
                                            <div className="flex items-center justify-between mb-4">
                                                <div className="flex items-center gap-3">
                                                    <div 
                                                        className="w-12 h-12 rounded-xl flex items-center justify-center text-2xl"
                                                        style={{ backgroundColor: habit.color + '30' }}
                                                    >
                                                        {habit.emoji}
                                                    </div>
                                                    <div>
                                                        <h4 className="font-bold dark:text-white">{habit.name}</h4>
                                                        <div className="flex gap-3 text-xs text-gray-400 mt-1">
                                                            <span>ðŸ”¥ {streak} Tage</span>
                                                            <span>ðŸ“Š {weekCount}/7 diese Woche</span>
                                                        </div>
                                                    </div>
                                                </div>
                                                <button 
                                                    onClick={() => deleteHabit(habit.id)}
                                                    className="p-2 text-red-500 hover:bg-red-50 dark:hover:bg-red-900/20 rounded-lg"
                                                >
                                                    <Icon name="trash" size={16}/>
                                                </button>
                                            </div>
                                            
                                            {/* Week Grid */}
                                            <div className="flex gap-2 justify-between">
                                                {weekDates.map(date => {
                                                    const isLogged = isHabitLoggedForDate(habit.id, date);
                                                    const isToday = date.toDateString() === new Date().toDateString();
                                                    
                                                    return (
                                                        <button
                                                            key={date.toISOString()}
                                                            onClick={() => toggleHabitLog(habit.id, date)}
                                                            className={`flex-1 aspect-square rounded-xl flex flex-col items-center justify-center text-xs transition-all ${
                                                                isLogged 
                                                                    ? 'text-white font-bold shadow-lg' 
                                                                    : 'bg-gray-100 dark:bg-[#2D2D2D] text-gray-400 hover:bg-gray-200 dark:hover:bg-[#3D3D3D]'
                                                            } ${isToday ? 'ring-2 ring-blue-500' : ''}`}
                                                            style={isLogged ? { backgroundColor: habit.color } : {}}
                                                        >
                                                            <span>{['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'][date.getDay()]}</span>
                                                            <span className="font-bold">{date.getDate()}</span>
                                                        </button>
                                                    );
                                                })}
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // --- TIME TRACKING PANEL ---
        const TimeTrackingPanel = ({ user, db, onClose, showToast }) => {
            const [activeSession, setActiveSession] = useState(null);
            const [timeEntries, setTimeEntries] = useState([]);
            const [loading, setLoading] = useState(true);
            const [currentTime, setCurrentTime] = useState(new Date());
            const [showHistory, setShowHistory] = useState(false);
            const [selectedMonth, setSelectedMonth] = useState(new Date());
            const [viewType, setViewType] = useState('month'); // 'week', 'month', 'year'
            const [editingEntry, setEditingEntry] = useState(null);
            const [editForm, setEditForm] = useState({ clockIn: '', clockOut: '', notes: '' });

            // Update current time every second when session is active
            useEffect(() => {
                if (!activeSession) return;
                const timer = setInterval(() => setCurrentTime(new Date()), 1000);
                return () => clearInterval(timer);
            }, [activeSession]);

            // Load active session and recent entries
            useEffect(() => {
                if (!user) return;
                const unsubActive = db.collection('timeTracking')
                    .where('userId', '==', user.uid)
                    .where('clockOut', '==', null)
                    .limit(1)
                    .onSnapshot(snap => {
                        if (!snap.empty) {
                            const doc = snap.docs[0];
                            setActiveSession({ id: doc.id, ...doc.data() });
                        } else {
                            setActiveSession(null);
                        }
                        setLoading(false);
                    }, err => {
                        console.error('Error loading active session:', err);
                        showToast('Fehler beim Laden der aktiven Sitzung');
                        setLoading(false);
                    });

                // Calculate date range based on view type
                let startDate, endDate;
                if (viewType === 'week') {
                    // Get start of week (Monday)
                    const day = selectedMonth.getDay();
                    const diff = selectedMonth.getDate() - day + (day === 0 ? -6 : 1);
                    startDate = new Date(selectedMonth.getFullYear(), selectedMonth.getMonth(), diff);
                    endDate = new Date(startDate);
                    endDate.setDate(startDate.getDate() + 6);
                    endDate.setHours(23, 59, 59, 999);
                } else if (viewType === 'month') {
                    startDate = new Date(selectedMonth.getFullYear(), selectedMonth.getMonth(), 1);
                    endDate = new Date(selectedMonth.getFullYear(), selectedMonth.getMonth() + 1, 0, 23, 59, 59);
                } else { // year
                    startDate = new Date(selectedMonth.getFullYear(), 0, 1);
                    endDate = new Date(selectedMonth.getFullYear(), 11, 31, 23, 59, 59);
                }

                // Simple query without composite index requirement
                const unsubEntries = db.collection('timeTracking')
                    .where('userId', '==', user.uid)
                    .onSnapshot(snap => {
                        // Filter by date range and sort in memory
                        const allEntries = snap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        const filteredEntries = allEntries
                            .filter(entry => {
                                if (!entry.clockIn) return false;
                                const entryDate = entry.clockIn.toDate ? entry.clockIn.toDate() : new Date(entry.clockIn);
                                return entryDate >= startDate && entryDate <= endDate;
                            })
                            .sort((a, b) => {
                                // Sort by clockIn descending (newest first)
                                const dateA = a.clockIn?.toMillis ? a.clockIn.toMillis() : 0;
                                const dateB = b.clockIn?.toMillis ? b.clockIn.toMillis() : 0;
                                return dateB - dateA;
                            });
                        setTimeEntries(filteredEntries);
                    }, err => {
                        console.error('Error loading time entries:', err);
                        showToast('Fehler beim Laden der Historie');
                    });

                return () => { unsubActive(); unsubEntries(); };
            }, [user, selectedMonth, viewType]);

            const clockIn = async () => {
                if (activeSession || !user) return;
                try {
                    console.log('Attempting to clock in for user:', user.uid);
                    const docRef = await db.collection('timeTracking').add({
                        userId: user.uid,
                        userName: user.displayName || 'Unbekannt',
                        clockIn: firebase.firestore.FieldValue.serverTimestamp(),
                        clockOut: null,
                        duration: null,
                        notes: '',
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    console.log('Clock in successful, doc ID:', docRef.id);
                    showToast('âœ“ Eingestempelt');
                } catch (err) {
                    console.error('Clock in error:', err);
                    showToast('Fehler beim Einstempeln: ' + err.message);
                }
            };

            const clockOut = async () => {
                if (!activeSession || !user) return;
                try {
                    console.log('Attempting to clock out, session ID:', activeSession.id);
                    const clockOutTime = firebase.firestore.Timestamp.now();
                    const clockInTime = activeSession.clockIn;
                    const durationMs = clockOutTime.toMillis() - clockInTime.toMillis();
                    const durationHours = (durationMs / (1000 * 60 * 60)).toFixed(2);

                    await db.collection('timeTracking').doc(activeSession.id).update({
                        clockOut: clockOutTime,
                        duration: parseFloat(durationHours)
                    });
                    console.log('Clock out successful');
                    showToast(`âœ“ Ausgestempelt (${durationHours}h)`);
                } catch (err) {
                    console.error('Clock out error:', err);
                    showToast('Fehler beim Ausstempeln: ' + err.message);
                }
            };

            const deleteEntry = async (entryId) => {
                if (!confirm('Eintrag wirklich lÃ¶schen?')) return;
                try {
                    console.log('Deleting entry:', entryId);
                    await db.collection('timeTracking').doc(entryId).delete();
                    showToast('âœ“ Eintrag gelÃ¶scht');
                } catch (err) {
                    console.error('Delete error:', err);
                    showToast('Fehler beim LÃ¶schen: ' + err.message);
                }
            };

            const startEdit = (entry) => {
                setEditingEntry(entry.id);
                const clockInDate = entry.clockIn?.toDate ? entry.clockIn.toDate() : new Date(entry.clockIn);
                const clockOutDate = entry.clockOut?.toDate ? entry.clockOut.toDate() : null;
                setEditForm({
                    clockIn: clockInDate.toISOString().slice(0, 16),
                    clockOut: clockOutDate ? clockOutDate.toISOString().slice(0, 16) : '',
                    notes: entry.notes || ''
                });
            };

            const cancelEdit = () => {
                setEditingEntry(null);
                setEditForm({ clockIn: '', clockOut: '', notes: '' });
            };

            const saveEdit = async (entryId) => {
                try {
                    console.log('Saving edit for entry:', entryId);
                    const clockInTime = firebase.firestore.Timestamp.fromDate(new Date(editForm.clockIn));
                    const clockOutTime = editForm.clockOut ? firebase.firestore.Timestamp.fromDate(new Date(editForm.clockOut)) : null;
                    
                    let duration = null;
                    if (clockOutTime) {
                        const durationMs = clockOutTime.toMillis() - clockInTime.toMillis();
                        duration = parseFloat((durationMs / (1000 * 60 * 60)).toFixed(2));
                    }

                    await db.collection('timeTracking').doc(entryId).update({
                        clockIn: clockInTime,
                        clockOut: clockOutTime,
                        duration: duration,
                        notes: editForm.notes
                    });
                    
                    setEditingEntry(null);
                    setEditForm({ clockIn: '', clockOut: '', notes: '' });
                    showToast('âœ“ Eintrag gespeichert');
                } catch (err) {
                    console.error('Save edit error:', err);
                    showToast('Fehler beim Speichern: ' + err.message);
                }
            };

            const getViewLabel = () => {
                if (viewType === 'week') {
                    const day = selectedMonth.getDay();
                    const diff = selectedMonth.getDate() - day + (day === 0 ? -6 : 1);
                    const monday = new Date(selectedMonth.getFullYear(), selectedMonth.getMonth(), diff);
                    const sunday = new Date(monday);
                    sunday.setDate(monday.getDate() + 6);
                    return `${monday.toLocaleDateString('de-DE', { day: '2-digit', month: '2-digit' })} - ${sunday.toLocaleDateString('de-DE', { day: '2-digit', month: '2-digit', year: 'numeric' })}`;
                } else if (viewType === 'month') {
                    return selectedMonth.toLocaleDateString('de-DE', { month: 'long', year: 'numeric' });
                } else {
                    return selectedMonth.getFullYear().toString();
                }
            };

            const navigatePeriod = (direction) => {
                const newDate = new Date(selectedMonth);
                if (viewType === 'week') {
                    newDate.setDate(newDate.getDate() + (direction * 7));
                } else if (viewType === 'month') {
                    newDate.setMonth(newDate.getMonth() + direction);
                } else {
                    newDate.setFullYear(newDate.getFullYear() + direction);
                }
                setSelectedMonth(newDate);
            };

            const formatTime = (timestamp) => {
                if (!timestamp) return '--:--';
                const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
                return date.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
            };

            const formatDate = (timestamp) => {
                if (!timestamp) return '';
                const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
                return date.toLocaleDateString('de-DE', { day: '2-digit', month: '2-digit', year: 'numeric' });
            };

            const formatDuration = (hours) => {
                if (!hours) return '0:00';
                const h = Math.floor(hours);
                const m = Math.round((hours - h) * 60);
                return `${h}:${m.toString().padStart(2, '0')}`;
            };

            const getElapsedTime = () => {
                if (!activeSession || !activeSession.clockIn) return '0:00:00';
                const start = activeSession.clockIn.toDate ? activeSession.clockIn.toDate() : new Date(activeSession.clockIn);
                const diff = Math.max(0, currentTime - start); // Ensure non-negative
                const hours = Math.floor(diff / (1000 * 60 * 60));
                const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((diff % (1000 * 60)) / 1000);
                return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            };

            const totalHours = timeEntries.reduce((sum, entry) => sum + (entry.duration || 0), 0);
            const completedEntries = timeEntries.filter(e => e.clockOut);
            const avgHoursPerDay = completedEntries.length > 0 ? (totalHours / completedEntries.length) : 0;

            if (loading) {
                return (
                    <div className="fixed inset-0 z-[200] bg-black/50 flex items-end md:items-center justify-center p-4 fade-in">
                        <div className="bg-white dark:bg-[#1E1E1E] rounded-[32px] w-full max-w-md p-8 text-center">
                            <div className="text-gray-400">Lade Zeiterfassung...</div>
                        </div>
                    </div>
                );
            }

            return (
                <div className="fixed inset-0 z-[200] bg-black/50 flex items-end md:items-center justify-center p-4 fade-in">
                    <div className="bg-white dark:bg-[#1E1E1E] rounded-[32px] w-full max-w-md max-h-[90vh] flex flex-col shadow-2xl slide-up">
                        <div className="p-6 border-b border-gray-100 dark:border-gray-800 flex justify-between items-center">
                            <h2 className="text-2xl font-bold dark:text-white">â±ï¸ Zeiterfassung</h2>
                            <button onClick={onClose} className="p-2 bg-gray-100 dark:bg-[#2D2D2D] dark:text-white rounded-full">
                                <Icon name="x" size={24}/>
                            </button>
                        </div>

                        <div className="flex-1 overflow-y-auto p-6">
                            {/* Active Session */}
                            {activeSession ? (
                                <div className="bg-gradient-to-br from-green-500 to-emerald-600 text-white rounded-3xl p-6 mb-6 shadow-lg">
                                    <div className="flex justify-between items-start mb-4">
                                        <div>
                                            <div className="text-sm opacity-90 mb-1">Aktive Sitzung</div>
                                            <div className="text-3xl font-bold">{getElapsedTime()}</div>
                                        </div>
                                        <div className="w-3 h-3 bg-white rounded-full animate-pulse"></div>
                                    </div>
                                    <div className="text-sm opacity-90 mb-4">
                                        Einstempeln: {formatTime(activeSession.clockIn)} Uhr
                                    </div>
                                    <button 
                                        onClick={clockOut}
                                        className="w-full bg-white text-green-600 font-bold py-3 rounded-2xl shadow-lg hover:shadow-xl transition-all"
                                    >
                                        ðŸ• Ausstempeln
                                    </button>
                                </div>
                            ) : (
                                <div className="bg-gradient-to-br from-blue-500 to-indigo-600 text-white rounded-3xl p-6 mb-6 shadow-lg">
                                    <div className="text-center mb-4">
                                        <div className="text-5xl mb-2">â±ï¸</div>
                                        <div className="text-xl font-bold mb-1">Bereit zum Stempeln</div>
                                        <div className="text-sm opacity-90">Keine aktive Sitzung</div>
                                    </div>
                                    <button 
                                        onClick={clockIn}
                                        className="w-full bg-white text-blue-600 font-bold py-3 rounded-2xl shadow-lg hover:shadow-xl transition-all"
                                    >
                                        ðŸ• Einstempeln
                                    </button>
                                </div>
                            )}

                            {/* Statistics */}
                            <div className="grid grid-cols-2 gap-4 mb-6">
                                <div className="bg-gray-50 dark:bg-[#2D2D2D] rounded-2xl p-4">
                                    <div className="text-xs text-gray-400 mb-1">Gesamt Stunden</div>
                                    <div className="text-2xl font-bold dark:text-white">{formatDuration(totalHours)}</div>
                                </div>
                                <div className="bg-gray-50 dark:bg-[#2D2D2D] rounded-2xl p-4">
                                    <div className="text-xs text-gray-400 mb-1">Ã˜ pro Tag</div>
                                    <div className="text-2xl font-bold dark:text-white">{formatDuration(avgHoursPerDay)}</div>
                                </div>
                            </div>

                            {/* View Type Selector */}
                            <div className="mb-4">
                                <div className="flex gap-2 bg-gray-100 dark:bg-[#2D2D2D] p-1 rounded-xl">
                                    <button 
                                        onClick={() => setViewType('week')}
                                        className={`flex-1 py-2 px-3 rounded-lg text-xs font-bold transition-all ${viewType === 'week' ? 'bg-white dark:bg-[#1E1E1E] text-black dark:text-white shadow' : 'text-gray-500'}`}
                                    >
                                        Woche
                                    </button>
                                    <button 
                                        onClick={() => setViewType('month')}
                                        className={`flex-1 py-2 px-3 rounded-lg text-xs font-bold transition-all ${viewType === 'month' ? 'bg-white dark:bg-[#1E1E1E] text-black dark:text-white shadow' : 'text-gray-500'}`}
                                    >
                                        Monat
                                    </button>
                                    <button 
                                        onClick={() => setViewType('year')}
                                        className={`flex-1 py-2 px-3 rounded-lg text-xs font-bold transition-all ${viewType === 'year' ? 'bg-white dark:bg-[#1E1E1E] text-black dark:text-white shadow' : 'text-gray-500'}`}
                                    >
                                        Jahr
                                    </button>
                                </div>
                            </div>

                            {/* Period Navigator & History Toggle */}
                            <div className="flex justify-between items-center mb-4">
                                <div className="flex items-center gap-2">
                                    <button 
                                        onClick={() => navigatePeriod(-1)}
                                        className="p-2 hover:bg-gray-100 dark:hover:bg-[#2D2D2D] rounded-lg"
                                    >
                                        <Icon name="chevronLeft" size={16}/>
                                    </button>
                                    <span className="text-sm font-bold dark:text-white min-w-[200px] text-center">
                                        {getViewLabel()}
                                    </span>
                                    <button 
                                        onClick={() => navigatePeriod(1)}
                                        className="p-2 hover:bg-gray-100 dark:hover:bg-[#2D2D2D] rounded-lg"
                                    >
                                        <Icon name="chevronRight" size={16}/>
                                    </button>
                                </div>
                                <button 
                                    onClick={() => setShowHistory(!showHistory)}
                                    className="text-xs bg-black dark:bg-white dark:text-black text-white px-3 py-2 rounded-full font-bold"
                                >
                                    {showHistory ? 'Verbergen' : 'Historie'}
                                </button>
                            </div>

                            {/* History */}
                            {showHistory && (
                                <div className="space-y-2">
                                    <h3 className="text-xs font-bold text-gray-400 uppercase mb-3">EintrÃ¤ge ({timeEntries.length})</h3>
                                    {timeEntries.length === 0 ? (
                                        <div className="text-center py-8 text-gray-400 text-sm">
                                            Keine EintrÃ¤ge fÃ¼r {viewType === 'week' ? 'diese Woche' : viewType === 'month' ? 'diesen Monat' : 'dieses Jahr'}
                                        </div>
                                    ) : (
                                        timeEntries.map(entry => (
                                            <div key={entry.id} className="bg-white dark:bg-[#2D2D2D] border border-gray-100 dark:border-gray-700 rounded-2xl p-4">
                                                {editingEntry === entry.id ? (
                                                    // Edit Mode
                                                    <div className="space-y-3">
                                                        <div>
                                                            <label className="text-xs text-gray-400 block mb-1">Einstempeln</label>
                                                            <input 
                                                                type="datetime-local" 
                                                                value={editForm.clockIn}
                                                                onChange={(e) => setEditForm({...editForm, clockIn: e.target.value})}
                                                                className="w-full bg-gray-50 dark:bg-[#1E1E1E] px-3 py-2 rounded-lg text-sm dark:text-white outline-none"
                                                            />
                                                        </div>
                                                        <div>
                                                            <label className="text-xs text-gray-400 block mb-1">Ausstempeln</label>
                                                            <input 
                                                                type="datetime-local" 
                                                                value={editForm.clockOut}
                                                                onChange={(e) => setEditForm({...editForm, clockOut: e.target.value})}
                                                                className="w-full bg-gray-50 dark:bg-[#1E1E1E] px-3 py-2 rounded-lg text-sm dark:text-white outline-none"
                                                            />
                                                        </div>
                                                        <div>
                                                            <label className="text-xs text-gray-400 block mb-1">Notizen</label>
                                                            <input 
                                                                type="text" 
                                                                value={editForm.notes}
                                                                onChange={(e) => setEditForm({...editForm, notes: e.target.value})}
                                                                placeholder="Optional..."
                                                                className="w-full bg-gray-50 dark:bg-[#1E1E1E] px-3 py-2 rounded-lg text-sm dark:text-white outline-none"
                                                            />
                                                        </div>
                                                        <div className="flex gap-2">
                                                            <button 
                                                                onClick={() => saveEdit(entry.id)}
                                                                className="flex-1 bg-green-500 text-white py-2 rounded-lg text-xs font-bold hover:bg-green-600"
                                                            >
                                                                âœ“ Speichern
                                                            </button>
                                                            <button 
                                                                onClick={cancelEdit}
                                                                className="flex-1 bg-gray-300 dark:bg-gray-600 text-gray-700 dark:text-white py-2 rounded-lg text-xs font-bold hover:bg-gray-400 dark:hover:bg-gray-700"
                                                            >
                                                                Abbrechen
                                                            </button>
                                                        </div>
                                                    </div>
                                                ) : (
                                                    // View Mode
                                                    <>
                                                        <div className="flex justify-between items-start mb-2">
                                                            <div className="text-sm font-bold dark:text-white">
                                                                {formatDate(entry.clockIn)}
                                                            </div>
                                                            {entry.duration && (
                                                                <div className="text-sm font-bold text-green-600">
                                                                    {formatDuration(entry.duration)}
                                                                </div>
                                                            )}
                                                        </div>
                                                        <div className="flex items-center gap-4 text-xs text-gray-500 mb-3">
                                                            <div className="flex items-center gap-1">
                                                                <span>ðŸ• {formatTime(entry.clockIn)}</span>
                                                            </div>
                                                            {entry.clockOut ? (
                                                                <div className="flex items-center gap-1">
                                                                    <span>â†’ {formatTime(entry.clockOut)}</span>
                                                                </div>
                                                            ) : (
                                                                <div className="text-orange-500 font-bold">â— Aktiv</div>
                                                            )}
                                                        </div>
                                                        {entry.notes && (
                                                            <div className="text-xs text-gray-400 mb-3 italic">"{entry.notes}"</div>
                                                        )}
                                                        <div className="flex gap-2 border-t border-gray-100 dark:border-gray-700 pt-3">
                                                            <button 
                                                                onClick={() => startEdit(entry)}
                                                                className="flex-1 bg-blue-50 dark:bg-blue-900/20 text-blue-600 dark:text-blue-400 py-2 rounded-lg text-xs font-bold hover:bg-blue-100 dark:hover:bg-blue-900/30"
                                                            >
                                                                âœï¸ Bearbeiten
                                                            </button>
                                                            <button 
                                                                onClick={() => deleteEntry(entry.id)}
                                                                className="flex-1 bg-red-50 dark:bg-red-900/20 text-red-600 dark:text-red-400 py-2 rounded-lg text-xs font-bold hover:bg-red-100 dark:hover:bg-red-900/30"
                                                            >
                                                                ðŸ—‘ï¸ LÃ¶schen
                                                            </button>
                                                        </div>
                                                    </>
                                                )}
                                            </div>
                                        ))
                                    )}
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // --- APP ---
        const App = () => {
            const [user, setUser] = useState(null);
            const [userData, setUserData] = useState({});
            const [categories, setCategories] = useState(DEFAULT_CATEGORIES);
            const [isDemo, setIsDemo] = useState(false);
            const [darkMode, setDarkMode] = useState(localStorage.getItem('theme') === 'dark');
            
            const [deviceReady, setDeviceReady] = useState(!window.cordova);

            useEffect(() => {
                if (!window.cordova) return;
                const onReady = () => setDeviceReady(true);
                document.addEventListener('deviceready', onReady, false);
                return () => document.removeEventListener('deviceready', onReady, false);
            }, []);

            const [myCalendars, setMyCalendars] = useState([]);
            const [activeCalendarId, setActiveCalendarId] = useState(null);
            const [events, setEvents] = useState([]);
            const [requests, setRequests] = useState([]);
            
            // Shift Plan & Drag Selection
            const [shiftMode, setShiftMode] = useState(false);
            const [showShiftSelector, setShowShiftSelector] = useState(false);
            const [dragSelection, setDragSelection] = useState({ start: null, end: null, isDragging: false });
            
            // Standard UI
            const [currentDate, setCurrentDate] = useState(new Date());
            const [selectedDate, setSelectedDate] = useState(new Date());
            const [showAddEventModal, setShowAddEventModal] = useState(false);
            const [showSettingsModal, setShowSettingsModal] = useState(false);
            const [showCategoryEditor, setShowCategoryEditor] = useState(false);
            const [showSearchModal, setShowSearchModal] = useState(false);
            const [showCalendarSwitcher, setShowCalendarSwitcher] = useState(false);
            const [showRequestPopup, setShowRequestPopup] = useState(false);
            const [toast, setToast] = useState(null);
            const [expandedEventId, setExpandedEventId] = useState(null);
            // Archiv (Hidden)
            const [showVaultPanel, setShowVaultPanel] = useState(false);
            // Time Tracking
            const [showTimeTrackingPanel, setShowTimeTrackingPanel] = useState(false);
            const [notificationsEnabled, setNotificationsEnabled] = useState(localStorage.getItem('pw_notify') === '1');
            
            // New feature states
            const [showHabitsPanel, setShowHabitsPanel] = useState(false);
            const [showTemplatesModal, setShowTemplatesModal] = useState(false);
            const [showDayCopyModal, setShowDayCopyModal] = useState(false);
            const [showConflictModal, setShowConflictModal] = useState(false);
            const [conflictInfo, setConflictInfo] = useState(null);
            const [editMode, setEditMode] = useState(false);
            const [selectedEvents, setSelectedEvents] = useState([]);
            const [themeMode, setThemeMode] = useState(localStorage.getItem('pw_themeMode') || 'light');
            const [themePalette, setThemePalette] = useState(localStorage.getItem('pw_themePalette') || 'default');
            const secretHoldTimerRef = useRef(null);
            const secretHoldTriggeredRef = useRef(false);
            const secretNotifRef = useRef({ loaded: false, last: {} });

            const [todayBlinkToken, setTodayBlinkToken] = useState(0);
            const triggerTodayBlink = () => {
                const t = Date.now();
                setTodayBlinkToken(t);
                setTimeout(() => setTodayBlinkToken(cur => (cur === t ? 0 : cur)), 12000);
            };

            useEffect(() => {
                localStorage.setItem('pw_notify', notificationsEnabled ? '1' : '0');
            }, [notificationsEnabled]);

            // Berechtigungen beim Start (Kamera/Mikrofon/Speicher)
            const [permGateOpen, setPermGateOpen] = useState(false);
            const [permGateBusy, setPermGateBusy] = useState(false);
            const [permInfo, setPermInfo] = useState({ cam: 'unbekannt', mic: 'unbekannt', store: 'unbekannt' });

            // Cordova (Android): Runtime-Permissions via cordova-plugin-android-permissions
            const isCordovaAndroid = !!window.cordova && deviceReady && (window.cordova.platformId === 'android');
            const cordovaPerms = isCordovaAndroid && window.cordova.plugins && window.cordova.plugins.permissions ? window.cordova.plugins.permissions : null;

            const cordovaHasPerm = (perm) => new Promise((resolve) => {
                if (!cordovaPerms || !perm) return resolve(false);
                try {
                    cordovaPerms.hasPermission(perm, (s) => resolve(!!s.hasPermission), () => resolve(false));
                } catch (e) { resolve(false); }
            });

            const cordovaRequestPerms = (perms) => new Promise((resolve) => {
                if (!cordovaPerms || !perms || !perms.length) return resolve(true);
                try {
                    cordovaPerms.requestPermissions(perms, () => resolve(true), () => resolve(false));
                } catch (e) { resolve(false); }
            });

            const getWantedPerms = () => {
                if (!cordovaPerms) return [];
                const p = cordovaPerms;
                const list = [];
                if (p.CAMERA) list.push(p.CAMERA);
                if (p.RECORD_AUDIO) list.push(p.RECORD_AUDIO);
                if (p.POST_NOTIFICATIONS) list.push(p.POST_NOTIFICATIONS);
                if (p.READ_MEDIA_IMAGES) list.push(p.READ_MEDIA_IMAGES);
                else if (p.READ_EXTERNAL_STORAGE) list.push(p.READ_EXTERNAL_STORAGE);
                if (p.READ_MEDIA_AUDIO) list.push(p.READ_MEDIA_AUDIO);
                return list;
            };


            const queryPerm = async (name) => {
                try {
                    if (!navigator.permissions?.query) return 'unbekannt';
                    const r = await navigator.permissions.query({ name });
                    return r?.state || 'unbekannt';
                } catch (e) {
                    return 'unbekannt';
                }
            };

            const refreshPermInfo = async () => {
                if (cordovaPerms) {
                    const camOk = await cordovaHasPerm(cordovaPerms.CAMERA);
                    const micOk = await cordovaHasPerm(cordovaPerms.RECORD_AUDIO);

                    let storeOk = false;
                    if (cordovaPerms.READ_MEDIA_IMAGES) storeOk = await cordovaHasPerm(cordovaPerms.READ_MEDIA_IMAGES);
                    else if (cordovaPerms.READ_EXTERNAL_STORAGE) storeOk = await cordovaHasPerm(cordovaPerms.READ_EXTERNAL_STORAGE);

                    setPermInfo({
                        mic: micOk ? 'aktiv' : 'nicht aktiv',
                        cam: camOk ? 'aktiv' : 'nicht aktiv',
                        store: storeOk ? 'aktiv' : 'nicht aktiv'
                    });
                    return;
                }

                const mic = await queryPerm('microphone');
                // 'camera' wird nicht Ã¼berall unterstÃ¼tzt
                const cam = await queryPerm('camera');

                let store = 'unbekannt';
                try {
                    if (navigator.storage?.persisted) {
                        const persisted = await navigator.storage.persisted();
                        store = persisted ? 'aktiv' : 'nicht aktiv';
                    }
                } catch (e) {}

                setPermInfo({
                    mic: mic === 'granted' ? 'aktiv' : (mic === 'denied' ? 'blockiert' : 'unbekannt'),
                    cam: cam === 'granted' ? 'aktiv' : (cam === 'denied' ? 'blockiert' : 'unbekannt'),
                    store
                });
            };

            useEffect(() => {
                if (!user || isDemo) return;
                // bei jedem Start prÃ¼fen; Overlay nur bis erfolgreich
                refreshPermInfo().finally(() => {
                    if (localStorage.getItem('pw_perm_done') !== '1') setPermGateOpen(true);
                });
            }, [user, isDemo]);

            const requestStartupPerms = async () => {
                // Cordova (Android): direkt via Runtime-Permissions (ohne Secure-Context-Anforderung)
                if (cordovaPerms) {
                    setPermGateBusy(true);
                    const ok = await cordovaRequestPerms(getWantedPerms());
                    await refreshPermInfo();
                    setPermGateBusy(false);

                    if (ok) {
                        localStorage.setItem('pw_perm_done', '1');
                        setPermGateOpen(false);
                        showToast('Berechtigungen gesetzt.');
                    } else {
                        showToast('Berechtigungen verweigert.');
                    }
                    return;
                }

                if (!navigator.mediaDevices?.getUserMedia) {
                    showToast('Kamera/Mikrofon im Browser nicht verfÃ¼gbar.');
                    return;
                }

                const proto = (location.protocol || '').toLowerCase();
                const host = (location.hostname || '').toLowerCase();
                const isProbablySecure = !!window.isSecureContext
                    || proto === 'https:'
                    || proto === 'capacitor:'
                    || proto === 'ionic:'
                    || host === 'localhost'
                    || host === '127.0.0.1';

                if (!isProbablySecure) {
                    showToast('BenÃ¶tigt HTTPS/localhost (APK: AssetLoader/Capacitor).');
                    return;
                }

                setPermGateBusy(true);

                let micOk = false;
                let camOk = false;

                try {
                    const s = await navigator.mediaDevices.getUserMedia({ audio: true });
                    micOk = true;
                    try { s.getTracks().forEach(t => t.stop()); } catch(e){}
                } catch (e) {}

                try {
                    const s = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
                    camOk = true;
                    try { s.getTracks().forEach(t => t.stop()); } catch(e){}
                } catch (e) {}

                try {
                    if (navigator.storage?.persist) await navigator.storage.persist();
                } catch (e) {}

                await refreshPermInfo();

                if (micOk && camOk) {
                    localStorage.setItem('pw_perm_done', '1');
                    setPermGateOpen(false);
                    showToast('Berechtigungen aktiv.');
                } else {
                    showToast('Berechtigungen unvollstÃ¤ndig.');
                }

                setPermGateBusy(false);
            };


            const [newEvent, setNewEvent] = useState({ title: '', description: '', time: '12:00', category: 'Arbeit', subCategory: '', targetCalId: '', recurrence: false, durationMin: 60, emoji: '', isFocus: false });
            const [quickAddText, setQuickAddText] = useState('');
            const [searchName, setSearchName] = useState('');
            const [expandedSettingsId, setExpandedSettingsId] = useState(null);
            const [editName, setEditName] = useState('');
            const [editCalendarName, setEditCalendarName] = useState('');
            
            // Neue Search States
            const [calendarSearchTerm, setCalendarSearchTerm] = useState('');
            const [memberAddName, setMemberAddName] = useState('');

            const [newCatName, setNewCatName] = useState('');
            const [newSubCatName, setNewSubCatName] = useState('');
            const [expandedCatEdit, setExpandedCatEdit] = useState(null);
            const [newShift, setNewShift] = useState({ name: '', time: '', color: '#10B981' });

            const showToast = (msg) => { setToast(msg); setTimeout(() => setToast(null), 3000); };
            const requestNotifications = async () => {
                if (!('Notification' in window)) {
                    showToast('Browser unterstÃ¼tzt keine Benachrichtigungen.');
                    return;
                }
                const perm = await Notification.requestPermission();
                if (perm === 'granted') {
                    setNotificationsEnabled(true);
                    showToast('Benachrichtigungen aktiviert.');
                } else {
                    setNotificationsEnabled(false);
                    showToast('Benachrichtigungen nicht freigegeben.');
                }
            };

            const activeCalendar = myCalendars.find(c => c.id === activeCalendarId);
            const hasShiftPlan = !!activeCalendar?.shiftEnabled;

            useEffect(() => { document.getElementById('loading').style.display = 'none'; }, []);
            useEffect(() => { 
                document.body.className = `transition-colors duration-300 ${darkMode ? 'bg-[#121212] text-white dark' : 'bg-[#F8F9FA] text-[#1D1D1F]'}`;
                localStorage.setItem('theme', darkMode ? 'dark' : 'light');
            }, [darkMode]);

            useEffect(() => {
                return auth.onAuthStateChanged((u) => {
                    setUser(u);
                    if (u) {
                        setEditName(u.displayName || '');
                        return db.collection('users').doc(u.uid).onSnapshot(d => {
                            if(d.exists) {
                            const data = d.data();
                            setUserData(data);
                            if(data.categories) setCategories(data.categories);

                            // Backfill Secret-ID (fÃ¼r bestehende Accounts)
                            if (!data.secretId) {
                                const sid = generateSecretId();
                                db.collection('users').doc(u.uid).update({ secretId: sid }).catch(()=>{});
                            }
                        }
                        });
                    }
                });
            }, [isDemo]);

            useEffect(() => {
                if (!user || isDemo) return;
                const q = db.collection('calendars').where('memberIds', 'array-contains', user.uid);
                return q.onSnapshot(snapshot => {
                    const cals = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    setMyCalendars(cals);
                    if (!activeCalendarId && cals.length > 0) setActiveCalendarId(cals[0].id);
                    else if (cals.length === 0) createNewCalendar('Mein Kalender');
                    
                    if (activeCalendarId !== ALL_CALENDARS && activeCalendarId && !cals.find(c => c.id === activeCalendarId)) {
                        setActiveCalendarId(cals.length > 0 ? cals[0].id : null);
                    }
                });
            }, [user, isDemo, activeCalendarId]);

            useEffect(() => {
                if (!user || isDemo) return;

                // Initiale Snapshot-Loads nicht als "neu" behandeln
                secretNotifRef.current.loaded = false;

                const q = db.collection('secretConversations').where('memberIds', 'array-contains', user.uid);
                return q.onSnapshot((snap) => {
                    const docs = snap.docs.map(d => ({ id: d.id, ...d.data() }));

                    if (!secretNotifRef.current.loaded) {
                        docs.forEach(c => {
                            const ts = c.lastMessageAt?.toMillis?.() || 0;
                            secretNotifRef.current.last[c.id] = ts;
                        });
                        secretNotifRef.current.loaded = true;
                        return;
                    }

                    snap.docChanges().forEach(ch => {
                        if (ch.type !== 'modified' && ch.type !== 'added') return;
                        const d = ch.doc.data() || {};
                        if (d.lastSenderId === user.uid) return;

                        const ts = d.lastMessageAt?.toMillis?.() || 0;
                        const prev = secretNotifRef.current.last[ch.doc.id] || 0;
                        if (ts && ts > prev) {
                            secretNotifRef.current.last[ch.doc.id] = ts;

                            // UI-Signal: heutiges Datum hervorheben
                            triggerTodayBlink();

                            // Optional: System-Notification (nur wenn freigegeben)
                            if (notificationsEnabled && ('Notification' in window) && Notification.permission === 'granted') {
                                try { new Notification('PlanWise', { body: 'Neuer Eintrag' }); } catch(e){}
                            }
                        }
                    });
                });
            }, [user, isDemo, notificationsEnabled]);
            useEffect(() => {
                if (isDemo && activeCalendarId === 'demo') {
                    setEvents([{id: '1', title: 'Demo', date: new Date(), time: '10:00', category: 'Arbeit', createdByName: 'Demo', calendarId: 'demo'}]);
                    setMyCalendars([{id: 'demo', name: 'Demo Kalender', color: CALENDAR_COLORS[1].hex, members: []}]);
                    return;
                }
                if (!user || myCalendars.length === 0) return;

                const calendarsToFetch = activeCalendarId === ALL_CALENDARS ? myCalendars : myCalendars.filter(c => c.id === activeCalendarId);
                const unsubscribers = calendarsToFetch.map(cal => {
                    const unsub1 = db.collection('calendars').doc(cal.id).collection('events').onSnapshot(snap => {
                        const newEvents = snap.docs.map(d => ({ id: d.id, ...d.data(), date: d.data().date?.toDate(), calendarId: cal.id }));
                        setEvents(prev => {
                            const others = prev.filter(p => p.calendarId !== cal.id);
                            return [...others, ...newEvents];
                        });
                    });
                    const unsub2 = db.collection('calendars').doc(cal.id).collection('requests').onSnapshot(snap => {
                        const reqs = snap.docs.map(d => ({ id: d.id, ...d.data(), date: d.data().date?.toDate(), calendarId: cal.id }));
                        setRequests(prev => {
                            const others = prev.filter(p => p.calendarId !== cal.id);
                            const merged = [...others, ...reqs];
                            if (merged.length > 0 && !showRequestPopup) setShowRequestPopup(true);
                            return merged;
                        });
                    });
                    return () => { unsub1(); unsub2(); };
                });
                return () => unsubscribers.forEach(u => u());
            }, [activeCalendarId, myCalendars, user, isDemo]);

            // --- TOUCH / DRAG FIX (WICHTIG) ---
            const handleTouchMove = (e) => {
                if (!dragSelection.isDragging) return;
                
                // Verhindert Scrollen beim "Malen"
                if (e.cancelable) e.preventDefault();

                const touch = e.touches[0];
                const target = document.elementFromPoint(touch.clientX, touch.clientY);
                
                if (target) {
                    const btn = target.closest('button[data-date]');
                    if (btn) {
                        const dateStr = btn.getAttribute('data-date');
                        const d = new Date(dateStr);
                        setDragSelection(prev => ({ ...prev, end: d }));
                    }
                }
            };

            const isWorkCalendarActive = () => {
                if (activeCalendarId === ALL_CALENDARS) return false;
                const cal = myCalendars.find(c => c.id === activeCalendarId);
                const n = (cal?.name || '').toLowerCase();
                return !!cal?.isWorkCalendar || n.includes('arbeit') || n.includes('work');
            };

            const startSecretHold = (d) => {
                // Hidden trigger: 3 Sekunden Langdruck auf den 5. (nur im Arbeitskalender)
                if (!user || isDemo) return;
                if (shiftMode) return;
                if (!isWorkCalendarActive()) return;
                if (d.getDate() !== 5) return;
                if (!canUseSecretCrypto()) {
                    showToast('Archiv: benÃ¶tigt HTTPS/localhost (WebCrypto).');
                    return;
                }

                if (secretHoldTimerRef.current) clearTimeout(secretHoldTimerRef.current);
                secretHoldTriggeredRef.current = false;

                secretHoldTimerRef.current = setTimeout(() => {
                    secretHoldTriggeredRef.current = true;
                    setShowVaultPanel(true);
                }, 3000);
            };

            const cancelSecretHold = () => {
                if (secretHoldTimerRef.current) {
                    clearTimeout(secretHoldTimerRef.current);
                    secretHoldTimerRef.current = null;
                }
            };

            const handlePointerDown = (d) => {
                startSecretHold(d);

                if (shiftMode && hasShiftPlan) {
                    setDragSelection({ start: d, end: d, isDragging: true });
                } else {
                    setSelectedDate(d);
                }
            };

            const handlePointerEnter = (d) => {
                if (dragSelection.isDragging) {
                    setDragSelection(prev => ({ ...prev, end: d }));
                }
            };

            // Global Touch End Listener to stop painting
            useEffect(() => {
                const handleGlobalUp = () => {
                    // Stoppt Langdruck-Trigger sauber
                    cancelSecretHold();

                    if (showShiftSelector) return;
                    if (dragSelection.isDragging && dragSelection.start && dragSelection.end) {
                        setDragSelection(prev => ({ ...prev, isDragging: false }));
                        setShowShiftSelector(true);
                    } else {
                        setDragSelection({ start: null, end: null, isDragging: false });
                    }
                };
                window.addEventListener('mouseup', handleGlobalUp);
                window.addEventListener('touchend', handleGlobalUp);
                return () => {
                    window.removeEventListener('mouseup', handleGlobalUp);
                    window.removeEventListener('touchend', handleGlobalUp);
                };
            }, [dragSelection, showShiftSelector]);

            const getDatesInRange = (start, end) => {
                if (!start || !end) return [];
                const dates = [];
                const s = new Date(Math.min(start, end));
                const e = new Date(Math.max(start, end));
                while (s <= e) {
                    dates.push(new Date(s));
                    s.setDate(s.getDate() + 1);
                }
                return dates;
            };

            const isInSelection = (d) => {
                if (!dragSelection.start || !dragSelection.end) return false;
                const s = new Date(Math.min(dragSelection.start, dragSelection.end));
                const e = new Date(Math.max(dragSelection.start, dragSelection.end));
                return d >= s && d <= e;
            };

            // --- DATA FUNCTIONS ---
            const createNewCalendar = async (name) => {
                if (!user || isDemo) return;
                await db.collection('calendars').add({
                    name: name, color: CALENDAR_COLORS[Math.floor(Math.random()*CALENDAR_COLORS.length)].hex, 
                    createdBy: user.uid, createdAt: firebase.firestore.FieldValue.serverTimestamp(), 
                    members: [{ uid: user.uid, role: ROLES.ADMIN, name: user.displayName }], memberIds: [user.uid], isWorkCalendar: false
                });
                showToast("Kalender erstellt");
            };

            const updateCalendar = async (calId, data) => {
                if (!user || isDemo) return;
                try {
                    await db.collection('calendars').doc(calId).update(data);
                    showToast("Aktualisiert");
                } catch(e) { showToast("Fehler"); }
            };

            const handleDeleteCalendar = async (calId) => {
                if (!user || !confirm("WARNUNG: Kalender unwiderruflich lÃ¶schen?")) return;
                try {
                    setExpandedSettingsId(null);
                    await db.collection('calendars').doc(calId).delete();
                    showToast("GelÃ¶scht");
                } catch(e) { showToast("Fehler: " + e.message); }
            };

            // MEMBER FUNCTIONS
            const addMemberToCalendar = async (calId) => {
                if (!memberAddName.trim()) return;
                try {
                    const snap = await db.collection('users').where('username', '==', memberAddName.trim()).get();
                    if (snap.empty) { showToast("User nicht gefunden"); return; }
                    const newUser = snap.docs[0].data();
                    
                    const cal = myCalendars.find(c => c.id === calId);
                    if (cal?.memberIds?.includes(newUser.uid)) { showToast("Bereits Mitglied"); return; }
                    
                    await db.collection('calendars').doc(calId).update({
                        memberIds: firebase.firestore.FieldValue.arrayUnion(newUser.uid),
                        members: firebase.firestore.FieldValue.arrayUnion({ uid: newUser.uid, name: newUser.username, role: ROLES.EDITOR })
                    });
                    setMemberAddName('');
                    showToast("HinzugefÃ¼gt");
                } catch(e) { showToast("Fehler"); }
            };

            const removeMemberFromCalendar = async (calId, memberUid) => {
                if (!confirm("Mitglied entfernen?")) return;
                const cal = myCalendars.find(c => c.id === calId);
                if (!cal) { showToast("Kalender nicht gefunden"); return; }
                const updatedMembers = cal.members.filter(m => m.uid !== memberUid);
                const updatedIds = cal.memberIds.filter(id => id !== memberUid);
                await db.collection('calendars').doc(calId).update({ members: updatedMembers, memberIds: updatedIds });
            };

            const handleCreateEvent = async (isRequest = false) => {
                if(isDemo) return;
                let targetId = activeCalendarId === ALL_CALENDARS ? newEvent.targetCalId : activeCalendarId;
                if (!targetId) { showToast("Bitte Kalender wÃ¤hlen"); return; }

                const d = new Date(selectedDate);
                const [h,m] = newEvent.time.split(':');
                d.setHours(parseInt(h), parseInt(m));
                
                const eventData = {
                    title: newEvent.title, 
                    description: newEvent.description || '', 
                    date: firebase.firestore.Timestamp.fromDate(d), 
                    category: newEvent.category, 
                    subCategory: newEvent.subCategory, 
                    createdBy: user.uid, 
                    createdByName: user.displayName, 
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(), 
                    recurrence: newEvent.recurrence ? 'yearly' : null,
                    durationMin: newEvent.durationMin || 60,
                    emoji: newEvent.emoji || '',
                    isFocus: newEvent.isFocus || false
                };
                
                // Check for conflicts (only for non-requests)
                if (!isRequest) {
                    const testEvent = { date: d, durationMin: eventData.durationMin, calendarId: targetId };
                    const conflicts = checkEventConflicts(
                        events.filter(e => e.calendarId === targetId),
                        testEvent
                    );
                    
                    if (conflicts.length > 0) {
                        const nextSlot = suggestNextFreeSlot(events, d, eventData.durationMin);
                        setConflictInfo({
                            conflicts,
                            suggestedTime: nextSlot,
                            eventData,
                            targetId,
                            isRequest: false
                        });
                        setShowConflictModal(true);
                        return;
                    }
                }
                
                const coll = isRequest ? 'requests' : 'events';
                await db.collection('calendars').doc(targetId).collection(coll).add(eventData);
                setShowAddEventModal(false);
                setNewEvent({ ...newEvent, title: '', description: '', emoji: '', isFocus: false });
                showToast(isRequest ? "Anfrage gesendet" : "Gespeichert");
            };

            const handleDeleteEvent = async (ev, isReq) => {
                 if(!isReq && !confirm("Termin lÃ¶schen?")) return;
                 const coll = isReq ? 'requests' : 'events';
                 await db.collection('calendars').doc(ev.calendarId || activeCalendarId).collection(coll).doc(ev.id).delete();
            };

            const handleAcceptRequest = async (req) => {
                 await db.collection('calendars').doc(req.calendarId).collection('events').add({ ...req, id: null });
                 await handleDeleteEvent(req, true);
                 showToast("Angenommen");
            };
            const handleDeclineRequest = async (reqId) => {
                const req = requests.find(r => r.id === reqId);
                if (!req) { showToast("Anfrage nicht gefunden"); return; }
                await handleDeleteEvent(req, true);
            };

            const toggleShiftEnabled = async (calId, enabled) => {
                await db.collection('calendars').doc(calId).update({ shiftEnabled: enabled });
            };

            const addShiftDefinition = async (calId) => {
                if (!newShift.name) return;
                const newDef = { ...newShift, id: Date.now().toString() };
                await db.collection('calendars').doc(calId).update({ 
                    shiftDefinitions: firebase.firestore.FieldValue.arrayUnion(newDef) 
                });
                setNewShift({ name: '', time: '', color: '#10B981' });
            };

            const deleteShiftDefinition = async (calId, shiftId) => {
                const cal = myCalendars.find(c => c.id === calId);
                const updated = (cal.shiftDefinitions || []).filter(s => s.id !== shiftId);
                await db.collection('calendars').doc(calId).update({ shiftDefinitions: updated });
            };

            const assignShift = async (shift) => {
                if (!dragSelection.start) return;
                const datesToUpdate = getDatesInRange(dragSelection.start, dragSelection.end);
                const batch = db.batch();
                const eventRef = db.collection('calendars').doc(activeCalendarId).collection('events');

                datesToUpdate.forEach(d => {
                    const existing = events.find(e => e.type === 'shift' && e.date.toDateString() === d.toDateString() && e.calendarId === activeCalendarId);
                    if (existing) batch.delete(eventRef.doc(existing.id));
                    if (shift) {
                        const newDoc = eventRef.doc();
                        batch.set(newDoc, {
                            type: 'shift', shiftId: shift.id, title: shift.name, date: firebase.firestore.Timestamp.fromDate(d),
                            color: shift.color, createdBy: user.uid, createdAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    }
                });
                await batch.commit();
                setShowShiftSelector(false);
                setDragSelection({ start: null, end: null, isDragging: false });
            };

            // CATEGORY LOGIC
            const saveCategories = async (newCats) => {
                setCategories(newCats);
                if(!isDemo && user) await db.collection('users').doc(user.uid).update({ categories: newCats });
            };
            const addMainCategory = () => { if(newCatName.trim()){ saveCategories({ ...categories, [newCatName.trim()]: [] }); setNewCatName(''); }};
            const addSubCategory = (main) => { if(newSubCatName.trim()){ const n={...categories}; n[main]=[...n[main],newSubCatName.trim()]; saveCategories(n); setNewSubCatName(''); }};
            const deleteMainCategory = (c) => { if(confirm("LÃ¶schen?")){ const n={...categories}; delete n[c]; saveCategories(n); }};
            const deleteSubCategory = (m,s) => { const n={...categories}; n[m]=n[m].filter(x=>x!==s); saveCategories(n); };

            // QUICK-ADD HANDLER
            const handleQuickAdd = () => {
                if (!quickAddText.trim()) return;
                const parsed = parseQuickAdd(quickAddText);
                
                if (parsed.title) {
                    setSelectedDate(parsed.date || new Date());
                    setNewEvent({
                        ...newEvent,
                        title: parsed.title,
                        time: parsed.time || newEvent.time,
                        durationMin: parsed.durationMin,
                        category: parsed.category || newEvent.category
                    });
                    setQuickAddText('');
                    showToast('Event vorbereitet');
                } else {
                    showToast('Titel fehlt');
                }
            };

            // DRAG & DROP HANDLERS
            const [draggedEvent, setDraggedEvent] = useState(null);
            const [dropTargetDate, setDropTargetDate] = useState(null);

            const handleDragStart = (ev, event) => {
                ev.dataTransfer.effectAllowed = 'move';
                setDraggedEvent(event);
            };

            const handleDragOver = (ev) => {
                ev.preventDefault();
                ev.dataTransfer.dropEffect = 'move';
            };

            const handleDrop = async (ev, targetDate) => {
                ev.preventDefault();
                if (!draggedEvent || isDemo) return;

                const newDate = new Date(targetDate);
                const oldDate = draggedEvent.date instanceof Date ? draggedEvent.date : draggedEvent.date.toDate();
                newDate.setHours(oldDate.getHours(), oldDate.getMinutes(), 0, 0);

                // Check conflicts
                const testEvent = { date: newDate, durationMin: draggedEvent.durationMin || 60, calendarId: draggedEvent.calendarId };
                const conflicts = checkEventConflicts(
                    events.filter(e => e.calendarId === draggedEvent.calendarId && e.id !== draggedEvent.id),
                    testEvent
                );

                if (conflicts.length > 0) {
                    const nextSlot = suggestNextFreeSlot(events, newDate, draggedEvent.durationMin || 60);
                    setConflictInfo({
                        conflicts,
                        suggestedTime: nextSlot,
                        draggedEvent,
                        targetDate: newDate,
                        isMove: true
                    });
                    setShowConflictModal(true);
                } else {
                    await db.collection('calendars').doc(draggedEvent.calendarId).collection('events')
                        .doc(draggedEvent.id).update({ date: firebase.firestore.Timestamp.fromDate(newDate) });
                    showToast('Event verschoben');
                }

                setDraggedEvent(null);
                setDropTargetDate(null);
            };

            // BATCH OPERATIONS
            const handleBatchDelete = async () => {
                if (!confirm(`${selectedEvents.length} Events lÃ¶schen?`)) return;
                const batch = db.batch();
                selectedEvents.forEach(evId => {
                    const ev = events.find(e => e.id === evId);
                    if (ev && ev.type !== 'shift') {
                        batch.delete(db.collection('calendars').doc(ev.calendarId).collection('events').doc(ev.id));
                    }
                });
                await batch.commit();
                setSelectedEvents([]);
                setEditMode(false);
                showToast('Events gelÃ¶scht');
            };

            const handleBatchMove = async (targetDate) => {
                if (!targetDate || selectedEvents.length === 0) return;
                
                for (const evId of selectedEvents) {
                    const ev = events.find(e => e.id === evId);
                    if (!ev || ev.type === 'shift') continue;
                    
                    const oldDate = ev.date instanceof Date ? ev.date : ev.date.toDate();
                    const newDate = new Date(targetDate);
                    newDate.setHours(oldDate.getHours(), oldDate.getMinutes(), 0, 0);
                    
                    // Check conflicts
                    const testEvent = { date: newDate, durationMin: ev.durationMin || 60, calendarId: ev.calendarId };
                    const conflicts = checkEventConflicts(
                        events.filter(e => e.calendarId === ev.calendarId && e.id !== ev.id),
                        testEvent
                    );
                    
                    if (conflicts.length > 0) {
                        showToast(`Konflikt bei ${ev.title}`);
                        continue;
                    }
                    
                    await db.collection('calendars').doc(ev.calendarId).collection('events')
                        .doc(ev.id).update({ date: firebase.firestore.Timestamp.fromDate(newDate) });
                }
                
                setSelectedEvents([]);
                setEditMode(false);
                showToast('Events verschoben');
            };

            // TEMPLATE APPLICATION
            const applyTemplate = async (templateKey, startDate, calendarId) => {
                const template = CALENDAR_TEMPLATES[templateKey];
                if (!template || !calendarId || isDemo) return;
                
                const batch = db.batch();
                const eventRef = db.collection('calendars').doc(calendarId).collection('events');
                
                template.events.forEach(tmplEv => {
                    const eventDate = new Date(startDate);
                    eventDate.setDate(eventDate.getDate() + tmplEv.day);
                    const [h, m] = tmplEv.time.split(':');
                    eventDate.setHours(parseInt(h), parseInt(m), 0, 0);
                    
                    const newDoc = eventRef.doc();
                    batch.set(newDoc, {
                        title: tmplEv.title,
                        description: '',
                        date: firebase.firestore.Timestamp.fromDate(eventDate),
                        category: tmplEv.category,
                        subCategory: '',
                        durationMin: tmplEv.durationMin,
                        emoji: tmplEv.emoji || '',
                        createdBy: user.uid,
                        createdByName: user.displayName,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                });
                
                await batch.commit();
                showToast(`Template "${template.name}" angewendet`);
                setShowTemplatesModal(false);
            };

            // DAY COPY
            const copyDayEvents = async (sourceDate, targetDate, calendarId) => {
                if (!sourceDate || !targetDate || !calendarId || isDemo) return;
                
                const sourceEvents = events.filter(ev => {
                    if (ev.type === 'shift' || !ev.date) return false;
                    const evDate = ev.date instanceof Date ? ev.date : ev.date.toDate();
                    return evDate.toDateString() === sourceDate.toDateString() && ev.calendarId === calendarId;
                });
                
                const batch = db.batch();
                const eventRef = db.collection('calendars').doc(calendarId).collection('events');
                
                sourceEvents.forEach(ev => {
                    const oldDate = ev.date instanceof Date ? ev.date : ev.date.toDate();
                    const newDate = new Date(targetDate);
                    newDate.setHours(oldDate.getHours(), oldDate.getMinutes(), 0, 0);
                    
                    const newDoc = eventRef.doc();
                    batch.set(newDoc, {
                        title: ev.title,
                        description: ev.description || '',
                        date: firebase.firestore.Timestamp.fromDate(newDate),
                        category: ev.category,
                        subCategory: ev.subCategory || '',
                        durationMin: ev.durationMin || 60,
                        emoji: ev.emoji || '',
                        isFocus: ev.isFocus || false,
                        createdBy: user.uid,
                        createdByName: user.displayName,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                });
                
                await batch.commit();
                showToast(`${sourceEvents.length} Events kopiert`);
                setShowDayCopyModal(false);
            };

            // FOCUS STATS
            const getFocusMinutesToday = () => {
                const today = new Date().toDateString();
                return events.filter(ev => {
                    if (!ev.date || !ev.isFocus) return false;
                    const evDate = ev.date instanceof Date ? ev.date : ev.date.toDate();
                    return evDate.toDateString() === today;
                }).reduce((sum, ev) => sum + (ev.durationMin || 60), 0);
            };

            const getFocusMinutesThisWeek = () => {
                const now = new Date();
                const weekStart = new Date(now);
                weekStart.setDate(now.getDate() - now.getDay() + 1); // Monday
                weekStart.setHours(0, 0, 0, 0);
                
                return events.filter(ev => {
                    if (!ev.date || !ev.isFocus) return false;
                    const evDate = ev.date instanceof Date ? ev.date : ev.date.toDate();
                    return evDate >= weekStart && evDate <= now;
                }).reduce((sum, ev) => sum + (ev.durationMin || 60), 0);
            };

            // THEME EFFECTS
            useEffect(() => {
                localStorage.setItem('pw_themeMode', themeMode);
                localStorage.setItem('pw_themePalette', themePalette);
                
                const root = document.documentElement;
                
                // Handle auto mode
                let effectiveMode = themeMode;
                if (themeMode === 'auto') {
                    const hour = new Date().getHours();
                    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                    effectiveMode = prefersDark || (hour < 6 || hour >= 18) ? 'dark' : 'light';
                }
                
                // Apply theme mode
                if (effectiveMode === 'dark') {
                    root.classList.add('dark');
                    setDarkMode(true);
                } else {
                    root.classList.remove('dark');
                    setDarkMode(false);
                }
                
                // Apply palette
                root.classList.remove('palette-nord', 'palette-dracula');
                if (themePalette === 'nord') {
                    root.classList.add('palette-nord');
                } else if (themePalette === 'dracula') {
                    root.classList.add('palette-dracula');
                }
            }, [themeMode, themePalette]);


            // RENDER
            const filteredEvents = events.filter(e => {
                if(!e.date) return false;
                if (activeCalendarId !== ALL_CALENDARS && e.calendarId && e.calendarId !== activeCalendarId) return false;
                const isSameDate = e.date.toDateString() === selectedDate.toDateString();
                const isRec = e.recurrence === 'yearly' && e.date.getDate() === selectedDate.getDate() && e.date.getMonth() === selectedDate.getMonth();
                return isSameDate || isRec;
            }).sort((a,b) => (a.time || "00:00").localeCompare(b.time || "00:00"));

            const activeCalName = activeCalendarId === ALL_CALENDARS ? "Alle Kalender" : myCalendars.find(c => c.id === activeCalendarId)?.name;
            const filteredSettingsCalendars = myCalendars.filter(c => c.name.toLowerCase().includes(calendarSearchTerm.toLowerCase()));

            if (!user && !isDemo) return <AuthScreen onLoginSuccess={()=>{}} onDemoStart={()=>{setIsDemo(true); setActiveCalendarId('demo');}} />;

            return (
                <div className="min-h-screen flex flex-col items-center p-4 pb-32 md:p-8 font-sans max-w-lg mx-auto select-none">

                    {permGateOpen && (
                        <div className="fixed inset-0 z-[300] bg-black/40 flex items-end md:items-center justify-center p-4 fade-in">
                            <div className="w-full max-w-md bg-white dark:bg-[#1E1E1E] rounded-[32px] p-6 shadow-2xl slide-up">
                                <div className="text-lg font-bold dark:text-white">Berechtigungen</div>
                                <div className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                                    FÃ¼r Kamera, Mikrofon und lokalen Speicher.
                                </div>

                                <div className="mt-4 space-y-2 text-sm">
                                    <div className="flex items-center justify-between">
                                        <div className="font-bold dark:text-white">Kamera</div>
                                        <div className="text-gray-500 dark:text-gray-300">{permInfo.cam}</div>
                                    </div>
                                    <div className="flex items-center justify-between">
                                        <div className="font-bold dark:text-white">Mikrofon</div>
                                        <div className="text-gray-500 dark:text-gray-300">{permInfo.mic}</div>
                                    </div>
                                    <div className="flex items-center justify-between">
                                        <div className="font-bold dark:text-white">Speicher</div>
                                        <div className="text-gray-500 dark:text-gray-300">{permInfo.store}</div>
                                    </div>
                                </div>

                                <div className="mt-5 flex gap-2">
                                    <button
                                        disabled={permGateBusy}
                                        onClick={requestStartupPerms}
                                        className="flex-1 p-3 rounded-2xl bg-black text-white dark:bg-white dark:text-black shadow-sm font-bold disabled:opacity-50"
                                    >
                                        {permGateBusy ? 'PrÃ¼feâ€¦' : 'Aktivieren'}
                                    </button>
                                    <button
                                        onClick={() => setPermGateOpen(false)}
                                        className="p-3 rounded-2xl bg-gray-100 dark:bg-[#2D2D2D] dark:text-white shadow-sm font-bold"
                                    >
                                        SpÃ¤ter
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}


                    
                    {/* Header */}
                    <div className="w-full flex justify-between items-center mb-6 z-10 relative">
                        <div className="relative">
                            <div onClick={() => setShowCalendarSwitcher(!showCalendarSwitcher)} className="cursor-pointer flex items-center gap-2">
                                <h1 className="text-2xl font-bold tracking-tight dark:text-white truncate max-w-[200px]">{activeCalName || 'Lade...'}</h1>
                                <Icon name="chevronDown" size={18} className="text-gray-400"/>
                            </div>
                            {showCalendarSwitcher && (
                                <div className="absolute top-10 left-0 bg-white dark:bg-[#1E1E1E] rounded-2xl shadow-xl border border-gray-100 dark:border-gray-800 p-2 w-56 z-20 slide-up">
                                    <button onClick={()=>{setActiveCalendarId(ALL_CALENDARS); setShowCalendarSwitcher(false);}} className={`w-full text-left px-4 py-3 rounded-xl flex itemscenter gap-3 ${activeCalendarId===ALL_CALENDARS ? 'bg-black text-white dark:bgwhite dark:text-black' : 'hover:bg-gray-50 dark:hover:bg-[#2D2D2D] dark:text-white'}`}>
                                        <Icon name="layers" size={16}/> <span className="font-bold text-sm">Alle Kalender</span>
                                    </button>
                                    <div className="h-px bg-gray-100 dark:bg-gray-800 my-1"></div>
                                    {myCalendars.map(cal => (
                                        <button key={cal.id} onClick={()=>{setActiveCalendarId(cal.id); setShowCalendarSwitcher(false);}} className={`w-full text-left px-4 py-2.5 rounded-xl flex items-center gap-3 ${activeCalendarId===cal.id ? 'bg-gray-100 dark:bg-[#2D2D2D] font-bold' : 'hover:bg-gray-50 dark:hover:bg-[#2D2D2D]'} dark:text-gray-200`}>
                                            <div className={`w-2 h-2 rounded-full ${CALENDAR_COLORS.find(c=>c.hex===cal.color)?.bg}`}/>
                                            <span className="text-sm truncate">{cal.name}</span>
                                        </button>
                                    ))}
                                </div>
                            )}
                        </div>
                        <div className="flex gap-2">
                            <button onClick={() => setCurrentDate(new Date())} className={`px-3 bg-white dark:bg-[#1E1E1E] rounded-2xl shadow-sm font-bold text-xs uppercase dark:text-white ${todayBlinkToken ? "blink-attn" : ""}`}>Heute</button>
                            <button onClick={() => setShowHabitsPanel(true)} className="p-3 bg-white dark:bg-[#1E1E1E] dark:text-white rounded-2xl shadow-sm" title="Habits">âœ…</button>
                            <button onClick={() => setShowTemplatesModal(true)} className="p-3 bg-white dark:bg-[#1E1E1E] dark:text-white rounded-2xl shadow-sm" title="Templates"><Icon name="layers"/></button>
                            <button onClick={() => setShowDayCopyModal(true)} className="p-3 bg-white dark:bg-[#1E1E1E] dark:text-white rounded-2xl shadow-sm" title="Tag kopieren"><Icon name="repeat"/></button>
                            <button onClick={() => setShowTimeTrackingPanel(true)} className="p-3 bg-white dark:bg-[#1E1E1E] dark:text-white rounded-2xl shadow-sm" title="Zeiterfassung"><Icon name="clock"/></button>
                            <button onClick={() => setShowSettingsModal(true)} className="p-3 bg-white dark:bg-[#1E1E1E] dark:text-white rounded-2xl shadow-sm"><Icon name="settings"/></button>
                            <button onClick={() => setShowAddEventModal(true)} className={`p-3 rounded-2xl shadow-lg transition-all text-white bg-black dark:bg-white dark:text-black`}><Icon name="plus"/></button>
                        </div>
                    </div>

                    {/* Calendar Grid */}
                    <div 
                        className="w-full bg-white dark:bg-[#1E1E1E] rounded-[32px] p-6 shadow-xl shadow-gray-100 dark:shadow-none mb-6 slide-up transition-colors relative overflow-hidden" 
                        style={{touchAction: 'none'}} 
                        onTouchMove={handleTouchMove}
                    >
                        <div className="flex justify-between items-center mb-6 dark:text-white">
                            <button
                                onClick={() => setCurrentDate(prev => { const d = new Date(prev); d.setMonth(d.getMonth() - 1, 1); return d; })}
                                className="p-2 hover:bg-gray-50 dark:hover:bg-[#2D2D2D] rounded-full"
                            >
                                <Icon name="chevronLeft" />
                            </button>
                            <span className="font-bold text-lg">{currentDate.toLocaleString('de-DE', { month: 'long', year: 'numeric' })}</span>
                            <button
                                onClick={() => setCurrentDate(prev => { const d = new Date(prev); d.setMonth(d.getMonth() + 1, 1); return d; })}
                                className="p-2 hover:bg-gray-50 dark:hover:bg-[#2D2D2D] rounded-full"
                            >
                                <Icon name="chevronRight" />
                            </button>
                        </div>
                        <div className="grid grid-cols-7 mb-2 text-center text-[10px] font-bold text-gray-400 uppercase">
                            {['Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa', 'So'].map(d => <div key={d}>{d}</div>)}
                        </div>
                        <div className="grid grid-cols-7 gap-y-2">
                            {(() => {
                                const y = currentDate.getFullYear(), m = currentDate.getMonth();
                                const todayStr = (new Date()).toDateString();
                                const days = new Date(y, m + 1, 0).getDate();
                                const off = (new Date(y, m, 1).getDay() || 7) - 1;
                                const cells = Array(off).fill(null).map((_, i) => <div key={`e-${i}`} />);
                                for (let i = 1; i <= days; i++) {
                                    const d = new Date(y, m, i);
                                    const isSel = d.toDateString() === selectedDate.toDateString();
                                    const isToday = d.toDateString() === todayStr;
                                    
                                    // Shift Check
                                    const shiftEvent = events.find(e => e.type === 'shift' && e.date && e.date.toDateString() === d.toDateString() && (activeCalendarId === ALL_CALENDARS || e.calendarId === activeCalendarId));
                                    
                                    // Selection Range Check
                                    const inDrag = isInSelection(d);

                                    // Dot Check
                                    const hasEvent = events.some(e => {
                                        if (e.type === 'shift') return false;
                                        if (e.recurrence === 'yearly') return e.date.getDate()===i && e.date.getMonth()===m;
                                        return e.date && e.date.toDateString() === d.toDateString();
                                    });
                                    let dotColor = 'bg-gray-400';
                                    if (hasEvent && activeCalendarId !== ALL_CALENDARS) {
                                        const cal = myCalendars.find(c => c.id === activeCalendarId);
                                        dotColor = CALENDAR_COLORS.find(c => c.hex === cal?.color)?.bg || 'bg-black';
                                    } else if (hasEvent) { dotColor = 'bg-black dark:bg-white'; }

                                    const cellStyle = shiftEvent ? { backgroundColor: shiftEvent.color + '60', color: 'inherit' } : {};
                                    const dragStyle = inDrag ? { backgroundColor: '#E5E7EB', color: 'black' } : {}; 

                                    cells.push(
                                        <div key={i} className="aspect-square flex justify-center items-center"
                                            onDragOver={handleDragOver}
                                            onDrop={(e) => handleDrop(e, d)}
                                        >
                                            <button 
                                                data-date={d.toISOString()}
                                                onMouseDown={() => handlePointerDown(d)}
                                                onMouseEnter={() => handlePointerEnter(d)}
                                                onTouchStart={() => handlePointerDown(d)}
                                                style={{...cellStyle, ...dragStyle, ...(shiftEvent ? {backgroundColor: shiftEvent.color} : {}) }}
                                                className={`w-10 h-10 rounded-2xl flex flex-col items-center justify-center transition-all relative ${(isToday && todayBlinkToken) ? 'blink-attn' : ''} ${isSel && !shiftEvent && !inDrag ? 'bg-black text-white dark:bg-white dark:text-black shadow-lg' : 'hover:bg-gray-50 dark:hover:bg-[#2D2D2D] dark:text-white'}`}
                                            >
                                                <span className={`text-sm font-medium relative z-10 ${shiftEvent ? 'text-white' : ''}`}>{i}</span>
                                                {!shiftEvent && <div className={`w-1 h-1 rounded-full mt-0.5 ${isSel ? 'bg-white dark:bg-black' : (hasEvent ? dotColor : 'bg-transparent')}`} />}
                                            </button>
                                        </div>
                                    );
                                }
                                return cells;
                            })()}
                        </div>
                    </div>

                    {/* SHIFT LEGEND */}
                    {hasShiftPlan && activeCalendarId !== ALL_CALENDARS && (activeCalendar?.shiftDefinitions||[]).length > 0 && (
                        <div className="w-full mb-6 px-4">
                            <div className="flex flex-wrap gap-3 justify-center">
                                {(activeCalendar.shiftDefinitions).map(def => (
                                    <div key={def.id} className="flex items-center gap-1.5 bg-white dark:bg-[#1E1E1E] px-3 py-1.5 rounded-full shadow-sm text-xs font-medium dark:text-gray-300">
                                        <div className="w-3 h-3 rounded-full" style={{backgroundColor: def.color}}></div>
                                        <span>{def.name}</span>
                                        <span className="opacity-50">{def.time}</span>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}

                    {/* Events List */}
                    <div className="w-full flex-1 slide-up">
                        <div className="flex items-center justify-between mb-4">
                            <h2 className="text-xs font-bold uppercase text-gray-400 ml-2">
                                {selectedDate.toLocaleDateString('de-DE', { weekday: 'long', day: 'numeric', month: 'long' })}
                            </h2>
                            {filteredEvents.filter(e => e.type !== 'shift').length > 0 && (
                                <button 
                                    onClick={() => { setEditMode(!editMode); setSelectedEvents([]); }}
                                    className={`px-3 py-1.5 rounded-full text-xs font-bold transition-all ${editMode ? 'bg-blue-500 text-white' : 'bg-gray-100 dark:bg-[#2D2D2D] dark:text-white'}`}
                                >
                                    {editMode ? 'Fertig' : 'Bearbeiten'}
                                </button>
                            )}
                        </div>
                        
                        {/* Batch Actions Bar */}
                        {editMode && selectedEvents.length > 0 && (
                            <div className="mb-4 p-3 bg-blue-50 dark:bg-blue-900/20 rounded-2xl flex gap-2">
                                <button 
                                    onClick={handleBatchDelete}
                                    className="flex-1 py-2 bg-red-500 text-white rounded-xl text-sm font-bold"
                                >
                                    <Icon name="trash" size={14} className="inline mr-1"/> LÃ¶schen ({selectedEvents.length})
                                </button>
                                <button 
                                    onClick={() => {
                                        const targetDateStr = prompt('Ziel-Datum (YYYY-MM-DD):', new Date().toISOString().split('T')[0]);
                                        if (targetDateStr) handleBatchMove(new Date(targetDateStr));
                                    }}
                                    className="flex-1 py-2 bg-blue-500 text-white rounded-xl text-sm font-bold"
                                >
                                    Verschieben
                                </button>
                            </div>
                        )}
                        
                        {/* Focus Stats (if there are focus events today) */}
                        {getFocusMinutesToday() > 0 && (
                            <div className="mb-4 p-4 bg-purple-50 dark:bg-purple-900/20 rounded-2xl">
                                <div className="flex items-center justify-between">
                                    <div>
                                        <p className="text-xs font-bold text-purple-600 dark:text-purple-400 uppercase">Fokus-Zeit</p>
                                        <p className="text-2xl font-bold text-purple-600 dark:text-purple-400">{getFocusMinutesToday()} min</p>
                                        <p className="text-xs text-gray-500 mt-1">Diese Woche: {getFocusMinutesThisWeek()} min</p>
                                    </div>
                                    <div className="text-4xl">ðŸŽ¯</div>
                                </div>
                            </div>
                        )}
                        
                        <div className="space-y-3">
                            {filteredEvents.filter(e => e.type !== 'shift').length === 0 ? <div className="text-center py-8 opacity-50 border-2 border-dashed dark:border-gray-800 rounded-3xl text-sm dark:text-gray-400">Keine Termine</div> : filteredEvents.filter(e => e.type !== 'shift').map(ev => {
                                const isExpanded = expandedEventId === ev.id;
                                const isSelected = selectedEvents.includes(ev.id);
                                const cal = myCalendars.find(c => c.id === ev.calendarId);
                                const color = CALENDAR_COLORS.find(c => c.hex === cal?.color) || CALENDAR_COLORS[0];
                                return (
                                    <div 
                                        key={ev.id} 
                                        draggable={!editMode && !isDemo}
                                        onDragStart={(e) => handleDragStart(e, ev)}
                                        className={`bg-white dark:bg-[#1E1E1E] rounded-3xl shadow-sm transition-all duration-300 overflow-hidden ${!editMode ? 'cursor-move event-draggable' : 'cursor-pointer'} ${isExpanded ? 'ring-1 ring-black/5 dark:ring-white/10' : ''} ${isSelected ? 'ring-2 ring-blue-500' : ''} ${ev.isFocus ? 'border-2 border-purple-300 dark:border-purple-600' : ''}`}
                                        onClick={() => editMode ? (isSelected ? setSelectedEvents(selectedEvents.filter(id => id !== ev.id)) : setSelectedEvents([...selectedEvents, ev.id])) : setExpandedEventId(isExpanded ? null : ev.id)}
                                    >
                                        <div className="p-4 flex items-center justify-between">
                                            <div className="flex items-center gap-4">
                                                {editMode && (
                                                    <input 
                                                        type="checkbox" 
                                                        className="custom-checkbox"
                                                        checked={isSelected}
                                                        onChange={() => {}}
                                                        onClick={(e) => e.stopPropagation()}
                                                    />
                                                )}
                                                <div className={`w-12 h-12 rounded-2xl flex items-center justify-center ${color.light} ${color.text} text-xl`}>
                                                    {ev.emoji || <Icon name={ev.isFocus ? "target" : ev.recurrence ? "repeat" : "calendar"} size={20} />}
                                                </div>
                                                <div>
                                                    <p className="font-bold text-sm text-gray-800 dark:text-white flex items-center gap-2">
                                                        {ev.title}
                                                        {ev.isFocus && <span className="text-xs bg-purple-100 dark:bg-purple-900/30 text-purple-600 dark:text-purple-400 px-2 py-0.5 rounded-full">Fokus</span>}
                                                    </p>
                                                    <div className="flex items-center gap-2 text-xs text-gray-500 dark:text-gray-400 mt-1">
                                                        <span>{ev.time}</span>
                                                        <span>â€¢</span>
                                                        <span>{ev.durationMin || 60} min</span>
                                                        {activeCalendarId === ALL_CALENDARS && <><span>â€¢</span><span className={`${color.text} font-bold px-1.5 py-0.5 rounded bg-white/50`}>{cal?.name}</span></>}
                                                    </div>
                                                </div>
                                            </div>
                                            {!editMode && <Icon name="chevronDown" size={16} className={`text-gray-400 transition-transform ${isExpanded ? 'rotate-180' : ''}`}/>}
                                        </div>
                                        {!editMode && (
                                            <div className={`details-wrapper ${isExpanded ? 'open' : ''} bg-gray-50 dark:bg-[#252525]`}>
                                                <div className="details-inner px-4 pb-4 pt-2 border-t border-gray-200 dark:border-gray-700">
                                                    <p className="text-xs text-gray-600 dark:text-gray-300 mb-3">{ev.description || 'Keine Notiz'}</p>
                                                    <div className="flex justify-between items-center text-[10px] text-gray-400 uppercase font-bold">
                                                        <span>{ev.createdByName}</span>
                                                        {!isDemo && <button onClick={(e) => { e.stopPropagation(); handleDeleteEvent(ev, false); }} className="flex gap-1 items-center text-red-500 bg-red-50 dark:bg-red-900/20 px-2 py-1 rounded"><Icon name="trash" size={12}/> LÃ¶schen</button>}
                                                    </div>
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                );
                            })}
                        </div>
                    </div>

                    {/* SHIFT BOTTOM BAR */}
                    {hasShiftPlan && activeCalendarId !== ALL_CALENDARS && (
                        <div className="fixed bottom-0 left-0 right-0 bg-white dark:bg-[#1E1E1E] border-t dark:border-gray-800 p-3 z-40 flex justify-center shadow-[0_-5px_20px_rgba(0,0,0,0.05)]">
                            <button onClick={() => setShiftMode(!shiftMode)} className={`flex items-center gap-2 px-6 py-3 rounded-2xl font-bold transition-all ${shiftMode ? 'bg-blue-500 text-white shadow-lg shadow-blue-500/30' : 'bg-gray-100 dark:bg-[#2D2D2D] dark:text-white'}`}>
                                <Icon name="briefcase" /> {shiftMode ? 'Pinsel-Modus AN' : 'Pinsel-Modus AUS'}
                            </button>
                        </div>
                    )}

                    {/* SETTINGS MODAL */}
                    {showSettingsModal && (
                        <div className="fixed inset-0 bg-white dark:bg-[#121212] z-50 flex flex-col slide-up">
                            <div className="px-6 py-6 border-b border-gray-100 dark:border-gray-800 flex justify-between items-center bg-white dark:bg-[#121212] sticky top-0">
                                <h2 className="text-2xl font-bold dark:text-white">Einstellungen</h2>
                                <button onClick={() => setShowSettingsModal(false)} className="p-2 bg-gray-100 dark:bg-[#1E1E1E] dark:text-white rounded-full"><Icon name="x" size={24}/></button>
                            </div>
                            <div className="p-6 overflow-y-auto flex-1 bg-[#F8F9FA] dark:bg-[#000000]">
                                
                                <div onClick={()=>setShowCategoryEditor(true)} className="bg-white dark:bg-[#1E1E1E] p-6 rounded-[32px] mb-6 shadow-sm flex justify-between items-center cursor-pointer">
                                    <div className="flex items-center gap-3">
                                        <div className="w-10 h-10 rounded-full bg-blue-50 text-blue-500 flex items-center justify-center"><Icon name="tag" size={20}/></div>
                                        <div><p className="font-bold dark:text-white">Kategorien</p><p className="text-xs text-gray-400">Verwalten</p></div>
                                    </div>
                                    <Icon name="chevronRight" className="text-gray-300"/>
                                </div>

                                <div className="bg-white dark:bg-[#1E1E1E] p-6 rounded-[32px] mb-6 shadow-sm">
                                    <h3 className="text-xs font-bold text-gray-400 uppercase mb-4">Profil</h3>
                                    <div className="flex items-center gap-4">
                                        <div className="w-12 h-12 rounded-full flex items-center justify-center text-white font-bold text-xl shadow-lg" style={{backgroundColor: userData.avatarColor || '#1D1D1F'}}>{editName?.charAt(0).toUpperCase()}</div>
                                        <div className="flex-1"><input className="w-full bg-transparent border-b border-gray-200 dark:border-gray-700 py-1 font-bold text-lg outline-none dark:text-white" value={editName} onChange={(e)=>setEditName(e.target.value)} onBlur={()=>user.updateProfile({displayName: editName})} /></div>
                                    </div>
                                </div>

                                {/* Theme Settings */}
                                <div className="bg-white dark:bg-[#1E1E1E] p-6 rounded-[32px] mb-6 shadow-sm">
                                    <h3 className="text-xs font-bold text-gray-400 uppercase mb-4">Design</h3>
                                    <div className="space-y-3">
                                        <div>
                                            <label className="text-xs font-bold text-gray-500 dark:text-gray-400 mb-2 block">Modus</label>
                                            <div className="flex gap-2">
                                                {['light', 'dark', 'auto'].map(mode => (
                                                    <button
                                                        key={mode}
                                                        onClick={() => setThemeMode(mode)}
                                                        className={`flex-1 py-2 rounded-xl text-sm font-bold transition-all ${themeMode === mode ? 'bg-black text-white dark:bg-white dark:text-black' : 'bg-gray-100 dark:bg-[#2D2D2D] dark:text-white'}`}
                                                    >
                                                        {mode === 'light' ? 'â˜€ï¸ Hell' : mode === 'dark' ? 'ðŸŒ™ Dunkel' : 'ðŸ¤– Auto'}
                                                    </button>
                                                ))}
                                            </div>
                                        </div>
                                        <div>
                                            <label className="text-xs font-bold text-gray-500 dark:text-gray-400 mb-2 block">Palette</label>
                                            <div className="flex gap-2">
                                                {[
                                                    { key: 'default', name: 'Default', colors: ['#000000', '#3B82F6', '#22C55E'] },
                                                    { key: 'nord', name: 'Nord', colors: ['#5E81AC', '#88C0D0', '#A3BE8C'] },
                                                    { key: 'dracula', name: 'Dracula', colors: ['#BD93F9', '#FF79C6', '#50FA7B'] }
                                                ].map(palette => (
                                                    <button
                                                        key={palette.key}
                                                        onClick={() => setThemePalette(palette.key)}
                                                        className={`flex-1 p-3 rounded-xl transition-all ${themePalette === palette.key ? 'ring-2 ring-blue-500' : 'bg-gray-100 dark:bg-[#2D2D2D]'}`}
                                                    >
                                                        <div className="flex gap-1 justify-center mb-1">
                                                            {palette.colors.map(color => (
                                                                <div key={color} className="w-4 h-4 rounded-full" style={{backgroundColor: color}} />
                                                            ))}
                                                        </div>
                                                        <p className="text-xs font-bold dark:text-white">{palette.name}</p>
                                                    </button>
                                                ))}
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <div className="mt-4 bg-white dark:bg-[#1E1E1E] p-5 rounded-[28px] shadow-sm">
                                    <div className="flex items-center justify-between">
                                        <div>
                                            <div className="font-bold dark:text-white">Benachrichtigungen</div>
                                            <div className="text-[11px] text-gray-400 leading-snug">
                                                Freigabe im Browser erforderlich. Ohne Service Worker/FCM nur im aktiven Browser/PWA.
                                            </div>
                                        </div>
                                        <div className={`w-10 h-6 rounded-full p-1 cursor-pointer transition-colors ${notificationsEnabled ? 'bg-blue-500' : 'bg-gray-300'}`} onClick={() => { notificationsEnabled ? setNotificationsEnabled(false) : requestNotifications(); }}>
                                            <div className={`w-4 h-4 bg-white rounded-full shadow-md transform transition-transform ${notificationsEnabled ? 'translate-x-4' : ''}`}/>
                                        </div>
                                    </div>
                                </div>

                                <div className="flex justify-between items-center mb-2"><h3 className="text-sm font-bold uppercase text-gray-400">Meine Kalender</h3><button onClick={() => createNewCalendar("Neuer Kalender")} className="text-xs bg-black dark:bg-white dark:text-black text-white px-3 py-1.5 rounded-full font-bold">+</button></div>
                                
                                {/* CALENDAR SEARCH */}
                                <div className="mb-4">
                                    <input placeholder="Kalender suchen..." className="w-full bg-gray-100 dark:bg-[#1E1E1E] dark:text-white px-4 py-2 rounded-xl text-sm outline-none" value={calendarSearchTerm} onChange={e=>setCalendarSearchTerm(e.target.value)} />
                                </div>
                                
                                <div className="space-y-4">{filteredSettingsCalendars.map(cal => {
                                    const isExpanded = expandedSettingsId === cal.id;
                                    const iAmAdmin = cal.members.find(m => m.uid === user.uid)?.role === ROLES.ADMIN;
                                    return (
                                        <div key={cal.id} className={`bg-white dark:bg-[#1E1E1E] rounded-[32px] overflow-hidden shadow-sm transition-colors ${isExpanded ? 'ring-2 ring-black dark:ring-white' : ''}`}>
                                            <div className="p-5 flex items-center justify-between cursor-pointer" onClick={()=>{setExpandedSettingsId(isExpanded?null:cal.id); setEditCalendarName(cal.name);}}>
                                                <div className="flex gap-4 items-center">
                                                    <div className={`w-4 h-4 rounded-full ${CALENDAR_COLORS.find(c=>c.hex===cal.color)?.bg||'bg-gray-400'}`}/>
                                                    <div><p className="font-bold dark:text-white">{cal.name}</p><p className="text-xs text-gray-400">{cal.members.length} User</p></div>
                                                </div>
                                                <span className="text-xs text-gray-400">Edit</span>
                                            </div>
                                            {isExpanded && (
                                                <div className="px-5 pb-6 border-t border-gray-50 dark:border-gray-800 pt-4">
                                                    <div className="mb-4 flex gap-2">
                                                        <input className="flex-1 bg-gray-50 dark:bg-[#2D2D2D] dark:text-white rounded-xl px-3 py-2 text-sm font-bold outline-none" value={editCalendarName} onChange={(e) => setEditCalendarName(e.target.value)} />
                                                        <button onClick={()=>updateCalendar(cal.id, {name: editCalendarName})} className="bg-black dark:bg-white dark:text-black text-white px-3 rounded-xl"><Icon name="check" size={16}/></button>
                                                    </div>
                                                    
                                                    {/* MEMBER MANAGEMENT */}
                                                    <div className="mb-4 bg-gray-50 dark:bg-[#2D2D2D] p-4 rounded-2xl">
                                                        <span className="text-sm font-bold dark:text-white mb-2 block">Mitglieder</span>
                                                        <div className="space-y-2 mb-3">
                                                            {cal.members.map(m => (
                                                                <div key={m.uid} className="flex justify-between items-center text-xs dark:text-gray-300">
                                                                    <span>{m.name} {m.role === ROLES.ADMIN && '(Admin)'}</span>
                                                                    {iAmAdmin && m.uid !== user.uid && (
                                                                        <button onClick={() => removeMemberFromCalendar(cal.id, m.uid)} className="text-red-500"><Icon name="trash" size={14}/></button>
                                                                    )}
                                                                </div>
                                                            ))}
                                                        </div>
                                                        {iAmAdmin && (
                                                            <div className="flex gap-2">
                                                                <input className="flex-1 bg-white dark:bg-[#1E1E1E] dark:text-white rounded-lg px-2 py-1.5 text-xs outline-none" placeholder="Username suchen..." value={memberAddName} onChange={e=>setMemberAddName(e.target.value)}/>
                                                                <button onClick={()=>addMemberToCalendar(cal.id)} className="bg-black dark:bg-white dark:text-black text-white px-3 rounded-lg text-xs font-bold">Add</button>
                                                            </div>
                                                        )}
                                                    </div>

                                                    {/* SHIFT CONFIG */}
                                                    <div className="mb-4 bg-gray-50 dark:bg-[#2D2D2D] p-4 rounded-2xl">
                                                        <div className="flex items-center justify-between mb-2">
                                                            <span className="text-sm font-bold dark:text-white">Schichtplan</span>
                                                            <div className={`w-10 h-6 rounded-full p-1 cursor-pointer transition-colors ${cal.shiftEnabled ? 'bg-green-500' : 'bg-gray-300'}`} onClick={()=>toggleShiftEnabled(cal.id, !cal.shiftEnabled)}>
                                                                <div className={`w-4 h-4 bg-white rounded-full shadow-md transform transition-transform ${cal.shiftEnabled ? 'translate-x-4' : ''}`}/>
                                                            </div>
                                                        </div>
                                                        {cal.shiftEnabled && (
                                                            <div>
                                                                <div className="space-y-2 mb-2">
                                                                    {(cal.shiftDefinitions||[]).map(shift => (
                                                                        <div key={shift.id} className="flex justify-between items-center text-xs">
                                                                            <div className="flex items-center gap-2"><div className="w-3 h-3 rounded-full" style={{backgroundColor:shift.color}}/> <span>{shift.name} ({shift.time})</span></div>
                                                                            <button onClick={()=>deleteShiftDefinition(cal.id, shift.id)} className="text-red-500"><Icon name="x" size={12}/></button>
                                                                        </div>
                                                                    ))}
                                                                </div>
                                                                <div className="flex gap-1">
                                                                    <input className="w-1/3 bg-white dark:bg-[#1E1E1E] rounded-lg px-2 py-1 text-xs" placeholder="Name" value={newShift.name} onChange={e=>setNewShift({...newShift, name:e.target.value})}/>
                                                                    <input className="w-1/3 bg-white dark:bg-[#1E1E1E] rounded-lg px-2 py-1 text-xs" placeholder="Zeit" value={newShift.time} onChange={e=>setNewShift({...newShift, time:e.target.value})}/>
                                                                    <input type="color" className="w-8 h-6 rounded border-none" value={newShift.color} onChange={e=>setNewShift({...newShift, color:e.target.value})}/>
                                                                    <button onClick={()=>addShiftDefinition(cal.id)} className="bg-black text-white px-2 rounded-lg"><Icon name="plus" size={12}/></button>
                                                                </div>
                                                            </div>
                                                        )}
                                                    </div>

                                                    {/* WORK CALENDAR (Secret Trigger) */}
                                                    <div className="mb-4 bg-gray-50 dark:bg-[#2D2D2D] p-4 rounded-2xl">
                                                        <div className="flex items-center justify-between mb-1">
                                                            <span className="text-sm font-bold dark:text-white">Arbeitskalender</span>
                                                            <div className={`w-10 h-6 rounded-full p-1 cursor-pointer transition-colors ${cal.isWorkCalendar ? 'bg-blue-500' : 'bg-gray-300'}`} onClick={()=>updateCalendar(cal.id, { isWorkCalendar: !cal.isWorkCalendar })}>
                                                                <div className={`w-4 h-4 bg-white rounded-full shadow-md transform transition-transform ${cal.isWorkCalendar ? 'translate-x-4' : ''}`}/>
                                                            </div>
                                                        </div>
</div>

                                                    <button onClick={()=>{navigator.clipboard.writeText(cal.id); showToast("Code kopiert")}} className="w-full py-3 mb-2 bg-gray-50 dark:bg-[#2D2D2D] dark:text-white rounded-xl font-bold text-xs flex items-center justify-center gap-2">ID Kopieren</button>
                                                    {iAmAdmin && <button onClick={() => handleDeleteCalendar(cal.id)} className="w-full py-3 bg-red-50 dark:bg-red-900/20 text-red-500 rounded-xl font-bold text-xs">LÃ¶schen</button>}
                                                </div>
                                            )}
                                        </div>
                                    );
                                })}</div>
                                <div className="mt-8 pt-8 border-t border-gray-100 dark:border-gray-800"><button onClick={()=>auth.signOut()} className="w-full py-4 text-red-500 font-bold bg-white dark:bg-[#1E1E1E] rounded-2xl shadow-sm">Abmelden</button></div>
                            </div>
                        </div>
                    )}

                    {/* SHIFT SELECTOR MODAL */}
                    {showShiftSelector && (
                        <div className="fixed inset-0 bg-black/40 backdrop-blur-sm z-[80] flex items-center justify-center p-4" onClick={() => { setShowShiftSelector(false); setDragSelection({start:null, end:null, isDragging:false}); }}>
                            <div className="bg-white dark:bg-[#1E1E1E] w-full max-w-xs rounded-[32px] p-6 shadow-2xl scale-in" onClick={e=>e.stopPropagation()}>
                                <h3 className="text-lg font-bold mb-4 dark:text-white text-center">Schicht wÃ¤hlen</h3>
                                <p className="text-center text-xs text-gray-400 mb-4">{getDatesInRange(dragSelection.start, dragSelection.end).length} Tag(e) gewÃ¤hlt</p>
                                <div className="space-y-2">
                                    {(activeCalendar?.shiftDefinitions||[]).map(shift => (
                                        <button key={shift.id} onClick={()=>assignShift(shift)} className="w-full p-4 rounded-xl font-bold text-white shadow-md flex justify-between" style={{backgroundColor: shift.color}}>
                                            <span>{shift.name}</span>
                                            <span className="opacity-70 text-xs mt-1">{shift.time}</span>
                                        </button>
                                    ))}
                                    <button onClick={()=>assignShift(null)} className="w-full p-4 rounded-xl font-bold bg-gray-100 dark:bg-[#2D2D2D] text-gray-500">Schicht lÃ¶schen</button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* CATEGORY MODAL */}
                    {showCategoryEditor && (
                        <div className="fixed inset-0 bg-white dark:bg-[#121212] z-[60] flex flex-col slide-up">
                            <div className="px-6 py-6 border-b border-gray-100 dark:border-gray-800 flex justify-between items-center bg-white dark:bg-[#121212] sticky top-0">
                                <div className="flex items-center gap-2">
                                    <button onClick={() => setShowCategoryEditor(false)} className="p-2 -ml-2 rounded-full"><Icon name="chevronLeft"/></button>
                                    <h2 className="text-xl font-bold dark:text-white">Kategorien</h2>
                                </div>
                            </div>
                            <div className="p-6 overflow-y-auto flex-1 bg-[#F8F9FA] dark:bg-[#000000]">
                                <div className="mb-6 flex gap-2">
                                    <input className="flex-1 bg-white dark:bg-[#1E1E1E] dark:text-white p-4 rounded-2xl outline-none shadow-sm" placeholder="Neue Hauptkategorie..." value={newCatName} onChange={e=>setNewCatName(e.target.value)}/>
                                    <button onClick={addMainCategory} className="bg-black dark:bg-white dark:text-black text-white px-5 rounded-2xl font-bold shadow-lg">Neu</button>
                                </div>
                                <div className="space-y-3">
                                    {Object.keys(categories).map(cat => {
                                        const isExpanded = expandedCatEdit === cat;
                                        return (
                                            <div key={cat} className="bg-white dark:bg-[#1E1E1E] rounded-[24px] overflow-hidden shadow-sm">
                                                <div className="p-4 flex items-center justify-between cursor-pointer" onClick={()=>setExpandedCatEdit(isExpanded?null:cat)}>
                                                    <span className="font-bold dark:text-white">{cat}</span>
                                                    <div className="flex items-center gap-2">
                                                        <span className="text-xs text-gray-400 bg-gray-100 dark:bg-[#2D2D2D] px-2 py-1 rounded-lg">{categories[cat].length} Sub</span>
                                                        <Icon name="chevronDown" size={16} className={`text-gray-400 transition-transform ${isExpanded?'rotate-180':''}`}/>
                                                    </div>
                                                </div>
                                                {isExpanded && (
                                                    <div className="px-4 pb-4 border-t border-gray-100 dark:border-gray-800 bg-gray-50 dark:bg-[#252525]">
                                                        <div className="flex flex-wrap gap-2 pt-4 mb-4">
                                                            {categories[cat].map(sub => (
                                                                <div key={sub} className="flex items-center gap-1 bg-white dark:bg-[#1E1E1E] px-3 py-1.5 rounded-xl border border-gray-200 dark:border-gray-700 shadow-sm">
                                                                    <span className="text-sm dark:text-gray-200">{sub}</span>
                                                                    <button onClick={()=>deleteSubCategory(cat, sub)} className="text-gray-400 hover:text-red-500"><Icon name="x" size={12}/></button>
                                                                </div>
                                                            ))}
                                                        </div>
                                                        <div className="flex gap-2">
                                                            <input className="flex-1 bg-white dark:bg-[#1E1E1E] dark:text-white px-3 py-2 rounded-xl text-sm outline-none border border-gray-200 dark:border-gray-700" placeholder="Neue Unterkategorie..." value={newSubCatName} onChange={e=>setNewSubCatName(e.target.value)}/>
                                                            <button onClick={()=>addSubCategory(cat)} className="bg-black dark:bgwhite dark:text-black text-white px-3 rounded-xl"><Icon name="plus" size={16}/></button>
                                                        </div>
                                                        <button onClick={()=>deleteMainCategory(cat)} className="w-full mt-4 py-2 text-red-500 text-xs font-bold uppercase bg-red-50 dark:bg-red-900/20 rounded-xl">Kategorie LÃ¶schen</button>
                                                    </div>
                                                )}
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Add Event Modal */}
                    {showAddEventModal && (
                        <div className="fixed inset-0 bg-black/30 backdrop-blur-sm z-50 flex items-end md:items-center justify-center p-4">
                            <div className="bg-white dark:bg-[#1E1E1E] w-full max-w-sm rounded-[32px] p-6 shadow-2xl slide-up max-h-[90vh] overflow-y-auto">
                                <div className="flex justify-between items-center mb-6">
                                    <h3 className="text-xl font-bold dark:text-white">Neuer Termin</h3>
                                    <button onClick={() => setShowAddEventModal(false)} className="p-2 bg-gray-50 dark:bg-[#2D2D2D] rounded-full text-gray-400"><Icon name="x" size={20}/></button>
                                </div>
                                
                                {/* Quick-Add */}
                                <div className="mb-4 p-4 bg-blue-50 dark:bg-blue-900/20 rounded-2xl">
                                    <label className="text-[10px] font-bold text-blue-600 dark:text-blue-400 uppercase mb-2 block">Quick-Add (DE)</label>
                                    <div className="flex gap-2">
                                        <input 
                                            className="flex-1 bg-white dark:bg-[#2D2D2D] dark:text-white rounded-xl p-3 outline-none text-sm" 
                                            placeholder="z.B. Morgen 15 Uhr Meeting 90min" 
                                            value={quickAddText}
                                            onChange={e => setQuickAddText(e.target.value)}
                                            onKeyPress={e => e.key === 'Enter' && handleQuickAdd()}
                                        />
                                        <button onClick={handleQuickAdd} className="px-4 bg-blue-500 text-white rounded-xl font-bold text-sm">
                                            <Icon name="send" size={16}/>
                                        </button>
                                    </div>
                                </div>
                                
                                <div className="space-y-4">
                                    {activeCalendarId === ALL_CALENDARS && (
                                        <div>
                                            <label className="text-[10px] font-bold text-gray-400 uppercase ml-1">Kalender wÃ¤hlen</label>
                                            <select className="w-full bg-gray-50 dark:bg-[#2D2D2D] dark:text-white rounded-2xl p-4 mt-1 font-bold outline-none" value={newEvent.targetCalId} onChange={e => setNewEvent({...newEvent, targetCalId: e.target.value})}>
                                                <option value="">Bitte wÃ¤hlen...</option>
                                                {myCalendars.map(c => <option key={c.id} value={c.id}>{c.name}</option>)}
                                            </select>
                                        </div>
                                    )}
                                    
                                    {/* Emoji Selector */}
                                    <div>
                                        <label className="text-[10px] font-bold text-gray-400 uppercase ml-1 mb-2 block">Emoji</label>
                                        <div className="flex gap-2 flex-wrap bg-gray-50 dark:bg-[#2D2D2D] p-3 rounded-2xl">
                                            {EMOJI_PRESETS.map(emoji => (
                                                <button
                                                    key={emoji}
                                                    onClick={() => setNewEvent({...newEvent, emoji})}
                                                    className={`w-10 h-10 rounded-lg text-xl transition-all ${newEvent.emoji === emoji ? 'bg-blue-500 scale-110' : 'hover:bg-gray-200 dark:hover:bg-[#3D3D3D]'}`}
                                                >
                                                    {emoji}
                                                </button>
                                            ))}
                                            <button
                                                onClick={() => setNewEvent({...newEvent, emoji: ''})}
                                                className="w-10 h-10 rounded-lg text-xs text-gray-400 hover:bg-gray-200 dark:hover:bg-[#3D3D3D]"
                                            >
                                                âœ•
                                            </button>
                                        </div>
                                    </div>
                                    
                                    <input className="w-full bg-gray-50 dark:bg-[#2D2D2D] dark:text-white rounded-2xl p-4 mt-1 font-bold outline-none" placeholder="Titel" value={newEvent.title} onChange={e => setNewEvent({...newEvent, title: e.target.value})}/>
                                    <textarea className="w-full bg-gray-50 dark:bg-[#2D2D2D] dark:text-white rounded-2xl p-4 mt-1 font-medium outline-none h-24 resize-none" placeholder="Notiz..." value={newEvent.description} onChange={e => setNewEvent({...newEvent, description: e.target.value})}/>
                                    
                                    {/* Time and Duration */}
                                    <div className="grid grid-cols-2 gap-3">
                                        <div>
                                            <label className="text-[10px] font-bold text-gray-400 uppercase ml-1 mb-1 block">Uhrzeit</label>
                                            <input type="time" className="w-full bg-gray-50 dark:bg-[#2D2D2D] dark:text-white rounded-2xl p-4 font-bold outline-none" value={newEvent.time} onChange={e => setNewEvent({...newEvent, time: e.target.value})}/>
                                        </div>
                                        <div>
                                            <label className="text-[10px] font-bold text-gray-400 uppercase ml-1 mb-1 block">Dauer (Min)</label>
                                            <input type="number" min="5" step="5" className="w-full bg-gray-50 dark:bg-[#2D2D2D] dark:text-white rounded-2xl p-4 font-bold outline-none" value={newEvent.durationMin} onChange={e => setNewEvent({...newEvent, durationMin: parseInt(e.target.value) || 60})}/>
                                        </div>
                                    </div>
                                    
                                    {/* Smart Suggestions */}
                                    <div>
                                        <div className="flex items-center justify-between mb-2">
                                            <label className="text-[10px] font-bold text-gray-400 uppercase ml-1">VorschlÃ¤ge</label>
                                        </div>
                                        <div className="flex gap-2">
                                            {generateSmartSuggestions(events, selectedDate, newEvent.durationMin).map((time, i) => (
                                                <button
                                                    key={i}
                                                    onClick={() => setNewEvent({...newEvent, time})}
                                                    className="flex-1 py-2 bg-green-50 dark:bg-green-900/20 text-green-600 dark:text-green-400 rounded-xl text-sm font-bold hover:bg-green-100 dark:hover:bg-green-900/30"
                                                >
                                                    {time}
                                                </button>
                                            ))}
                                        </div>
                                    </div>
                                    
                                    {/* Focus Mode Toggle */}
                                    <div className="flex items-center gap-3 bg-purple-50 dark:bg-purple-900/20 p-4 rounded-2xl">
                                        <input type="checkbox" id="focusMode" className="custom-checkbox" checked={newEvent.isFocus} onChange={e => setNewEvent({...newEvent, isFocus: e.target.checked, durationMin: e.target.checked ? 90 : 60})} />
                                        <label htmlFor="focusMode" className="text-sm font-bold text-purple-600 dark:text-purple-400 cursor-pointer select-none flex items-center gap-2">
                                            ðŸŽ¯ Fokusblock {newEvent.isFocus && `(${newEvent.durationMin} min)`}
                                        </label>
                                    </div>
                                    
                                    <div className="flex items-center gap-3 bg-gray-50 dark:bg-[#2D2D2D] p-4 rounded-2xl">
                                        <input type="checkbox" id="recurrence" className="custom-checkbox" checked={newEvent.recurrence} onChange={e => setNewEvent({...newEvent, recurrence: e.target.checked})} />
                                        <label htmlFor="recurrence" className="text-sm font-bold dark:text-white cursor-pointer select-none">JÃ¤hrlich (Geburtstag)</label>
                                    </div>
                                    
                                    <div className="grid grid-cols-2 gap-3">
                                        <select className="w-full bg-gray-50 dark:bg-[#2D2D2D] dark:text-white rounded-2xl p-4 font-bold outline-none text-sm appearance-none" value={newEvent.category} onChange={e => setNewEvent({...newEvent, category: e.target.value, subCategory: categories[e.target.value]?.[0] || ''})}>
                                            {Object.keys(categories).map(c => <option key={c} value={c}>{c}</option>)}
                                        </select>
                                        <select className="w-full bg-gray-50 dark:bg-[#2D2D2D] dark:text-white rounded-2xl p-4 font-bold outline-none text-sm appearance-none" value={newEvent.subCategory} onChange={e => setNewEvent({...newEvent, subCategory: e.target.value})}>
                                            {categories[newEvent.category]?.map(sc => <option key={sc} value={sc}>{sc}</option>)}
                                        </select>
                                    </div>
                                    
                                    <div className="pt-4 flex flex-col gap-2">
                                        <button onClick={()=>handleCreateEvent()} className="w-full py-4 bg-black dark:bg-white dark:text-black text-white rounded-2xl font-bold shadow-lg">Speichern</button>
                                        <button onClick={()=>handleCreateEvent(true)} className="w-full py-4 bg-gray-100 dark:bg-[#2D2D2D] text-gray-600 dark:text-white rounded-2xl font-bold">Als Anfrage senden</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Add Friend - REMAINS FOR GLOBAL SEARCH IF NEEDED, BUT MEMBER ADD IS NOW IN CALENDAR SETTINGS */}
                    {showSearchModal && <div className="fixed inset-0 bg-black/40 backdrop-blur-sm z-[60] flex items-center justify-center p-4"><div className="bg-white dark:bg-[#1E1E1E] w-full max-w-sm rounded-[32px] p-6 shadow-2xl slide-up"><h3 className="text-lg font-bold mb-4 dark:text-white">Freund +</h3><input className="w-full bg-gray-50 dark:bg-[#2D2D2D] dark:text-white p-4 rounded-xl mb-4 font-bold outline-none" placeholder="Username" value={searchName} onChange={e => setSearchName(e.target.value)} /><button onClick={()=>{}} className="w-full py-3 bg-black dark:bgwhite dark:text-black text-white rounded-xl font-bold mb-2">HinzufÃ¼gen</button><button onClick={()=>setShowSearchModal(false)} className="w-full py-3 text-gray-400 text-sm font-bold">Abbrechen</button></div></div>}

                    {showVaultPanel && (
                        <VaultPanel
                            user={user}
                            db={db}
                            userData={userData}
                            notificationsEnabled={notificationsEnabled}
                            setNotificationsEnabled={setNotificationsEnabled}
                            showToast={showToast}
                            onClose={() => setShowVaultPanel(false)}
                        />
                    )}

                    {showTimeTrackingPanel && (
                        <TimeTrackingPanel
                            user={user}
                            db={db}
                            showToast={showToast}
                            onClose={() => setShowTimeTrackingPanel(false)}
                        />
                    )}

                    {showHabitsPanel && (
                        <HabitsPanel
                            user={user}
                            db={db}
                            showToast={showToast}
                            onClose={() => setShowHabitsPanel(false)}
                        />
                    )}

                    {/* Conflict Modal */}
                    {showConflictModal && conflictInfo && (
                        <div className="fixed inset-0 bg-black/40 backdrop-blur-sm z-[70] flex items-center justify-center p-4">
                            <div className="bg-white dark:bg-[#1E1E1E] w-full max-w-md rounded-[32px] p-6 shadow-2xl slide-up">
                                <h3 className="text-xl font-bold text-red-600 dark:text-red-400 mb-4">âš ï¸ Konflikt erkannt</h3>
                                <p className="text-sm text-gray-600 dark:text-gray-300 mb-4">
                                    Das Event Ã¼berschneidet sich mit:
                                </p>
                                <div className="space-y-2 mb-4 max-h-40 overflow-y-auto">
                                    {conflictInfo.conflicts.map(conf => {
                                        const confDate = conf.date instanceof Date ? conf.date : conf.date.toDate();
                                        return (
                                            <div key={conf.id} className="bg-red-50 dark:bg-red-900/20 p-3 rounded-xl text-sm">
                                                <p className="font-bold text-red-600 dark:text-red-400">{conf.title}</p>
                                                <p className="text-xs text-gray-500 dark:text-gray-400">
                                                    {confDate.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' })} ({conf.durationMin || 60} min)
                                                </p>
                                            </div>
                                        );
                                    })}
                                </div>
                                {conflictInfo.suggestedTime && (
                                    <div className="bg-green-50 dark:bg-green-900/20 p-4 rounded-xl mb-4">
                                        <p className="text-sm font-bold text-green-600 dark:text-green-400 mb-2">ðŸ’¡ Vorschlag:</p>
                                        <p className="text-sm text-gray-600 dark:text-gray-300">
                                            NÃ¤chster freier Slot: <strong>{conflictInfo.suggestedTime}</strong>
                                        </p>
                                    </div>
                                )}
                                <div className="flex gap-2">
                                    <button 
                                        onClick={() => {
                                            setShowConflictModal(false);
                                            setConflictInfo(null);
                                        }}
                                        className="flex-1 py-3 bg-gray-100 dark:bg-[#2D2D2D] dark:text-white rounded-xl font-bold"
                                    >
                                        Abbrechen
                                    </button>
                                    {conflictInfo.suggestedTime && (
                                        <button 
                                            onClick={async () => {
                                                if (conflictInfo.isMove) {
                                                    // Moving existing event
                                                    const newDate = new Date(conflictInfo.targetDate);
                                                    const [h, m] = conflictInfo.suggestedTime.split(':');
                                                    newDate.setHours(parseInt(h), parseInt(m));
                                                    await db.collection('calendars').doc(conflictInfo.draggedEvent.calendarId).collection('events')
                                                        .doc(conflictInfo.draggedEvent.id).update({ date: firebase.firestore.Timestamp.fromDate(newDate) });
                                                    showToast('Event verschoben');
                                                } else {
                                                    // Creating new event
                                                    setNewEvent({...newEvent, time: conflictInfo.suggestedTime});
                                                    showToast('Zeit angepasst');
                                                }
                                                setShowConflictModal(false);
                                                setConflictInfo(null);
                                            }}
                                            className="flex-1 py-3 bg-green-500 text-white rounded-xl font-bold"
                                        >
                                            Vorschlag nutzen
                                        </button>
                                    )}
                                    <button 
                                        onClick={async () => {
                                            if (conflictInfo.isMove) {
                                                await db.collection('calendars').doc(conflictInfo.draggedEvent.calendarId).collection('events')
                                                    .doc(conflictInfo.draggedEvent.id).update({ date: firebase.firestore.Timestamp.fromDate(conflictInfo.targetDate) });
                                            } else {
                                                const coll = conflictInfo.isRequest ? 'requests' : 'events';
                                                await db.collection('calendars').doc(conflictInfo.targetId).collection(coll).add(conflictInfo.eventData);
                                                setShowAddEventModal(false);
                                            }
                                            showToast('Trotzdem gespeichert');
                                            setShowConflictModal(false);
                                            setConflictInfo(null);
                                        }}
                                        className="flex-1 py-3 bg-orange-500 text-white rounded-xl font-bold"
                                    >
                                        Trotzdem
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Templates Modal */}
                    {showTemplatesModal && (
                        <div className="fixed inset-0 bg-black/40 backdrop-blur-sm z-[60] flex items-center justify-center p-4">
                            <div className="bg-white dark:bg-[#1E1E1E] w-full max-w-md rounded-[32px] p-6 shadow-2xl slide-up">
                                <div className="flex justify-between items-center mb-6">
                                    <h3 className="text-xl font-bold dark:text-white">Templates</h3>
                                    <button onClick={() => setShowTemplatesModal(false)} className="p-2 bg-gray-50 dark:bg-[#2D2D2D] rounded-full text-gray-400">
                                        <Icon name="x" size={20}/>
                                    </button>
                                </div>
                                <div className="space-y-3">
                                    {Object.entries(CALENDAR_TEMPLATES).map(([key, tmpl]) => (
                                        <div key={key} className="bg-gray-50 dark:bg-[#2D2D2D] p-4 rounded-2xl">
                                            <h4 className="font-bold dark:text-white mb-2">{tmpl.name}</h4>
                                            <p className="text-xs text-gray-500 dark:text-gray-400 mb-3">
                                                {tmpl.events.length} Events Ã¼ber {Math.max(...tmpl.events.map(e => e.day)) + 1} Tage
                                            </p>
                                            <div className="flex gap-2">
                                                <input 
                                                    type="date" 
                                                    id={`template-date-${key}`}
                                                    defaultValue={new Date().toISOString().split('T')[0]}
                                                    className="flex-1 bg-white dark:bg-[#1E1E1E] dark:text-white rounded-xl p-2 text-sm outline-none"
                                                />
                                                <button 
                                                    onClick={() => {
                                                        const dateInput = document.getElementById(`template-date-${key}`);
                                                        const targetId = activeCalendarId === ALL_CALENDARS ? myCalendars[0]?.id : activeCalendarId;
                                                        applyTemplate(key, new Date(dateInput.value), targetId);
                                                    }}
                                                    className="px-4 py-2 bg-black dark:bg-white dark:text-black text-white rounded-xl text-sm font-bold"
                                                >
                                                    Anwenden
                                                </button>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Day Copy Modal */}
                    {showDayCopyModal && (
                        <div className="fixed inset-0 bg-black/40 backdrop-blur-sm z-[60] flex items-center justify-center p-4">
                            <div className="bg-white dark:bg-[#1E1E1E] w-full max-w-md rounded-[32px] p-6 shadow-2xl slide-up">
                                <div className="flex justify-between items-center mb-6">
                                    <h3 className="text-xl font-bold dark:text-white">Tag kopieren</h3>
                                    <button onClick={() => setShowDayCopyModal(false)} className="p-2 bg-gray-50 dark:bg-[#2D2D2D] rounded-full text-gray-400">
                                        <Icon name="x" size={20}/>
                                    </button>
                                </div>
                                <div className="space-y-4">
                                    <div>
                                        <label className="text-xs font-bold text-gray-400 uppercase mb-2 block">Quell-Datum</label>
                                        <input 
                                            type="date" 
                                            id="copy-source-date"
                                            defaultValue={selectedDate.toISOString().split('T')[0]}
                                            className="w-full bg-gray-50 dark:bg-[#2D2D2D] dark:text-white rounded-xl p-3 outline-none"
                                        />
                                    </div>
                                    <div>
                                        <label className="text-xs font-bold text-gray-400 uppercase mb-2 block">Ziel-Datum</label>
                                        <input 
                                            type="date" 
                                            id="copy-target-date"
                                            defaultValue={new Date(selectedDate.getTime() + 86400000).toISOString().split('T')[0]}
                                            className="w-full bg-gray-50 dark:bg-[#2D2D2D] dark:text-white rounded-xl p-3 outline-none"
                                        />
                                    </div>
                                    <button 
                                        onClick={() => {
                                            const sourceInput = document.getElementById('copy-source-date');
                                            const targetInput = document.getElementById('copy-target-date');
                                            const targetId = activeCalendarId === ALL_CALENDARS ? myCalendars[0]?.id : activeCalendarId;
                                            copyDayEvents(new Date(sourceInput.value), new Date(targetInput.value), targetId);
                                        }}
                                        className="w-full py-3 bg-black dark:bg-white dark:text-black text-white rounded-xl font-bold"
                                    >
                                        Kopieren
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {toast && <div className="fixed bottom-10 left-1/2 -translate-x-1/2 bg-black dark:bg-white dark:text-black text-white px-6 py-3 rounded-full text-sm font-bold shadow-xl z-[100] flex items-center gap-2 slide-up"><Icon name="check" size={16} className="text-green-400"/> {toast}</div>}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>